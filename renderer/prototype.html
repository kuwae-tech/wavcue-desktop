<!DOCTYPE html>
<html lang="ja"><head><meta charset="utf-8"/><meta content="width=device-width,initial-scale=1" name="viewport"/><title>WavCue</title><style>
/* CODE ORGANIZATION
   - Root tokens
   - Base
   - Layout
   - Components
   - Dialogs
   - Tables/Lists
   - Utilities
*/

/* Icon (SVG) */
.btnIcon{
  width: 14px;
  height: 14px;
  display: inline-block;
  vertical-align: -2px;
  margin-right: 8px;
  opacity: .95;
}
.btnIcon use{ pointer-events:none; }

  :root{
    --bg:#0b0c0f;
    --panel:#121417;
    --panel2:#171a1f;
    --line:#242a33;
    --text:#e9ecf1;
    --muted:#aab2bd;
    --good:#7ee7a2;
    --accent:#ffd24a;
    --warn:#fbbf24;
    --bad:#fb7185;
    --shadow: 0 18px 48px rgba(0,0,0,.45);
    --r:16px;
    --app-pad: 10px;
    --app-gap: 10px;
    --brand-logo-h: 44px;
    --bottom-line-h: 240px;
    --fileList-min-h: var(--bottom-line-h);
    --wave-min-h: 210px;
    --stereo-box-h: var(--bottom-line-h);
    --titlebar-drag-h: 34px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 20% 10%, #15264a 0%, var(--bg) 55%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Meiryo",sans-serif;-webkit-user-select:none;user-select:none}
  body{padding-top: var(--titlebar-drag-h)}
  .app{height:100%;display:flex;flex-direction:column;gap:var(--app-gap);padding:var(--app-pad)}
  .appHeader{
    display:flex;
    align-items:center;
    gap:12px;
    -webkit-app-region: drag;
    flex: 0 0 auto;
    overflow: visible;
    padding-bottom: 2px;
    flex-wrap: nowrap;
    white-space: nowrap;
  }
  .hdrLeft{
    flex:0 0 auto;
    display:flex;
    align-items:center;
    gap:12px;
    min-width:0;
    flex-wrap:nowrap;
    min-width:max-content;
  }
  .hdrMid{
    flex: 1 1 auto;
    min-width: 0;
  }
  .hdrRight{
    flex:0 1 auto;
    display:flex;
    align-items:center;
    gap:10px;
    margin-left:auto;
    min-width: 0;
    max-width: 55vw;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    -webkit-app-region: no-drag;
  }
  .hdrRight > *{
    flex: 0 0 auto;
  }
  .hdrRight::-webkit-scrollbar{ height: 6px; }
  .hdrRight::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.18); border-radius: 8px; }
  .hdrRight{ scrollbar-width: thin; }
  .appHeader button,
  .appHeader a,
  .appHeader input,
  .appHeader select,
  .appHeader textarea,
  .appHeader .btn,
  .appHeader .pill,
  .appHeader .chip,
  .appHeader .no-drag{
    -webkit-app-region: no-drag;
  }
  .headerActions{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .headerActions .btnIcon{
    margin-right: 0;
  }
  #tierBadge{
    font-size:11px;
    font-weight:600;
    letter-spacing:.4px;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,.4);
    background:rgba(148,163,184,.12);
    color:rgba(226,232,240,.95);
    text-transform:uppercase;
    line-height:1;
  }
  #tierBadge.tierBadge--demo{
    background:rgba(148,163,184,.16);
    border-color:rgba(148,163,184,.4);
    color:rgba(226,232,240,.92);
  }
  #tierBadge.tierBadge--standard{
    background:rgba(59,130,246,.18);
    border-color:rgba(59,130,246,.45);
    color:rgba(191,219,254,.95);
  }
  #tierBadge.tierBadge--pro{
    background:rgba(34,197,94,.18);
    border-color:rgba(34,197,94,.45);
    color:rgba(187,247,208,.95);
  }
  #licenseBanner{
    display:none;
    margin:8px 16px 0;
    padding:10px 14px;
    border-radius:12px;
    border:1px solid rgba(248,113,113,.45);
    background:rgba(248,113,113,.12);
    color:rgba(254,202,202,.95);
    font-size:13px;
    font-weight:600;
  }
  #licenseBanner.licenseBanner--standard{
    border-color:rgba(251,191,36,.45);
    background:rgba(251,191,36,.14);
    color:rgba(254,243,199,.98);
  }
  #licenseBanner.licenseBanner--demo{
    border-color:rgba(148,163,184,.4);
    background:rgba(148,163,184,.12);
    color:rgba(226,232,240,.92);
  }
  #licenseBanner.licenseBanner--withChip{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  #licenseBanner.licenseBanner--grace{
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  #licenseBanner .licenseBannerText{
    display:inline-flex;
    align-items:center;
    gap:6px;
  }
  #licenseBanner .licenseBannerMeta{
    font-size:11px;
    font-weight:600;
    opacity:.85;
    white-space:nowrap;
  }
  #licenseBanner .demoRemainingChip{
    display:inline-flex;
    align-items:center;
    gap:4px;
    font-size:11px;
    font-weight:600;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,.35);
    background:rgba(148,163,184,.12);
    color:rgba(226,232,240,.9);
    white-space:nowrap;
  }
  #licenseBanner .demoRemainingValue{
    font-weight:600;
  }
  #licenseBanner .demoRemainingValue--low{
    font-weight:700;
    color:rgba(255,255,255,.98);
    text-shadow:0 0 6px rgba(255,255,255,.28);
  }
  #licenseBanner.show{
    display:block;
  }
  #licenseBanner.licenseBanner--grace.show{
    display:flex;
  }
  #licenseBanner.licenseBanner--withChip.show{
    display:flex;
  }
  .brand{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .brandMark{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    color: rgba(230,232,238,.92);
  }
  .brandMark img{
    display:block;
  }
  .brandLogo,
  .brandLogo img,
  .brandLogo svg{
    height: var(--brand-logo-h);
    width: auto;
    max-height: var(--brand-logo-h);
    display:block;
  }
  .btnRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .btn{
    appearance:none;border:1px solid var(--line);background:rgba(255,255,255,.04);
    color:var(--text);padding:9px 10px;border-radius:12px;cursor:pointer;
    font-size:12px;line-height:1;display:inline-flex;gap:8px;align-items:center;
  }
  .btn:hover{background:rgba(255,255,255,.07)}
  .btn:disabled{opacity:.45;cursor:not-allowed}
  .btn.primary{border-color:rgba(56,189,248,.45);background:rgba(56,189,248,.14)}
  .btn.primary:hover{background:rgba(56,189,248,.18)}
  .btn.good{border-color:rgba(126,231,162,.45);background:rgba(126,231,162,.12)}
  .btn.good:hover{background:rgba(126,231,162,.16)}
  .btn.danger{border-color:rgba(255,91,110,.5);background:rgba(255,91,110,.14)}
  .btn.danger:hover{background:rgba(255,91,110,.2)}

  .pill{
    font-size:11px;color:var(--muted);border:1px solid var(--line);border-radius:999px;padding:6px 10px;
    background:rgba(255,255,255,.03)
  }
  .main{
    flex:1;
    min-height:0;
    display:grid;
    grid-template-columns: minmax(0,1fr) 340px;
    gap:10px;
  }
  .panel{
    min-height:0;background:rgba(15,26,46,.72);border:1px solid var(--line);border-radius:var(--r);box-shadow:var(--shadow);
  }
  .panel.left{
    min-height:0;
    display:flex;
    flex-direction:column;
  }
  .left{display:flex;flex-direction:column;min-height:0;min-width:0;overflow:hidden}
  .panel.right{
    min-height:0;
    width:340px;
    overflow:auto;
  }
  .sectionHead{
    display:flex;justify-content:space-between;align-items:center;gap:10px;
    padding:10px 12px;border-bottom:1px solid var(--line);
  }
  .sectionHead .title{display:flex;flex-direction:column;gap:2px}
  .sectionHead .title b{font-size:12px}
  .sectionHead .title span{font-size:11px;color:var(--muted)}
  .fileName{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;font-size:11px;color:rgba(229,231,235,.82);max-width:52vw;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .waveWrap{flex:1;min-height:0;padding:10px;display:flex;flex-direction:column;gap:10px}
  .waveBox{
    position:relative;flex:1;min-height:0;
    border:1px solid var(--line);border-radius:14px;overflow:hidden;background:rgba(0,0,0,.14);
  }
  #waveBox{flex:1;min-height:0}
  #wave{
    width:100% !important;height:100% !important;
    display:block;
    touch-action:none;
    cursor:crosshair;
  }
  #cueCanvas{
    position:absolute;left:0;top:0;
    width:100% !important;height:100% !important;
    display:block;
    pointer-events:none;
  }
  .waveHud{
    position:absolute;left:10px;top:10px;
    display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    pointer-events:none;
  }
  .hudChip{
    pointer-events:none;
    font-size:11px;color:rgba(229,231,235,.84);
    background:rgba(0,0,0,.35);border:1px solid rgba(148,163,184,.22);
    padding:6px 8px;border-radius:999px;
    backdrop-filter: blur(6px);
  }
  .analyzers{
    flex:0 0 180px;
    height:180px;
    min-height:180px;
    max-height:180px;
    display:flex;
    gap:10px;
    align-items:stretch;
    min-height:0;
    min-width:0;
  }
  .meterBlock,
  .imagerBlock,
  .scopeBlock{
    display:flex;
    align-items:stretch;
    justify-content:center;
  }
  .meterBlock{
    flex:0 0 120px;
    width:120px;
    min-width:120px;
    max-width:120px;
  }
  .imagerBlock,
  .scopeBlock{
    flex:0 0 180px;
    width:180px;
    height:180px;
    min-width:180px;
    max-width:180px;
    border-radius:12px;
    overflow:hidden;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
  }
  .meterBox,
  .scopeBox{
    border:1px solid var(--line);border-radius:14px;overflow:hidden;background:rgba(0,0,0,.12);
  }
  .meterBox{height:180px}
  .scopeBox{
    flex:1;
    min-width:0;
    min-height:0;
    height:100%;
    width:100%;
    display:flex;
  }
  #meterCanvas{width:100% !important;height:100% !important;display:block}
  #imagerCanvas{width:100% !important;height:100% !important;display:block}
  .right{display:flex;flex-direction:column;min-height:0}
  .cueSide{
    width: 340px;
    min-width: 340px;
    max-width: 340px;
    flex: 0 0 340px;
    overflow: auto;
    border-left: 1px solid rgba(255,255,255,.08);
  }
  .right .sectionHead{border-bottom:1px solid var(--line)}
  .sidePad{padding:10px;display:flex;flex-direction:column;gap:10px;min-height:0}
  .card{border:1px solid var(--line);border-radius:14px;background:rgba(255,255,255,.03);padding:10px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .rowBetween{display:flex;gap:8px;align-items:center;justify-content:space-between}
  #btnAddPair{
    white-space:nowrap;
    line-height:1.1;
  }
  .cueSide .row{
    flex-wrap:nowrap;
  }
  .cueSide .switchWrap,
  .cueSide .linkMiniLabel{
    white-space:nowrap;
  }
  label{font-size:11px;color:var(--muted)}
  input[type="text"]{
    width:100%;padding:10px;border-radius:12px;
    border:1px solid var(--line);background:rgba(0,0,0,.15);color:var(--text);outline:none;
    font-size:12px
  }
  input,
  textarea,
  [contenteditable="true"],
  .allowSelect{
    -webkit-user-select:text;
    user-select:text;
  }
  .cueTableWrap{flex:1;min-height:0;border:1px solid var(--line);border-radius:14px;overflow:auto;background:rgba(0,0,0,.10)}
  .cueTableWrap thead th{
    background: rgba(255,255,255,.03);
  }
  table{width:100%;border-collapse:collapse;font-size:12px}
  thead th{
    position:sticky;top:0;z-index:2;
    background:rgba(17,31,54,.92);backdrop-filter: blur(8px);
    text-align:left;padding:7px;border-bottom:1px solid var(--line);font-size:11px;color:var(--muted)
  }
  tbody td{padding:6px;border-bottom:1px solid rgba(148,163,184,.12)}
  tbody tr:hover{background:rgba(255,255,255,.03)}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
  .opBtn{padding:7px 9px;border-radius:10px;border:1px solid var(--line);background:rgba(255,255,255,.04);color:var(--text);cursor:pointer;font-size:11px}
  .opBtn:hover{background:rgba(255,255,255,.07)}
  .opBtn.bad{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.12)}
  .opBtn.bad:hover{background:rgba(251,113,133,.16)}

  /* Drop overlay */
  #dropOverlay{
    position:fixed;inset:0;
    display:none;align-items:center;justify-content:center;
    background:rgba(2,6,23,.65);
    backdrop-filter: blur(10px);
    z-index:9999;
    pointer-events:none;
  }
  #dropOverlay.show{display:flex;pointer-events:auto}
  #dropOverlay .box{
    width:min(560px, calc(100% - 24px));
    border-radius:20px;border:1px dashed rgba(56,189,248,.55);
    background:rgba(15,26,46,.65);
    padding:18px 18px;
    box-shadow:var(--shadow);
    text-align:center;
  }
  #dropOverlay .box .big{font-size:18px;font-weight:700;margin-bottom:6px}
  #dropOverlay .box .small{font-size:12px;color:var(--muted)}
  #dropOverlay .box .small2{margin-top:10px;font-size:11px;color:rgba(229,231,235,.75);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

  /* Progress overlay */
  #progressOverlay{
    position:fixed;inset:0;
    display:none;
    align-items:center;justify-content:center;
    background:rgba(0,0,0,.55);
    z-index:9999;
  }
  #progressOverlay.show{display:flex}
  #progressOverlay .box{
    width:min(540px,92vw);
    border:1px solid var(--line);
    border-radius:16px;
    background:rgba(17,31,54,.92);
    backdrop-filter: blur(10px);
    box-shadow:0 20px 60px rgba(0,0,0,.45);
    padding:14px 16px;
  }
  #progressOverlay .meta{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px}
  #progressOverlay .msg{font-size:13px}
  #progressOverlay .pct{font-size:11px;color:var(--muted);white-space:nowrap}
  #progressOverlay .bar{
    position:relative;
    height:10px;border-radius:999px;
    background:rgba(255,255,255,.08);
    overflow:hidden;
    border:1px solid rgba(148,163,184,.18)
  }
  #progressOverlay .bar>div{
    height:100%;width:0%;
    background:var(--good);
    opacity:.85;
    transition:width .12s ease;
    transform:translateX(0);
    border-radius:999px;
  }
  #progressOverlay .bar>div.indet{
    width:40%;
    transition:none;
    animation:progIndet 1.1s infinite ease-in-out;
  }
  @keyframes progIndet{
    0%{transform:translateX(-130%)}
    100%{transform:translateX(260%)}
  }
  #progressOverlay .sub{font-size:11px;color:var(--muted);margin-top:8px;line-height:1.4}
  /* Bulk overlay */
  #bulkOverlay{
    position:fixed;
    inset:0;
    background:rgba(2,6,23,0.65);
    backdrop-filter: blur(6px);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:10040;
  }
  #bulkOverlay.show{display:flex}
  #bulkOverlay .box{
    width:min(520px, 90vw);
    padding:16px;
    border-radius:16px;
    background:rgba(15,23,42,0.95);
    border:1px solid rgba(255,255,255,0.15);
    box-shadow:0 20px 60px rgba(0,0,0,0.35);
  }
  #bulkOverlay .meta{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px}
  #bulkOverlay .msg{font-size:13px}
  #bulkOverlay .pct{font-size:11px;color:var(--muted);white-space:nowrap}
  #bulkOverlay .bar{width:100%;height:8px;border-radius:999px;background:rgba(255,255,255,0.08);overflow:hidden}
  #bulkOverlay .bar>div{height:100%;width:0%;border-radius:999px;background:linear-gradient(90deg,rgba(96,165,250,0.95),rgba(34,197,94,0.95))}
  #bulkOverlay .sub{font-size:11px;color:var(--muted);margin-top:8px;line-height:1.4}

  
  /* ===== QC preset export selector overlay ===== */
  dialog.scExportSelDialog{
    border:none;
    padding:0;
    background:transparent;
    width: min(720px, 96vw);
  }
  dialog.scExportSelDialog::backdrop{
    background: rgba(0,0,0,.55);
  }
  /* Keep the dialog itself non-scroll; scroll only inside list */
  dialog.scExportSelDialog .box{
    width: min(720px, 96vw);
    max-height: min(86vh, 720px);
    overflow: hidden;
    display:flex;
    flex-direction:column;
    gap:0;
    border:1px solid var(--line);
    border-radius:18px;
    background: var(--panel);
    padding:14px 14px 12px;
    box-shadow:0 20px 70px rgba(0,0,0,.5);
  }
  dialog.scExportSelDialog .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  dialog.scExportSelDialog .list{
    margin-top:10px;
    border:1px solid var(--line);
    border-radius:14px;
    padding:10px;
    background:rgba(255,255,255,.03);
    overflow:auto;
    flex:1;
    min-height: 0;
  }
  dialog.scExportSelDialog .item{display:flex;gap:10px;align-items:flex-start;padding:8px 6px;border-bottom:1px dashed rgba(255,255,255,.08)}
  dialog.scExportSelDialog .item:last-child{border-bottom:none}
  dialog.scExportSelDialog .item label{cursor:pointer}
  dialog.scExportSelDialog .mutedSmall{font-size:12px;color:var(--muted)}
  /* ===== /QC preset export selector overlay ===== */

  /* Modal */

  /* ===== ChunkDialog: tabs + inner scroll ===== */
  body.modalLock{ overflow:hidden; }

  dialog#chunkDialog{
    max-height: min(92vh, 980px);
    width: min(1100px, 92vw);
  }
  .chunkModalBody{
    display:flex;
    flex-direction:column;
    gap:12px;
    overflow:hidden;
  }
  .chunkTabs{
    flex:1;
    min-height:0;
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
  }
  .tabBar{
    display:flex;
    gap:8px;
    padding:3px;
    border:1px solid var(--line, rgba(255,255,255,.15));
    border-radius:14px;
    background:rgba(0,0,0,.14);
  }
  .tabBtn{
    appearance:none;
    border:1px solid transparent;
    border-radius:12px;
    background:transparent;
    color:var(--text, #fff);
    padding:8px 12px;
    cursor:pointer;
    font-size:12px;
    line-height:1;
  }
  .tabBtn.active{
    background:rgba(255,255,255,.08);
    border-color:rgba(255,255,255,.12);
  }
  .tabPanels{
    flex:1;
    min-height:0;
    position:relative;
    overflow:hidden;
  }
  .tabPanel{
    display:none;
    height:100%;
    overflow:auto;
    overscroll-behavior: contain;
    padding-right:6px;
  }
  .tabPanel.active{ display:block; }

  .chunkSectionTitle{
    display:flex;
    align-items:baseline;
    gap:10px;
    margin:6px 0 10px;
  }
  .chunkMeta{ opacity:.75; font-size:12px; }

  .kvGrid{
    display:grid;
    grid-template-columns: 220px 1fr;
    gap:8px 12px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    padding:12px;
    background:rgba(0,0,0,.10);
  }
  .kvK{
    font-size:12px;
    opacity:.82;
    align-self:start;
    padding-top:2px;
  }
  .kvV{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space:pre-wrap;
    word-break:break-word;
    opacity:.95;
  }

  .fieldBlock textarea{
    min-height: 120px;
  }
  #cmcdRawArea{
    min-height: 180px;
  }
  .advBox{
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    padding:10px 12px;
    background:rgba(0,0,0,.08);
  }
  .advBox summary{
    cursor:pointer;
    user-select:none;
    font-size:12px;
    opacity:.9;
  }

  .logBoxSmall{
    height: 120px;
    overflow:auto;
  }
  
  /* --- ChunkDialog: tab height unify + no page/dialog scroll (safe patch) --- */
  /* NOTE: keep dialog default rendering; only constrain the content area */
  dialog#chunkDialog{
    overflow: hidden; /* prevent dialog internal scrollbars */
  }

  /* modalHead stays visible; body is constrained to viewport */
  dialog#chunkDialog .chunkModalBody{
    /* fill available space under the header inside the dialog */
    max-height: calc(92vh - 70px);
    height: calc(92vh - 70px);
    overflow: hidden;
  }

  dialog#chunkDialog .chunkTabs{
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  dialog#chunkDialog .tabPanels{
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
  }

  /* Only the active tab content scrolls */
  dialog#chunkDialog .tabPanel{
    height: 100%;
    overflow: auto;
    overscroll-behavior: contain;
  }

  /* cmcd: prevent the grid wrapper from forcing layout growth */
  dialog#chunkDialog .cmcdGridWrap{
    max-height: none;
  }

  /* log: do not force fixed height; scroll is handled by the tabPanel */
  dialog#chunkDialog #logBox2{
    height: auto;
  }
  dialog#chunkDialog .modalHead{
    border-bottom:none;
  }
  /* --- /ChunkDialog patch --- */

  /* ===== /ChunkDialog ===== */

  dialog{
    border:1px solid var(--line);
    border-radius:18px;
    background:rgba(15,26,46,.92);
    color:var(--text);
    box-shadow:var(--shadow);
    position:relative;
    width:min(980px, calc(100% - 24px));
  }
  dialog::backdrop{background:rgba(2,6,23,.60);backdrop-filter: blur(6px)}
  dialog.standardGraceDialog{
    width:min(520px, calc(100% - 32px));
    border-radius:16px;
    border:1px solid rgba(148,163,184,.35);
    background:rgba(15,23,42,.98);
    padding:0;
  }
  dialog.standardGraceDialog .stdGraceBody{
    padding:20px 22px 12px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  dialog.standardGraceDialog .stdGraceTitle{
    font-size:14px;
    font-weight:700;
  }
  dialog.standardGraceDialog .stdGraceMsg{
    font-size:13px;
    line-height:1.6;
    color:rgba(226,232,240,.92);
    white-space: pre-line;
  }
  dialog.standardGraceDialog .stdGraceActions{
    display:flex;
    justify-content:flex-end;
    gap:10px;
    padding:0 22px 20px;
  }
  .modalHead{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:12px 14px;border-bottom:1px solid var(--line);position:relative}
  .dlgHead{position:relative}
  .dialogShell .modalHead,
  .dialogShell .dlgHead{padding-right:52px}
  .dialogShell .modalBody{padding-right:52px}
  .dialogShellBare{padding-top:36px;padding-right:36px}
  .modalCloseBtn{
    position:absolute;
    top:6px;
    right:6px;
    width:32px;
    height:32px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(15,23,42,0.75);
    color:var(--text);
    font-size:18px;
    line-height:1;
    cursor:pointer;
  }
  .modalCloseBtn:hover{ background:rgba(255,255,255,0.16); }
  .modalBody{padding:12px 14px}
  .modalGrid{display:grid;grid-template-columns: 1fr 1fr;gap:12px}
  .settingsDialog{
    width:min(1040px, calc(100% - 24px));
    color-scheme: dark;
  }
  .settingsDialog .settingsGrid{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap:10px;
  }
  .settingsDialog .settingsCard{
    border:1px solid var(--line);
    border-radius:16px;
    background:rgba(255,255,255,.03);
    padding:10px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .settingsDialog .settingsCard h3{
    margin:0;
    font-size:12px;
    letter-spacing:.2px;
  }
  .settingsDialog .settingsBlock{
    display:flex;
    flex-direction:column;
    gap:8px;
    padding-top:8px;
  }
  .settingsDialog .settingsBlock + .settingsBlock{
    border-top:1px solid var(--line);
    margin-top:2px;
  }
  .settingsDialog .settingsBlockTitle{
    font-size:12px;
    color:rgba(229,231,235,.85);
    letter-spacing:.2px;
  }
  .settingsDialog .settingsBlockTitleRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .settingsDialog .settingsBadge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid rgba(255,210,74,.45);
    background:rgba(255,210,74,.12);
    color:var(--accent);
    font-size:10px;
    letter-spacing:.3px;
  }
  .settingsDialog .settingsBadge.is-hidden{
    display:none;
  }
  .settingsDialog .settingsLog{
    border:1px solid var(--line);
    border-radius:14px;
    background:rgba(0,0,0,.16);
    padding:10px;
    font-size:12px;
    white-space:pre-wrap;
    min-height:120px;
    max-height:200px;
    overflow:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    color:rgba(229,231,235,.9);
  }
  .settingsDialog .settingsField{
    display:grid;
    gap:4px;
    font-size:12px;
  }
  .settingsDialog select,
  .settingsDialog input[type="number"]{
    color-scheme: dark;
    width:100%;
    padding:8px 10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:rgba(13,16,22,.92);
    color:var(--text);
    font-size:12px;
  }
  .settingsDialog select:focus{
    outline:none;
    border-color:rgba(255,210,74,.7);
    box-shadow:0 0 0 2px rgba(255,210,74,.2);
  }
  .settingsDialog select option{
    color-scheme: dark;
    background:#10141b;
    color:var(--text);
  }
  .settingsDialog .settingsHint{
    font-size:11px;
    color:rgba(229,231,235,.65);
  }
  .settingsDialog .rulesCard{
    border:1px solid rgba(148,163,184,.25);
    border-radius:14px;
    background:rgba(9,12,17,.45);
    padding:10px;
  }
  .settingsDialog .rulesGrid{
    display:grid;
    grid-template-columns: repeat(2, minmax(180px, 1fr));
    align-items:start;
    gap:8px 12px;
  }
  .settingsDialog .rulesNote{
    font-size:11px;
    color:rgba(229,231,235,.65);
  }
  .settingsDialog .fieldNote{
    font-size:10px;
    color:rgba(229,231,235,.6);
    min-height:1em;
  }
  .settingsDialog .fieldNote.is-empty{
    visibility:hidden;
  }
  .confirmDialog{
    width:min(520px, calc(100% - 24px));
  }
  .confirmDialog .confirmBody{
    display:grid;
    gap:10px;
    font-size:12px;
    color:rgba(229,231,235,.85);
  }
  .confirmDialog .confirmList{
    margin:0;
    padding-left:18px;
    display:grid;
    gap:4px;
  }
  .confirmDialog .confirmActions{
    display:flex;
    justify-content:flex-end;
    gap:8px;
    margin-top:8px;
  }
  @media (max-width: 640px){
    .settingsDialog .rulesGrid{
      grid-template-columns: 1fr;
    }
  }
  textarea{
    width:100%;height:220px;border-radius:14px;border:1px solid var(--line);
    background:rgba(0,0,0,.16);color:var(--text);
    padding:10px;font-size:12px;outline:none;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  }
  .logBox{height:240px;overflow:auto;border-radius:14px;border:1px solid var(--line);background:rgba(0,0,0,.16);padding:10px}
  .logLine{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;font-size:11px;color:rgba(229,231,235,.80);white-space:pre-wrap;margin:0 0 6px 0}
  
  .waveBox{flex:1;min-height:0}
  .transport{
    display:flex;align-items:center;gap:8px;flex-wrap:wrap;
    padding:10px 10px;
    border:1px solid var(--line);
    border-radius:14px;
    background:rgba(0,0,0,.10);
  }
  .tbtn{
    appearance:none;border:1px solid var(--line);
    background:rgba(255,255,255,.04);
    color:var(--text);
    padding:10px 12px;
    border-radius:14px;
    cursor:pointer;
    font-size:12px;
    line-height:1;
    display:inline-flex;gap:8px;align-items:center;
  }
  .tbtn:hover{background:rgba(255,255,255,.07)}
  .tbtn:disabled{opacity:.45;cursor:not-allowed}
  .tsep{width:1px;height:28px;background:rgba(148,163,184,.22);margin:0 4px}
  .thint{margin-left:auto;color:rgba(229,231,235,.55);font-size:11px;white-space:nowrap}

  

/* CMCD */
.cmcdBox{
  max-width:min(980px, calc(100vw - 40px));
  /* Keep dialog size stable when switching tabs */
  display:flex;
  flex-direction:column;
  height:min(80vh, 760px);
  max-height:min(80vh, 760px);
}

#cmcdDialog .tabPanels{
  flex: 1;
  min-height: 0;
  overflow: hidden; /* prevent outer scrolling; inner grids scroll */
  padding-right: 0;
}
#cmcdDialog .tabPanel{
  min-height: 0;
  height: 100%;
  overflow: hidden;
  padding-right: 0;
}

#cmcdDialog .tabPanel.active{
  display: flex;
  flex-direction: column;
}
#cmcdDialog .cmcdActions{ flex: 0 0 auto; }
#cmcdDialog .cmcdPmContent{ flex: 1 1 auto; min-height: 0; }
#cmcdDialog .cmcdGrid{
  flex: 1 1 auto;
  min-height: 0;
  max-height: none; /* override global 60vh to fit dialog */
  overflow: auto;
}
.cmcdGrid{
  margin-top:12px;
  display:grid;
  grid-template-columns:repeat(2, minmax(0, 1fr));
  gap:10px 14px;
  padding:12px;
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(0,0,0,.10);
  max-height:60vh;
  overflow:auto;
}
.cmcdRow{display:grid; grid-template-columns:160px 1fr; gap:10px; align-items:center;}
.cmcdKey{color:rgba(229,231,235,.75); font-size:12px; white-space:nowrap;}
.cmcdVal{
  width:100%;
  padding:9px 12px;
  border-radius:12px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.04);
  color:var(--text);
  font-size:12px;
}
.cmcdVal:focus{outline:none; border-color:rgba(94,234,212,.55);}
.cmcdActions{display:flex; gap:10px; justify-content:flex-end; margin-top:12px;}
@media (max-width: 760px){
  .cmcdGrid{grid-template-columns:1fr;}
  .cmcdRow{grid-template-columns:1fr; gap:6px;}
}

  /* PDF attach */
  .pdfZone{border:1px dashed rgba(255,255,255,.25); border-radius:14px; padding:14px; margin:10px 0; background:rgba(255,255,255,.04);}
  .pdfZone.drag{outline:2px solid rgba(139,255,191,.65); background:rgba(139,255,191,.08);}
  .pdfZoneTitle{font-weight:700; margin-bottom:6px;}
  .pdfZoneSub{margin:8px 0;}
  .pdfZoneHint{font-size:12px;}

  .attachDescSmall{font-size:12px; opacity:.85; display:block; line-height:1.55; margin:0 0 12px 0;}
  .attachListWrap{margin:10px 0 6px;}
  .attachListHead{display:flex;align-items:center;justify-content:space-between;margin:0 0 6px 0;}
  .attachCount{font-size:12px; opacity:.75;}
  .attachList{border:1px solid rgba(255,255,255,.16); border-radius:14px; background:rgba(255,255,255,.03); max-height:220px; overflow:auto; padding:6px;}
  .attachItem{display:flex; gap:10px; align-items:flex-start; padding:8px 10px; border-radius:12px; cursor:pointer; user-select:none;}
  .attachItem:hover{background:rgba(255,255,255,.05);}
  .attachItem.selected{outline:2px solid rgba(139,255,191,.55); background:rgba(139,255,191,.06);}
  .attachItem.dragging{opacity:.6;}
  .attachItem.dragOver{outline:2px dashed rgba(139,255,191,.55);}
  .dragHandle{width:18px; flex:0 0 18px; line-height:1; font-size:18px; opacity:.85; cursor:grab; margin-top:1px;}

  .attachSlotBadge{
    flex:0 0 auto;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    min-width:34px;
    height:22px;
    padding:0 8px;
    border-radius:999px;
    font-size:12px;
    font-weight:800;
    letter-spacing:.2px;
    background:rgba(56,189,248,.16);
    border:1px solid rgba(56,189,248,.35);
    color:rgba(226,232,240,.95);
    margin-top:1px;
  }
  .attachOrderHint{
    margin-top:8px;
    font-size:12px;
    opacity:.82;
    line-height:1.45;
  }

  .attachMain{flex:1; min-width:0;}
  .attachNameLine{font-weight:700; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .attachMetaLine{font-size:12px; opacity:.75; margin-top:2px;}

  .pdfActions{display:flex; gap:8px; flex-wrap:wrap; margin:10px 0;}
  .pdfGrid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:10px; margin-top:8px;}
  .pdfRow{display:flex; flex-direction:column; gap:6px;}
  .pdfKey{font-size:12px; color:rgba(255,255,255,.75);}
  .pdfVal{width:100%;}
  .pdfViewerWrap{height:min(70vh, 720px); border:1px solid rgba(255,255,255,.12); border-radius:14px; overflow:hidden; background:rgba(0,0,0,.25);}
  .pdfViewerFrame{width:100%; height:100%; border:0; background:white;}
  .fileTextPreview{width:100%;height:100%;border:0;display:none;resize:none;padding:14px;background:rgba(0,0,0,.35);color:rgba(255,255,255,.92);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;line-height:1.5;white-space:pre;overflow:auto;}

  /* PDF viewer header spacing (avoid title overlap) */
  #pdfViewDialog .dlgHead{
    padding:10px 14px;
    border-bottom:1px solid rgba(255,255,255,.10);
  }
  #pdfViewDialog .dlgTitle{
    font-size:12px;
    font-weight:700;
    line-height:1.2;
    letter-spacing:.02em;
    color:rgba(255,255,255,.92);
    margin:0;
  }
  #pdfViewDialog .pdfViewerWrap{
    margin:12px 14px 14px;
    /* keep existing height; margin handles spacing */
  }
/* ===== Pair link switch ===== */
.switchWrap{
  display:flex;
  align-items:center;
  gap:10px;
  margin-top:10px;
  padding:10px 12px;
  border-radius:14px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.08);
}
.switch{
  position:relative;
  display:inline-block;
  width:46px;
  height:26px;
  flex: 0 0 auto;
}
.switch input{ display:none; }
.slider{
  position:absolute;
  inset:0;
  cursor:pointer;
  background:#6b7280;
  transition: .18s ease;
  border-radius:999px;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
}
.slider:before{
  content:"";
  position:absolute;
  height:20px;
  width:20px;
  left:3px;
  top:3px;
  background:#ffffff;
  transition: .18s ease;
  border-radius:999px;
  box-shadow: 0 6px 14px rgba(0,0,0,0.35);
}
.switch input:checked + .slider{
  background:#2fbf71; /* green on */
}
.switch input:checked + .slider:before{
  transform: translateX(20px);
}
.switchText{ display:flex; flex-direction:column; gap:2px; }
.switchLabel{
  font-size:12px;
  color: rgba(255,255,255,0.88);
  letter-spacing: .02em;
}
.pairLinkHint{
  font-size:11px;
  color: rgba(255,255,255,0.55);
}

/* ===== Cue time editor ===== */
.timeCell{ width: 110px; }
.timeInput{
  width: 96px;
  padding: 6px 8px;
  border-radius: 12px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  color: rgba(255,255,255,0.92);
  font: inherit;
  font-size: 12px;
  outline: none;
}
.timeInput:focus{
  border-color: rgba(47,191,113,0.65);
  box-shadow: 0 0 0 3px rgba(47,191,113,0.18);
}

/* ===== Pair link (mini, beside add button) ===== */
.pairRow{
  display:flex;
  align-items:center;
  gap:10px;
}
.linkMini{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border-radius:999px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  user-select:none;
}
.linkMiniLabel{
  font-size:11px;
  color: rgba(255,255,255,0.70);
  letter-spacing: .02em;
}



  /* ===== ChunkDialog: fixed tab bar + fixed display box (no resizing/jumping) ===== */
  dialog#chunkDialog{
    width: min(1200px, 96vw);
    max-height: 86vh;
  }
  dialog#chunkDialog .chunkModalBody{
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;            /* prevent dialog/body scroll */
    max-height: calc(86vh - 72px); /* header budget (safe) */
    height: calc(86vh - 72px);
  }

  /* Tab bar must never move */
  dialog#chunkDialog .chunkTabs{
    flex:1 1 auto;
    min-height:0;
    display:flex;
    flex-direction:column;
    overflow:hidden;
    align-items:stretch;
  }
  dialog#chunkDialog .tabBar{
    width:100%;
    flex:0 0 auto;
    justify-content:flex-start;
    box-sizing:border-box;
  }

  /* One fixed "display box" that always stays same size */
  dialog#chunkDialog .tabPanels{
    flex:1 1 auto;
    min-height:0;
    position:relative;
    overflow:hidden;
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    background:rgba(0,0,0,.08);
    padding:12px;
    box-sizing:border-box;
  }

  /* All tabs occupy the same box; only active is shown; scroll inside */
  dialog#chunkDialog .tabPanel{
    position:absolute;
    inset:12px;                 /* match padding so content aligns */
    overflow-y: scroll;         /* always reserve scrollbar width */
    overflow-x:hidden;
    overscroll-behavior: contain;
    scrollbar-gutter: stable both-edges;
    display:none;
    padding-right:6px;          /* tiny breathing room for scrollbar */
    box-sizing:border-box;
  }
  dialog#chunkDialog .tabPanel.active{ display:block; }

  /* Use full width inside panels */
  dialog#chunkDialog .kvGrid,
  dialog#chunkDialog .fieldBlock,
  dialog#chunkDialog textarea,
  dialog#chunkDialog details.advBox,
  dialog#chunkDialog .logBox{
    width:100%;
    box-sizing:border-box;
  }
  dialog#chunkDialog textarea{ width:100%; box-sizing:border-box; max-width:100%; }

  /* Reduce right-bias by pulling values left */
  dialog#chunkDialog .kvGrid{
    grid-template-columns: 150px minmax(0,1fr);
  }
  dialog#chunkDialog .kvV{ min-width:0; overflow-wrap:anywhere; }

  /* cmcd: multi-column (key/value | key/value) + thin divider */
  dialog#chunkDialog #cmcdViewGrid{
    position:relative;
    grid-template-columns: 150px minmax(0,1fr) 150px minmax(0,1fr);
  }
  dialog#chunkDialog #cmcdViewGrid::before{
    content:"";
    position:absolute;
    top:10px;
    bottom:10px;
    left:50%;
    width:1px;
    background: rgba(255,255,255,.10);
    pointer-events:none;
  }
  /* ===== /ChunkDialog ===== */



  /* ===== Release polish: remove dev-facing headings ===== */
  dialog#chunkDialog .modalHead{
    padding: 6px 10px;
  }
  dialog#chunkDialog .modalHead .title{
    display:none !important; /* hide (now empty) header title area */
  }
  /* ===== /Release polish ===== */



  /* ===== Release UI: remove redundant close buttons in sub-dialogs ===== */
  #cmcdDialog .dlgHead button,
  #pdfAttachDialog .dlgHead button,
  #pdfViewDialog .dlgHead button{
    display:none !important;
  }
  /* ===== /Release UI ===== */



  /* ===== Release UI: hide waveform HUD info (dur/scroll) ===== */
  #hudInfo, .waveHud{ display:none !important; }
  /* ===== /Release UI ===== */



  /* ===== Theme: ProTools-like (visual only; functionality unchanged) ===== */
  :root{
    --pt-bg: #14151a;
    --pt-panel: #1d1f26;
    --pt-panel2:#232631;
    --pt-panel3:#2a2e3b;
    --pt-border:#3b4152;
    --pt-border2:#2f3443;
    --pt-text:#e6e8ee;
    --pt-muted:#a9afc0;
    --pt-accent:#ffd24a;      /* PT-ish yellow */
    --pt-accent2:#67a7ff;     /* selection blue */
    --pt-good:#35d07f;
    --pt-bad:#ff5b6e;
    --pt-shadow: rgba(0,0,0,.45);
  }

  html, body{
    background: radial-gradient(1200px 900px at 20% 0%, #1a1c24 0%, var(--pt-bg) 55%, #0f1014 100%);
    color: var(--pt-text);
  }

  /* General typography */
  body{
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
    letter-spacing: .2px;
  }

  /* App chrome */
  .app, .wrap, .container, .page{
    color: var(--pt-text);
  }

  /* Panels / cards */
  .card, .panel, .box, .section, .zone{
    background: linear-gradient(180deg, var(--pt-panel2), var(--pt-panel));
    border: 1px solid var(--pt-border2);
    box-shadow: 0 10px 24px var(--pt-shadow);
    border-radius: 14px;
  }

  /* Buttons: beveled PT-like */
  .btn, button.btn, .pillBtn, .chipBtn{
    background: linear-gradient(180deg, #2b3040 0%, #1f2330 100%);
    border: 1px solid var(--pt-border);
    color: var(--pt-text);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 14px rgba(0,0,0,.35);
    border-radius: 10px;
    transition: transform .06s ease, filter .12s ease;
  }
  .btn:hover, button.btn:hover{
    filter: brightness(1.06);
  }
  .btn:active, button.btn:active{
    transform: translateY(1px);
    filter: brightness(.98);
  }
  .btn.primary, .btnPrimary{
    background: linear-gradient(180deg, #3a3f52 0%, #262b3b 100%);
    border-color: #4a5066;
  }
  .btnDanger{
    border-color: rgba(255,91,110,.55);
  }

  /* Inputs */
  input[type="text"], input[type="number"], textarea, select{
    background: linear-gradient(180deg, #191b23, #14161c);
    border: 1px solid var(--pt-border2);
    color: var(--pt-text);
    border-radius: 10px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
  }
  input::placeholder, textarea::placeholder{
    color: rgba(169,175,192,.65);
  }
  label{
    color: var(--pt-muted);
  }

  /* Tabs: ProTools-ish segmented */
  dialog#chunkDialog .tabBar{
    gap: 6px;
    padding: 6px;
    border-radius: 12px;
    background: linear-gradient(180deg, #1a1d27, #14161c);
    border: 1px solid var(--pt-border2);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
  }
  dialog#chunkDialog .tabBtn{
    border-radius: 10px;
    padding: 8px 12px;
    background: linear-gradient(180deg, #2b3040, #1e2230);
    border: 1px solid var(--pt-border);
    color: var(--pt-muted);
  }
  dialog#chunkDialog .tabBtn.active{
    color: #121318;
    background: linear-gradient(180deg, var(--pt-accent), #f0b800);
    border-color: rgba(255,210,74,.75);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.22), 0 8px 16px rgba(0,0,0,.35);
  }
  dialog#chunkDialog .tabPanels{
    background: linear-gradient(180deg, #171a22, #121318);
    border: 1px solid var(--pt-border2);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
    border-radius: 14px;
  }

  /* Dialogs */
  dialog{
    border: 1px solid var(--pt-border);
    background: linear-gradient(180deg, #1c1f29, #14161c);
    box-shadow: 0 18px 50px rgba(0,0,0,.6);
    border-radius: 16px;
    color: var(--pt-text);
  }
  dialog::backdrop{
    background: rgba(0,0,0,.55);
    backdrop-filter: blur(2px);
  }

  /* KV grid */
  .kvGrid{
    border-radius: 12px;
  }
  .kvK{
    color: rgba(230,232,238,.72);
    background: transparent;
  }
  .kvV{
    color: var(--pt-text);
  }

  /* Waveform area: darker track-lane look */
  #waveWrap, .waveWrap, .waveBox, .waveCanvasWrap{
    background: linear-gradient(180deg, #0f1117, #0b0c10);
    border: 1px solid #2b3040;
    border-radius: 14px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
  }
  /* If there is a canvas element, give it a subtle lane tint */
  canvas{
    image-rendering: auto;
  }

  /* Cue labels / pills */
  .pill, .tag, .badge{
    background: linear-gradient(180deg, #2b3040, #1c2030);
    border: 1px solid var(--pt-border);
    color: var(--pt-text);
    border-radius: 999px;
  }
  .pill.good{ border-color: rgba(53,208,127,.55); }
  .pill.bad{ border-color: rgba(255,91,110,.55); }
  .badge{
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 999px;
    margin-left: 10px;
    line-height: 1.6;
  }
  .badge.ok{
    color: #bff5d2;
    border: 1px solid rgba(120,255,170,0.35);
    background: rgba(80,180,120,0.12);
  }
  .badge.ng{
    color: #ffd0d0;
    border: 1px solid rgba(255,120,120,0.40);
    background: rgba(255,90,90,0.10);
  }

  /* Subtle separators */
  hr, .sep, .divider{
    border-color: rgba(59,65,82,.55);
  }

  /* Muted text */
  .muted, .subtle, .hint{
    color: rgba(169,175,192,.78) !important;
  }

  /* Scrollbar (WebKit) */
  *::-webkit-scrollbar{ height: 10px; width: 10px; }
  *::-webkit-scrollbar-track{ background: #101218; }
  *::-webkit-scrollbar-thumb{
    background: linear-gradient(180deg, #2b3040, #1c2030);
    border: 1px solid #363c4e;
    border-radius: 10px;
  }
  *::-webkit-scrollbar-thumb:hover{ filter: brightness(1.08); }
  /* ===== /Theme: ProTools-like ===== */



  /* ===== ProTools+ (enhanced) UX layer: modern polish, no functional changes ===== */

  :root{
    --pt-gap: 10px;
    --pt-gap2: 14px;
    --pt-radius: 14px;
    --pt-radius2: 18px;
    --pt-focus: rgba(103,167,255,.55);
    --pt-glow: 0 0 0 4px rgba(103,167,255,.18);
    --pt-glow2: 0 0 0 4px rgba(255,210,74,.18);
  }

  /* Crisp, modern spacing */
  .row, .grid, .stack { gap: var(--pt-gap); }
  .card, .panel, .box, .section, .zone{
    border-radius: var(--pt-radius2);
  }

  /* Subtle animated sheen */
  @media (prefers-reduced-motion: no-preference){
    .card, .panel, .box, .section, .zone{
      position: relative;
      overflow: hidden;
    }
    .card::after, .panel::after, .box::after, .section::after, .zone::after{
      content:"";
      position:absolute;
      inset:-60%;
      background: radial-gradient(closest-side, rgba(255,255,255,.06), transparent 70%);
      transform: translate3d(-12%, -12%, 0);
      pointer-events:none;
      opacity:.55;
    }
  }

  /* Accessibility: strong focus */
  :focus-visible{
    outline: none !important;
    box-shadow: var(--pt-glow) !important;
    border-color: rgba(103,167,255,.65) !important;
  }
  .btn:focus-visible, button.btn:focus-visible{
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 14px rgba(0,0,0,.35), var(--pt-glow2) !important;
    border-color: rgba(255,210,74,.75) !important;
  }

  /* Modern button feel */
  .btn, button.btn{
    will-change: transform;
  }
  @media (prefers-reduced-motion: no-preference){
    .btn, button.btn{
      transition: transform .08s ease, filter .15s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .btn:hover, button.btn:hover{
      transform: translateY(-1px);
    }
    .btn:active, button.btn:active{
      transform: translateY(0px);
    }
  }

  /* Tool-like top bars and sticky action clusters (non-invasive) */
  .toolbar, .headerBar{
    backdrop-filter: blur(8px);
  }

  /* Dialog open animation */
  @media (prefers-reduced-motion: no-preference){
    dialog[open]{
      animation: ptDialogIn .16s ease-out;
      transform-origin: 50% 20%;
    }
    @keyframes ptDialogIn{
      from{ opacity: 0; transform: translateY(10px) scale(.985); }
      to{ opacity: 1; transform: translateY(0) scale(1); }
    }
  }

  /* Tabs: add an active indicator strip without changing markup */
  dialog#chunkDialog .tabBar{
    position: relative;
  }
  dialog#chunkDialog .tabBar::after{
    content:"";
    position:absolute;
    left:10px; right:10px; bottom:6px;
    height:1px;
    background: rgba(255,255,255,.06);
    pointer-events:none;
  }

  /* Tab button micro styling */
  dialog#chunkDialog .tabBtn{
    position: relative;
    overflow: hidden;
  }
  @media (prefers-reduced-motion: no-preference){
    dialog#chunkDialog .tabBtn::before{
      content:"";
      position:absolute;
      inset:-30%;
      background: radial-gradient(closest-side, rgba(255,255,255,.10), transparent 70%);
      opacity:0;
      transform: translate3d(-10%, -10%, 0);
      transition: opacity .18s ease;
      pointer-events:none;
    }
    dialog#chunkDialog .tabBtn:hover::before{ opacity:.65; }
  }

  /* Fixed “content box” (if present) readability */
  dialog#chunkDialog .tabPanels{
    position: relative;
  }

  /* Scroll shadows (used by JS below) */
  .scrollShadowTop::before,
  .scrollShadowBottom::after{
    content:"";
    position: sticky;
    left: 0;
    right: 0;
    height: 18px;
    display:block;
    pointer-events:none;
    z-index: 5;
  }
  .scrollShadowTop::before{
    top: 0;
    background: linear-gradient(180deg, rgba(0,0,0,.38), transparent);
  }
  .scrollShadowBottom::after{
    bottom: 0;
    background: linear-gradient(0deg, rgba(0,0,0,.38), transparent);
  }

  /* Waveform area: add subtle lane stripes to increase readability */
  #waveWrap, .waveWrap, .waveBox, .waveCanvasWrap{
    background:
      linear-gradient(180deg, rgba(255,255,255,.03), transparent 35%),
      repeating-linear-gradient(
        180deg,
        rgba(255,255,255,.02) 0px,
        rgba(255,255,255,.02) 26px,
        rgba(255,255,255,0) 26px,
        rgba(255,255,255,0) 52px
      ),
      linear-gradient(180deg, #0f1117, #0b0c10);
  }

  /* Better empty states (no layout changes) */
  .empty, .placeholder{
    color: rgba(230,232,238,.62);
  }

  /* Respect reduced motion */
  @media (prefers-reduced-motion: reduce){
    *{ transition: none !important; animation: none !important; }
  }

  /* ===== /ProTools+ (enhanced) ===== */



  /* ===== ProTools+ v2: product polish (visual only) ===== */

  .btnRow{
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
  }
  .pill.fileName{
    max-width: 36vw;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  @media (max-width: 980px){
    .pill.fileName{ max-width: 60vw; }
  }

  /* Status pill emphasis */
  #statusPill{
    border-color: rgba(255,210,74,.28);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
  }

  /* Toasts */
  .toastHost{
    position: fixed;
    left: 50%;
    top: 80px;
    transform: translateX(-50%);
    z-index: 2147483647;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
    gap: 10px;
    pointer-events: none; /* clicks pass through */
  }
  #toastRoot.toastHost,
  #toastLayerHost.toastHost{
    position: fixed;
    z-index: 2147483647;
    pointer-events: none;
  }
  .toast{
    pointer-events: auto;
    min-width: 280px;
    max-width: min(560px, calc(100vw - 32px));
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid rgba(59,65,82,.55);
    background: linear-gradient(180deg, rgba(43,48,64,.92), rgba(28,32,48,.92));
    box-shadow: 0 14px 34px rgba(0,0,0,.45);
    color: rgba(230,232,238,.96);
    display: grid;
    grid-template-columns: 18px 1fr;
    gap: 10px;
    align-items: start;
    backdrop-filter: blur(10px);
  }
  .toast .ic{
    width: 18px;
    height: 18px;
    border-radius: 6px;
    background: rgba(255,255,255,.08);
    border: 1px solid rgba(255,255,255,.10);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    line-height: 1;
    margin-top: 1px;
  }
  .toast .msg{
    font-size: 13px;
    line-height: 1.35;
    letter-spacing: .2px;
  }
  .toast.ok{ border-color: rgba(53,208,127,.45); }
  .toast.warn{ border-color: rgba(255,210,74,.45); }
  .toast.err{ border-color: rgba(255,91,110,.45); }

  /* Toast top-layer (always above any dialog) */
  dialog.toastLayer{
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    border: none;
    background: transparent;
    padding: 0;
    margin: 0;
    box-shadow: none;
    pointer-events: none;
  }
  dialog.toastLayer::backdrop{
    background: transparent;
    backdrop-filter: none;
  }

  /* Override position for the top-layer toast host */
  #toastRoot.toastHost,
  #toastLayerHost.toastHost{
    top: 16px;         /* 画面中央上部 */
    left: 50%;
    transform: translateX(-50%);
  }
  /* Stabilize toast position (prevent post-render drift) */
  #toastLayerHost.toastHost,
  #toastRoot.toastHost{
    right: auto !important;         /* cancel legacy right-based positioning */
    bottom: auto !important;
    margin: 0 !important;
    transform: translate3d(-50%, 0, 0) !important;
    transition: none !important;    /* no host movement */
    will-change: transform;
    contain: layout paint;          /* isolate layout to avoid subtle reflow drift */
  }

  @media (prefers-reduced-motion: no-preference){
    .toast{
      animation: toastIn .14s ease-out;
      transform-origin: 50% 50%;
    }
    @keyframes toastIn{
      from{ opacity: 0; transform: translateY(-6px) scale(.985); }
      to{ opacity: 1; transform: translateY(0) scale(1); }
    }
    .toast.out{
      animation: toastOut .16s ease-in forwards;
    }
    @keyframes toastOut{
      to{ opacity: 0; transform: translateY(-6px) scale(.985); }
    }
  }
  dialog.toastLayer{ display:none !important; }
  #toastRoot.toastHost{
    position: fixed !important;
    top: 16px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    z-index: 2147483647 !important;
    pointer-events: none !important;  /* host自体は操作を透過 */
  }
  #toastRoot.toastHost .toast{
    pointer-events: auto; /* トースト要素が閉じるボタン等を持つ場合だけ受ける */
  }
  /* ===== /ProTools+ v2 ===== */



  /* ===== ProTools+ v4: brand polish ===== */
  .brandTitle{
    font-size: 20px;
    font-weight: 800;
    letter-spacing: .6px;
    display: inline-flex;
    align-items: baseline;
    position: relative;
    text-shadow: 0 10px 26px rgba(0,0,0,.45);
  }
  .brandTitle .brandDash{ opacity: .9; }
  .brandTitle .brandEm{ letter-spacing: .9px; }
  .brandTitle::after{
    content:"";
    position:absolute;
    left: 0;
    right: 0;
    bottom: -6px;
    height: 2px;
    background: linear-gradient(90deg,
      rgba(255,210,74,0),
      rgba(255,210,74,.85),
      rgba(103,167,255,.75),
      rgba(255,210,74,0)
    );
    opacity: .9;
  }
  /* ===== /brand polish ===== */



  /* ===== ProTools+ v5: brand (stylish, minimal) ===== */
  .brandTitle{
    font-size: 19px !important;
    font-weight: 700 !important;
    letter-spacing: .35px !important;
    text-shadow: none !important;
  }
  .brandTitle .brandDash{ opacity: .8 !important; }
  .brandTitle .brandEm{ letter-spacing: .35px !important; }

  /* Replace underline with subtle accent shine */
  .brandTitle::after{
    content:none !important;
  }

  /* Optional: subtle gradient text when supported */
  @supports (-webkit-background-clip: text){
    .brandTitle{
      background: linear-gradient(90deg, rgba(230,232,238,.96), rgba(255,210,74,.92), rgba(103,167,255,.86));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent !important;
    }
  }

  /* Hide subtitle row entirely (keeps DOM stable) */
  .brand .small{
    display:none !important;
  }
  /* ===== /ProTools+ v5 brand ===== */



  /* ===== ProTools+ v6: ensure BWF-J hyphen is always visible ===== */
  .brandTitle .brandDash{
    display: inline-block !important;
    margin: 0 .5px !important;
    opacity: 1 !important;
  }

  /* When using gradient text (color: transparent), force dash to render with solid color */
  @supports (-webkit-background-clip: text){
    .brandTitle .brandDash{
      background: none !important;
      -webkit-background-clip: initial !important;
      background-clip: initial !important;
      color: rgba(230,232,238,.92) !important;
      -webkit-text-fill-color: rgba(230,232,238,.92) !important;
    }
  }
  /* ===== /ProTools+ v6 ===== */



  /* ===== UI tweak: consistent transport icon sizing ===== */
  .tbtn .ticon{
    display:inline-block;
    width:1.25em;
    text-align:center;
    font-size:1.08em;
    line-height:1;
    transform: translateY(1px);
  }
  /* Slight bump for ■ which looks optically smaller than ▶︎ */
  .tbtn .ticonStop{
    font-size:1.14em;
    transform: translateY(1px);
  }
  /* ===== /UI tweak ===== */



  /* ===== UI tweak v2: stop icon as drawn block (optically matches play) ===== */
  .tbtn .ticonStop{
    font-size: 1em !important;
    transform: translateY(1px) !important;
  }
  .tbtn .ticonStop::before{
    content:"";
    display:inline-block;
    width: 0.95em;
    height: 0.95em;
    background: currentColor;
    border-radius: 0.12em; /* slightly softened like UI glyphs */
    transform: translateY(0.02em);
  }
  /* ===== /UI tweak v2 ===== */


/* ===== Export Check modal (v4 columns) ===== */
.exportCheckDialog{
  width: min(860px, 92vw);
  max-width: 860px;
}
.exportCheckDialog::backdrop{
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(2px);
}

/* ===== Bulk Export NG preflight dialog ===== */
dialog.bulkNgDialog{
  width: min(560px, 92vw);
  max-width: 560px;
}
.bulkNgDialog .bulkNgDesc{
  font-size: 13px;
  opacity: .9;
  line-height: 1.5;
}
.bulkNgDialog .bulkNgList{
  margin-top: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: min(46vh, 360px);
  overflow: auto;
  padding-right: 4px;
}
.bulkNgDialog .bulkNgItem{
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 10px 12px;
  background: rgba(255,255,255,0.03);
}
.bulkNgDialog .bulkNgName{
  font-weight: 700;
  font-size: 14px;
}
.bulkNgDialog .bulkNgReasons{
  margin: 6px 0 0 0;
  padding-left: 1.1em;
  font-size: 12px;
  line-height: 1.5;
}
.bulkNgDialog .bulkNgActions{
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 12px;
}
/* ===== /Bulk Export NG preflight dialog ===== */

/* ===== StdCheck dialog stability tweaks (tabbed preset) ===== */
.stdCheckDialog{
  width: min(900px, 92vw);
  max-width: 900px;
  height: min(86vh, 840px);
  max-height: 86vh;
  overflow: hidden; /* prevent outer dialog scroll */
}
.stdCheckDialog[open]{
  display: flex;
  flex-direction: column;
}
.stdCheckDialog .modalHead{ flex: 0 0 auto; }
.stdCheckDialog .modalBody{
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  flex-direction: column;
  gap: 10px;
  overflow: hidden; /* keep scroll inside panes */
}
/* panes share same viewport height -> no size jump */
#sc_resultsPane,
#sc_presetMgr{
  flex: 1 1 auto;
  min-height: 0;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none; /* Firefox */
}
#sc_resultsPane::-webkit-scrollbar,
#sc_presetMgr::-webkit-scrollbar{
  width: 0;
  height: 0;
}
/* sort list */
.scSortList{
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.scSortItem{
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  border: 1px solid var(--line);
  border-radius: 12px;
  background: rgba(255,255,255,.03);
  cursor: grab;
  user-select: none;
}
.scSortItem:active{ cursor: grabbing; }
.scSortHandle{
  width: 18px;
  text-align: center;
  opacity: .85;
  font-size: 14px;
}
.scSortItem.dragging{
  opacity: .55;
}
.scSortItem.dragOver{
  outline: 2px solid rgba(118, 180, 255, .55);
  outline-offset: 2px;
}
.ecModalHead{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
}
.ecTitle{
  display:flex;
  flex-direction:column;
  gap:2px;
}

/* two-column key/value grid (no horizontal slide) */
.modalBody{ overflow-x:hidden; }
.ecTable{
  display:grid;
  grid-template-columns: 220px 220px 1fr;
  gap:10px 12px;
  margin-top: 10px;
  min-width: 0;
}
.ecColHead{
  font-size:11px;
  letter-spacing:.05em;
  text-transform: uppercase;
  color: rgba(235,238,248,.70);
  padding: 0 2px 4px;
}
.ecKey{
  font-size:12px;
  letter-spacing:.02em;
  color: rgba(235,238,248,.92);
  padding:10px 12px;
  border:1px solid var(--line);
  border-radius:14px;
  background: rgba(255,255,255,.03);
  font-weight: 700;
}
.ecVal{
  font-size:13px;
  padding:10px 12px;
  border:1px solid var(--line);
  border-radius:14px;
  background: rgba(0,0,0,.14);
  font-variant-numeric: tabular-nums;
  min-width: 0;
  overflow-wrap: anywhere;
  word-break: break-word;
}
.ecVal[title]:not([title=""]){ cursor: help; }

.ecTarget{
  font-size:12px;
  padding:10px 12px;
  border:1px solid var(--line);
  border-radius:14px;
  background: rgba(255,255,255,.05);
  color: rgba(235,238,248,.85);
  font-variant-numeric: tabular-nums;
  min-width: 0;
  overflow-wrap: anywhere;
  word-break: break-word;
}


/* cue list */
.ecCueList{
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px;
  background:rgba(255,255,255,.03);
  max-height:220px;
  overflow:auto;
}
.ecCueRow{ display:flex; gap:10px; padding:6px 2px; border-bottom:1px dashed rgba(255,255,255,.10); }
.ecCueRow:last-child{ border-bottom:none; }
.ecCueT{ min-width:92px; font-variant-numeric: tabular-nums; opacity:.95; }
.ecCueL{ flex:1; word-break: break-word; }

/* small screens: stack */
@media (max-width: 720px){
  .ecTable{ grid-template-columns: 1fr; }
  .ecColHead{ display:none; }
  .ecCueRow{ flex-direction:column; gap:2px; }
  .ecCueT{ min-width:auto; }
}

#ec_table{ grid-template-columns: 260px 1fr; }
/* ===== /Export Check modal ===== */
/* ===== Standard Check modal (separate from export) ===== */
.stdCheckDialog .scTopRow{
  display:flex; gap:8px; align-items:center; flex-wrap:wrap;
}
.btnSel{
  appearance:none;
  padding:8px 12px;
  border-radius:999px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.08);
  color:var(--fg);
  font-size:13px;
  line-height:1.2;
  color-scheme: dark;
}
.btnSel option{ background: var(--panel2); color: var(--text); }
.btnSel:hover{ background:rgba(255,255,255,.10); }
.btnSel:focus{ outline:none; box-shadow:0 0 0 3px rgba(255,255,255,.12); }


/* --- BC$ cue dropdown: match other selects --- */
#selBcLabel.btnSel{
  background-color: rgba(15,17,21,.92) !important;
  color: #e9eef7 !important;
  border-color: rgba(255,255,255,.18) !important;
}
#selBcLabel.btnSel option{
  background-color: #0f1115 !important;
  color: #e9eef7 !important;
}
/* ------------------------------------------------ */
.scPmPickSel{
  appearance:none;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size:13px;
  line-height:1.2;
  min-height:36px;
  color-scheme: dark;
}

.scPmPickSel.isNew{ color: var(--muted); }
.scPmPickSel:hover{ filter:brightness(1.05); }
.scPmPickSel:focus{ outline:none; box-shadow:0 0 0 3px rgba(255,255,255,.12); }
.scPmPickSel.isPlaceholder{ color: var(--muted); }
.scPmPickSel option{ background: var(--panel2); color: var(--text); }
.btnSel option{
  background:#0f1115;
  color:#e9eef7;
}

/* --- StdCheck select visibility (force high contrast) --- */
.stdCheckDialog .btnSel,
.stdCheckDialog select.btnSel{
  background-color: rgba(15,17,21,.92) !important;
  color: #e9eef7 !important;
  border-color: rgba(255,255,255,.18) !important;
}
.stdCheckDialog select.btnSel option{
  background-color: #0f1115 !important;
  color: #e9eef7 !important;
}
/* ------------------------------------------------------- */

.btnSel:disabled{ opacity:.55; }
.scPresetDesc{
  margin-top:6px;
  color:var(--muted);
  font-size:12px;
  line-height:1.4;
}
.scFixBox{
  margin-top:14px;
  padding:12px;
  border:1px solid var(--line);
  border-radius:12px;
  background:rgba(255,255,255,.03);
}
.scFixBox .muted{ font-size:12px; }
.scPill{
  display:inline-block;
  font-size:11px;
  border:1px solid var(--line);
  border-radius:999px;
  padding:4px 10px;
  background:rgba(255,255,255,.03);
  white-space:nowrap;
}
.scPill.ok{ border-color: rgba(53,208,127,.45); color: rgba(150,255,200,.95); }
.scPill.warn{ border-color: rgba(246,198,71,.55); color: rgba(255,220,140,.95); }
.scPill.ng{ border-color: rgba(255,96,96,.55); color: rgba(255,160,160,.95); }
/* ===== /Standard Check modal ===== */


/* ---- StdCheck preset manager locking ---- */
#sc_presetMgr.isLocked .scPresetGrid{opacity:1;}
#sc_presetMgr.isLocked .scPresetMgrBtns{opacity:1;}
#sc_presetMgr input:disabled, #sc_presetMgr select:disabled{
  opacity:.6;
  filter:grayscale(.2);
  cursor:not-allowed;
}
#sc_presetMgr .btn:disabled{
  opacity:.55;
  cursor:not-allowed;
}



  /* Accent tune to match the WavCue underline (warm yellow) */
  .btn.primary{
    background: linear-gradient(180deg, rgba(255,210,74,.20), rgba(255,210,74,.10));
    border-color: rgba(255,210,74,.35);
    color: var(--text);
    box-shadow: 0 10px 26px rgba(0,0,0,.28);
  }
  .btn.primary:hover{
    background: linear-gradient(180deg, rgba(255,210,74,.26), rgba(255,210,74,.14));
    border-color: rgba(255,210,74,.48);
  }
  .btn.primary:active{
    background: linear-gradient(180deg, rgba(255,210,74,.18), rgba(255,210,74,.08));
  }
  .btn:focus-visible{
    outline: none;
    box-shadow: 0 0 0 3px rgba(255,210,74,.18), 0 14px 38px rgba(0,0,0,.35);
  }


/* ===== DIFF SUMMARY UI ===== */
.chk{
  display:flex;
  align-items:center;
  gap:8px;
  font-size:12px;
  padding:6px 10px;
  border:1px solid var(--line);
  border-radius:999px;
  background:rgba(255,255,255,0.02);
  user-select:none;
}
.chk input{ transform: translateY(0.5px); }

.diffBox, .ecDiffBox{
  margin-top:10px;
  padding:10px 12px;
  border:1px solid #2a2f37;
  border-radius:14px;
  background:rgba(255,255,255,0.02);
  max-height:260px;
  overflow:auto;
}
.diffTable{
  width:100%;
  border-collapse:collapse;
  font-size:12px;
}
.diffTable th, .diffTable td{
  padding:8px 8px;
  border-bottom:1px solid rgba(255,255,255,0.06);
  vertical-align:top;
}
.diffTable th{
  color:rgba(255,255,255,0.65);
  font-weight:700;
  position:sticky;
  top:0;
  background:rgba(15,18,23,0.9);
  backdrop-filter: blur(8px);
}
.diffBadge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:2px 8px;
  border-radius:999px;
  font-size:11px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(255,255,255,0.04);
  white-space:nowrap;
}
.diffBadge.ok{ opacity:.75; }
.diffBadge.chg{ border-color: rgba(94, 234, 212, 0.28); background: rgba(94, 234, 212, 0.08); }
.diffMono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
/* ===== CMCD preset editor: no modal scroll (only cmcd boxes scroll) + hide left labels ===== */

#cmcdDialog .tabPanels{ overflow:hidden !important; }
#cmcdDialog .tabPanel{
  display:none; /* inactive panel */
  flex-direction:column;
  height:100%;
}
#cmcdDialog .tabPanel.active{
  display:flex;
}
#cmcdDialog .tabPanel .cmcdGrid{
  flex:1 1 auto;
  min-height:0;
  max-height:none;
  overflow:auto;
}
#cmcdDialog .cmcdActions{ flex:0 0 auto; }

#cmcdDialog #cmcdPresetMgr{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .scPresetGrid{
  display:flex !important;
  flex-direction:column;
  gap:10px;
  margin-top:10px;
}
#cmcdDialog #cmcdPresetMgr .scPresetGrid > .muted{
  display:none !important; /* hides 'プリセット','名前','内容' */
}
#cmcdDialog #cmcdPresetMgr .scPresetGrid > div{
  width:100%;
}

/* tighten cmcd content box a bit to suppress outer scroll */
#cmcdDialog #cmcdPresetMgr .cmcdGrid{
  margin-top:6px;
  padding:10px;
}
/* make the content container flex so the cmcdGrid can fill remaining space */
#cmcdDialog #cmcdPresetMgr .cmcdPmContent{
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
}


/* FIX: preset tab grid must be the scroll container (wheel over inputs should scroll grid) */
#cmcdDialog [data-tabpanel="cmcdPreset"]{
  display:flex;
  flex-direction:column;
  height:100%;
  min-height:0;
}
#cmcdDialog #cmcdPresetMgr{
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .scPresetGrid{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .cmcdPmContent{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .cmcdGrid{
  flex:1 1 auto;
  min-height:0;
  overflow:auto;
  max-height:none;
}



/* FIX: Ensure preset tab cmcd fields area is the ONLY scrollable region */
#cmcdDialog [data-tabpanel="cmcdPreset"]{
  display:flex;
  flex-direction:column;
  height:100%;
  min-height:0;
}
#cmcdDialog #cmcdPresetMgr{
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .scPresetGrid{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .cmcdPmContent{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .cmcdGrid{
  flex:1 1 auto;
  min-height:0;
  overflow:auto;
  max-height:none;
}



/* FIX: Ensure preset tab cmcd fields area is the ONLY scrollable region */
#cmcdDialog [data-tabpanel="cmcdPreset"]{
  display:flex;
  flex-direction:column;
  height:100%;
  min-height:0;
}
#cmcdDialog #cmcdPresetMgr{
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .scPresetGrid{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr .cmcdPmContent{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr #cmcd_pm_grid{
  flex:1 1 auto;
  min-height:0;
  max-height:none;
  overflow:auto;
}

/* FIX: Ensure preset tab cmcd fields area is the ONLY scrollable region */
#cmcdDialog [data-tabpanel="cmcdPreset"]{
  display:flex;
  flex-direction:column;
  height:100%;
  min-height:0;
}
/* turn preset manager into a flex column so the cmcd grid can take remaining height */
#cmcdDialog #cmcdPresetMgr{
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
/* preset editor wrapper must also fill height and allow children to shrink */
#cmcdDialog #cmcdPresetMgr .scPresetGrid{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
/* content area: only the inner cmcdGrid scrolls */
#cmcdDialog #cmcdPresetMgr .cmcdPmContent{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
#cmcdDialog #cmcdPresetMgr #cmcd_pm_grid{
  flex:1 1 auto;
  min-height:0;
  max-height:none;
  overflow:auto;
}

/* ===== /CMCD preset editor tweaks ===== */


  /* ===== UI polish: soften attach dialog description ===== */
  #pdfAttachDialog .dlgSub{
    font-size:12px;
    line-height:1.35;
  }
  /* ===== /UI polish ===== */

  /* Attach dialog: highlight when file is dragged over */
  .dlg.dragFile{ box-shadow: 0 0 0 3px rgba(70,160,120,.25) inset; }
/* Attachment hint framed box (minimal, no layout change) */
.attachHintBox{
  display:block;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,.25);
  border-radius:14px;
  background:rgba(255,255,255,.04);
  box-shadow:none;
}
/* Keep drop area layout; don't center entire contents */
#pdfAttachDrop{ text-align:left; }
/* Slight extra spacing between description and attach drop zone */
#pdfAttachDialog .pdfZone{ margin-top:14px; }

#pdfAttachDrop .pdfZoneTitle{ margin:0 0 6px 0; font-weight:600; }
#pdfAttachDrop .pdfZoneSub{ margin:0 0 6px 0; }
#pdfAttachDrop .pdfZoneHint{ margin-top:8px; opacity:.9; }

/* カスタムトップバーは一旦全OSで消す（Spotify方向） */
.wc-titlebar,
header.wc-titlebar,
#titlebar{
  display: none !important;
}

:root{
  --win-title-safe: 44px;
  --mac-titlebar-safe: 28px;
  --mac-logo-gap: 10px;
}
.is-win body{
  padding-top: max(env(titlebar-area-height, 0px), var(--win-title-safe), var(--titlebar-drag-h));
}
.is-win .appRoot, .is-win #app{
  padding-top: 0;
}

.is-win .appHeader{
  padding-right: 140px;
}

.is-mac body{
  padding-top: var(--titlebar-drag-h) !important;
}
.is-mac .app,
.is-mac #app,
.is-mac .appRoot{
  padding-top: 0 !important;
  margin-top: 0 !important;
}
.is-mac .appHeader{
  margin-top: var(--mac-logo-gap);
  padding-top: 0;
  padding-left: 0;
}

.no-drag{ -webkit-app-region: no-drag; }

:root{
  --wavcue-header-h: 64px; /* 現状の見た目に近い値。必要なら 60/64/68 で微調整 */
}

/* Header container: never shrink, never clip */
  .appHeader,
  #appHeader,
  .headerBar,
  .topHeader{
  height: var(--wavcue-header-h) !important;
  min-height: var(--wavcue-header-h) !important;
  max-height: var(--wavcue-header-h) !important;

  flex: 0 0 auto !important;
  align-items: center !important;

  overflow: visible !important;
  padding-bottom: 2px !important; /* 1px丸め対策の“逃げ” */
}

/* If header parent clips, neutralize */
body,
.appRoot,
#appRoot,
.mainLayout,
#mainLayout{
  overflow: visible;
}

/* Buttons in header: keep vertical metrics stable */
.appHeader button,
#appHeader button,
.headerBar button,
.topHeader button{
  line-height: 1 !important;
}

/* If there is an inner row that gets clipped */
.appHeader .row,
#appHeader .row,
.headerBar .row,
.topHeader .row,
.appHeader .headerInner,
#appHeader .headerInner{
  height: 100% !important;
  align-items: center !important;
  overflow: visible !important;
}
@media (prefers-reduced-motion: no-preference){
  .appHeader .btn:hover,
  #appHeader .btn:hover,
  .headerBar .btn:hover,
  .topHeader .btn:hover{
    transform: translateY(0);
    filter: brightness(1.08);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 8px 18px rgba(0,0,0,.38);
  }
}
/* ===== Electron drag region hardening ===== */
.appHeader,
#appHeader,
.headerBar,
.topHeader{
  -webkit-app-region: drag;
}
button, a, input, textarea, select, label,
.btn, .iconBtn, .tabBtn, .pill, .chip,
.dialog, dialog, .modal, .modalContent, .modalBody, .modalFooter{
  -webkit-app-region: no-drag !important;
}
dialog,
dialog *{
  -webkit-app-region: no-drag !important;
}
body, #appRoot, .appRoot, .mainLayout{
  -webkit-app-region: no-drag;
}
.appRoot,
.mainLeft{
  overflow: hidden !important;
}

.proFileDock{ flex:1 1 auto; min-width:0; min-height:0; height:100%; display:flex; flex-direction:column; position:relative; overflow:hidden; }
#proFileDock{ flex: 1 1 auto; min-width:0; min-height:0; display:flex; flex-direction:column; overflow:hidden; }
#proFileDock .proFileListWrap{ flex:1 1 auto; min-height:0; display:flex; overflow:hidden; }
#proFileDock .proFileList{ flex:1 1 auto; min-height:0; overflow:auto; padding:6px 8px; }
.proFileDockTop{
  flex:0 0 auto;
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:4px 8px 6px;
  border-bottom:1px solid rgba(255,255,255,0.08);
  flex-wrap:nowrap;
}
.proFileDockLeft{ display:flex; gap:6px; flex-wrap:nowrap; flex:1 1 auto; min-width:0; overflow:hidden; }
.proFileDockRight{ display:flex; gap:6px; align-items:center; flex-wrap:nowrap; justify-content:flex-end; min-width:0; }
.proOnlyWrap{
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  flex: 0 1 auto;
  min-width: 0;
}
.proOnlyWrap .btn{
  flex: 0 1 auto;
  min-width: 0;
  max-width: 100%;
  white-space: nowrap;
  word-break: keep-all;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 1.2;
  padding: 9px 8px;
}
.proOnlyWrap .btnLabel{
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  word-break: keep-all;
  display: block;
}
.proOnlyWrap .proBadge{
  display: none;
  font-size: 10px;
  line-height: 1;
  padding: 2px 6px;
  border-radius: 999px;
  border: 1px solid rgba(251,191,36,.65);
  color: rgba(251,191,36,.95);
  background: rgba(15,23,42,.6);
  flex: 0 0 auto;
  white-space: nowrap;
}
.proOnlyWrap .proTooltip{
  position: absolute;
  left: 50%;
  bottom: calc(100% + 6px);
  transform: translate(-50%, -4px);
  opacity: 0;
  padding: 6px 8px;
  border-radius: 8px;
  font-size: 11px;
  white-space: nowrap;
  color: rgba(229,231,235,.92);
  background: rgba(15,23,42,.92);
  border: 1px solid rgba(148,163,184,.2);
  pointer-events: none;
  transition: opacity .12s ease, transform .12s ease;
  box-shadow: 0 8px 18px rgba(0,0,0,.35);
  z-index: 6;
}
  .proOnlyWrap.proOnlyDisabled .btn{
    opacity: .45;
    cursor: not-allowed;
    pointer-events: none;
  }
  .proOnlyWrap.proOnlyDisabled .proJobMini{
    opacity: .45;
    cursor: not-allowed;
    pointer-events: none;
  }
  .proOnlyWrap.proOnlyDisabled .proBadge{
    display: inline-flex;
  }
.proOnlyWrap.proOnlyDisabled:hover .proTooltip{
  opacity: 1;
  transform: translate(-50%, -6px);
}
.proInput{ height:28px; padding:0 8px; width:180px; }
.proSelect{ height:28px; }
.proFilterWrap{ min-width: 0; flex: 1 1 auto; }
#proFilterStatus{
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  height: 32px;
  padding: 0 34px 0 12px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: rgba(240,242,246,.95);
  outline: none;
  min-width: 0;
  max-width: 100%;
}
#proFilterStatus:focus{
  border-color: rgba(103,167,255,.55);
  box-shadow: 0 0 0 3px rgba(103,167,255,.18);
}
.proFilterWrap{
  position: relative;
  display: inline-block;
}
.proFilterWrap::after{
  content: "▾";
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-52%);
  pointer-events: none;
  color: rgba(240,242,246,.65);
  font-size: 12px;
}
.proBottomRow,
.bottomRow{
  flex: 0 0 180px;
  height: 180px;
  min-height: 180px;
  max-height: 180px;
  display: flex;
  align-items: stretch;
  gap: 12px;
  padding: 10px;
  overflow: hidden;
  min-width: 0;
}
.proBottomRow .proMeterBox{
  width: 120px;
  min-width: 120px;
  max-width: 120px;
  flex: 0 0 120px;
  border-radius: 12px;
  overflow: hidden;
}
.meterBox{
  width: 120px;
  min-width: 120px;
  max-width: 120px;
  flex: 0 0 120px;
  border-radius: 12px;
  overflow: hidden;
}
.proBottomRow .proImagerBox,
.imagerBox{
  width: 180px;
  min-width: 180px;
  max-width: 180px;
  height: 180px;
  min-height: 180px;
  max-height: 180px;
  flex: 0 0 180px;
  border-radius: 12px;
  overflow: hidden;
  display: flex;
  align-items: stretch;
  justify-content: stretch;
}
.proBottomRow .proImagerBox canvas,
.imagerBox canvas{
  width: 100% !important;
  height: 100% !important;
  display: block;
}
.proBottomRow .proFileListBox,
.fileListBox{
  flex: 1 1 auto;
  min-width: 0;
  border-radius: 12px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.proFileListWrap{
  flex:1 1 auto; min-height:0; display:flex; flex-direction:column;
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(0,0,0,.12);
  overflow:hidden;
}
.proFileList{ flex:1 1 auto; min-height:0; overflow:auto; padding:6px 8px; }
#proFileListWrap{
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  overflow: hidden;
}
.proFileRow,
.proRow,
.fileRow{
  min-width:0;
}
.proFileRow{ display:flex; align-items:center; gap:10px; padding:6px 8px; border-radius:8px; cursor:pointer; }
.proFileRow:hover{ background:rgba(255,255,255,0.06); }
.proFileRow.active{ outline:2px solid rgba(120,200,255,0.7); }
.proFileRow.selected{ background:rgba(255,255,255,0.10); }
.proFileRowMain{ flex:1; min-width:0; display:flex; align-items:center; gap:8px; }
.proName,
.proRowName,
.proFileName,
.proFileRowMain,
.fileName{
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  min-width: 0;
}
.proFileFlags{ display:flex; gap:6px; }
.proBadge{ font-size:11px; padding:2px 6px; border-radius:999px; background:rgba(255,255,255,0.10); }
.proFileActions{ display:flex; align-items:center; gap:6px; }
.proFileActionBtn{
  border:1px solid rgba(255,255,255,0.15);
  background:rgba(255,255,255,0.04);
  color:var(--text);
  font-size:11px;
  padding:4px 8px;
  border-radius:999px;
  display:inline-flex;
  align-items:center;
  gap:6px;
  cursor:pointer;
}
.proFileActionBtn:hover{ background:rgba(255,255,255,0.08); }
.proStatusBadge.ok{ border-color:rgba(126,231,162,.45); color:var(--good); }
.proStatusBadge.ng{ border-color:rgba(251,113,133,.45); color:var(--bad); }
.proStatusBadge.unverified{ border-color:rgba(148,163,184,.4); color:var(--muted); }
.proCueBtn{ border-color:rgba(56,189,248,.45); color:#bae6fd; }
.proClipBtn{ border-color:rgba(255,255,255,0.2); }
.miniIcon{ width:12px; height:12px; display:inline-block; }
.proFileDockTop .btn,
.proFileDockTop .proJobMini{
  white-space: nowrap;
  word-break: keep-all;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}
.proJobMini{
  font-size:12px; padding:2px 10px; border-radius:999px;
  background:rgba(255,255,255,0.10);
  user-select:none; cursor:pointer;
  border:1px solid rgba(255,255,255,0.10);
  display:inline-flex;
  align-items:center;
  line-height:1.2;
  min-width:44px;
  flex:0 0 auto;
}
#proJobMiniText{
  white-space: nowrap;
  word-break: keep-all;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}
.proGlobalPopover{
  position:fixed;
  z-index:10020;
  max-width:420px;
  max-height:260px;
}
.proGlobalPopover.hidden{ display:none; }
.proGlobalPopoverInner{
  border:1px solid rgba(148,163,184,.25);
  border-radius:14px;
  background:rgba(17,31,54,.98);
  box-shadow:0 18px 60px rgba(0,0,0,.55);
  padding:10px 12px;
}
.proPopTitle{ font-weight:700; font-size:12px; margin-bottom:6px; }
.proPopBody{ font-size:12px; color:rgba(229,231,235,.9); max-height:200px; overflow:auto; }
.proPopList{ display:grid; gap:6px; }
.proPopRow{ display:flex; justify-content:space-between; gap:8px; }
.proPopItem{ padding:6px 8px; border-radius:10px; background:rgba(255,255,255,0.06); }
.proPopItem button{ all:unset; cursor:pointer; color:inherit; }
.proHistoryLayout{
  display:grid;
  grid-template-columns:minmax(200px, 260px) minmax(0,1fr);
  gap:12px;
  height:100%;
}
.proHistoryDialog{
  width:min(1120px, 96vw);
  height:min(720px, 90vh);
  display:none;
  flex-direction:column;
}
.proHistoryDialog[open]{
  display:flex;
}
.proHistoryDialog .modalBody{
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}
.proHistoryList{
  border:1px solid rgba(255,255,255,0.12);
  border-radius:14px;
  padding:8px;
  background:rgba(8,12,20,0.4);
  max-height:none;
  height:100%;
  overflow:auto;
  display:grid;
  gap:8px;
}
.proHistoryItem{
  border:1px solid rgba(255,255,255,0.12);
  border-radius:12px;
  padding:8px 10px;
  background:rgba(255,255,255,0.04);
  cursor:pointer;
  display:grid;
  gap:4px;
}
.proHistoryItem.active{ border-color:rgba(99,102,241,0.5); background:rgba(99,102,241,0.12); }
.proHistoryMeta{ display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:11px; color:var(--muted); }
.proHistoryTitle{ font-size:12px; font-weight:700; letter-spacing:.02em; }
.proHistoryBadge{ font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.16); }
.proHistoryBadge.ng{ border-color:rgba(248,113,113,0.45); color:rgba(248,113,113,0.95); }
.proHistoryBadge.ok{ border-color:rgba(126,231,162,.45); color:var(--good); }
.proJobPanel{
  position:fixed;
  right:16px;
  bottom:72px;
  width:min(720px, calc(100vw - 64px));
  max-height:min(520px, calc(100vh - 160px));
  overflow:hidden;
  border-radius:16px;
  background:rgba(18,18,22,0.94);
  border:1px solid rgba(255,255,255,0.12);
  box-shadow: 0 16px 60px rgba(0,0,0,0.45);
  padding:12px;
  z-index:10030;
  backdrop-filter: blur(10px);
}
.proJobPanel.hidden{ display:none; }
.proJobPanel.isExpanded{
  right:24px;
  bottom:24px;
  width:min(920px, calc(100vw - 72px));
  max-height:min(680px, calc(100vh - 72px));
}
.proJobPanelHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
}
.proJobTitleRow{
  display:flex;
  align-items:center;
  gap:10px;
}
.proJobTitle{
  font-weight:700;
  letter-spacing:0.02em;
}
.proJobBadge{
  font-size:12px;
  padding:2px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.16);
  background:rgba(255,255,255,0.06);
}
.proJobBadge.isFail{
  border-color: rgba(255,120,120,0.40);
  background: rgba(255,120,120,0.10);
}
.proJobHeaderBtns{
  display:flex;
  gap:8px;
  align-items:center;
}
.btnMini{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.14);
  background:rgba(255,255,255,0.06);
  color:#e9eef7;
}
.btnMini:hover{ background:rgba(255,255,255,0.10); }
.proJobProgressWrap{
  width:100%;
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,0.08);
  overflow:hidden;
  margin:6px 0 10px;
}
.proJobProgressBar{
  height:100%;
  width:0%;
  border-radius:999px;
  background:linear-gradient(90deg, rgba(120,240,200,0.95), rgba(120,180,255,0.95));
}
.proJobMetaRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:8px;
  color:rgba(233,238,247,0.85);
  font-size:12px;
}
.proJobNow{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.nowFile{ color:#e2e8f0; font-weight:600; }
.proJobFailList{
  display:grid;
  gap:6px;
  margin-bottom:8px;
}
.proJobFailItem{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  padding:6px 8px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(255,255,255,0.03);
  font-size:12px;
}
.proJobFailItem .name{ flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.proJobFailItem .btnMini{ padding:4px 8px; font-size:11px; }
.proJobLog{
  height: min(360px, calc(100vh - 320px));
  overflow:auto;
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.18);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:12px;
  line-height:1.55;
  white-space:pre-wrap;
}
.proJobLog .err{ color: rgba(255,140,140,0.95); }
.proJobFooter{
  display:flex;
  justify-content:flex-end;
  gap:10px;
  margin-top:10px;
}
.btnGhost{ background:transparent; border:1px solid rgba(255,255,255,0.18); padding:4px 10px; border-radius:10px; }
.proHistoryDialog .proJobPanel{
  position:static;
  width:100%;
  height:100%;
  max-height:none;
  background:transparent;
  border:none;
  box-shadow:none;
  padding:0;
  display:flex;
  flex-direction:column;
  min-height:0;
}
.proHistoryDialog .proJobPanelHeader{ margin-bottom:10px; }
.proHistoryDialog .proJobLog{ flex:1 1 auto; min-height:160px; height:auto; }
.proJobExportList{
  border:1px solid rgba(255,255,255,0.12);
  border-radius:10px;
  background:rgba(255,255,255,0.03);
  padding:8px 10px;
  font-size:12px;
  max-height:120px;
  overflow:auto;
  display:grid;
  gap:6px;
  margin-bottom:8px;
}
.proJobExportItem{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.ngDetailList{ display:grid; gap:10px; }
.ngDetailCard{
  border:1px solid rgba(255,255,255,0.12);
  border-radius:14px;
  padding:10px 12px;
  background:rgba(255,255,255,0.04);
}
.ngDetailHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  font-weight:700;
}
.ngDetailKey{ font-size:12px; color:var(--muted); letter-spacing:.02em; }
.ngDetailVal{ font-size:13px; color:#e2e8f0; }
.ngDetailGrid{
  margin-top:8px;
  display:grid;
  grid-template-columns:120px 1fr;
  gap:6px 10px;
  font-size:12px;
}
.ngDetailGrid .label{ color:var(--muted); }
.ngDetailEmpty{
  padding:10px 12px;
  border-radius:12px;
  border:1px dashed rgba(255,255,255,0.16);
  color:var(--muted);
  font-size:12px;
}


/* ===== Layout lock (Pro multi-file) - resize safe (FIX) ===== */

/* 右サイド幅・下段高さをここに統一 */
:root{
  --cueW: 340px;
  --bottomH: 190px;     /* 下段(メーター/イメージャ/ファイルリスト)固定高さ */
  --meterW: 140px;
  --imagerS: 190px;
  --gap: 12px;
}

/* main は “flexで伸びる” を最優先（height固定しない） */
.main{
  display:grid !important;
  grid-template-columns: minmax(0,1fr) var(--cueW) !important;
  gap: var(--gap) !important;

  flex: 1 1 auto !important;
  min-height: 0 !important;
  height: auto !important;        /* ★重要：calc(vh...)で固定しない */
}

/* 左カラム */
.left{
  min-width: 0 !important;
  min-height: 0 !important;
  overflow: hidden !important;

  display:flex !important;
  flex-direction: column !important;
}

/* 左カラム内：上可変 + 下固定 を “flex” で作る（grid固定と競合させない） */
.workCol{
  display:flex !important;
  flex-direction: column !important;
  min-height: 0 !important;
  height: auto !important;
  overflow: hidden !important;
}
.workTop{
  flex: 1 1 auto !important;
  min-height: 0 !important;
  display:flex !important;
  flex-direction: column !important;
  overflow: hidden !important;
}

/* sectionHead の下を波形+トランスポートで使い切る */
.waveWrap{
  flex: 1 1 auto !important;      /* ★重要：height:100%は禁止 */
  min-height: 0 !important;
  height: auto !important;
  display:flex !important;
  flex-direction: column !important;
}

/* 波形枠は残りを占有 */
.waveBox, #waveBox{
  flex: 1 1 auto !important;
  min-height: 0 !important;
  overflow: hidden !important;
}

/* 下段（analyzersRow）は高さを var(--bottomH) に統一 */
.workBottom,
.analyzers,
#analyzersRow{
  flex: 0 0 var(--bottomH) !important;
  height: var(--bottomH) !important;
  min-height: var(--bottomH) !important;
  max-height: var(--bottomH) !important;

  display:flex !important;
  gap: var(--gap) !important;
  align-items: stretch !important;
  overflow: hidden !important;
  position: relative !important;
}

/* メーター・イメージャの枠 */
.meterBox, .meterBlock{
  width: var(--meterW) !important;
  min-width: var(--meterW) !important;
  height: 100% !important;
  overflow: hidden !important;
  border-radius: 12px !important;
}
.imagerBox, .imagerBlock{
  width: var(--imagerS) !important;
  min-width: var(--imagerS) !important;
  height: 100% !important;
  aspect-ratio: 1 / 1 !important;
  overflow: hidden !important;
  border-radius: 12px !important;
}

/* ファイルリストは残り横幅を全て、縦は枠内スクロール */
#proFileDock, .proFileDock{
  flex: 1 1 auto !important;
  min-width: 0 !important;
  height: 100% !important;
  overflow: hidden !important;
  border-radius: 12px !important;
  display:flex !important;
  flex-direction: column !important;
}
#proFileListWrap{
  flex: 1 1 auto !important;
  min-height: 0 !important;
  overflow: auto !important;
}

/* canvasは枠に追従 */
#meterCanvas, #imagerCanvas{
  width: 100% !important;
  height: 100% !important;
  display:block !important;
}

/* 右サイド */
#cueSide, .cueSide{
  grid-column: 2 / 3 !important;
  min-height: 0 !important;
  height: 100% !important;
  overflow: hidden !important;
  position: relative !important;
}
#cueSide .btnRow,
#cueSide .row,
#cueSide .cueTopRow{
  display:flex !important;
  flex-wrap: nowrap !important;
  gap: 10px !important;
}
#cueSide button{
  white-space: nowrap !important;
}

/* ===== end ===== */
  /* ===== Pro layout hard-fix (bottom row) ===== */

  /* 下段の行は必ず横幅100%を取る。ここが 180px 固定になっていたのが崩れの主因 */
  #analyzersRow,
  .analyzersRow,
  .analyzers{
    width: 100%;
  }

  /* 背景模様の疑似要素が被るのを防ぐ（背景は背面、実コンテンツは前面） */
  #analyzersRow,
  .analyzersRow,
  .analyzers,
  .waveWrap{
    position: relative;
  }
  #analyzersRow::before,
  .analyzersRow::before,
  .analyzers::before,
  .waveWrap::before{
    pointer-events: none;
    z-index: 0;
  }
  #analyzersRow > *,
  .analyzersRow > *,
  .analyzers > *,
  .waveWrap > *{
    position: relative;
    z-index: 1;
  }

  /* 3カラム下段：高さ固定＆押し出し禁止 */
  .proBottomRow.bottomRow,
  .proBottomRow,
  .bottomRow{
    display: flex;
    align-items: stretch;
    gap: 12px;
    width: 100%;
    height: 190px;        /* 固定（必要なら微調整OK） */
    min-height: 190px;
    max-height: 190px;
    flex: 0 0 190px;      /* “高さ”として固定。幅固定にはしない */
    box-sizing: border-box;
    overflow: hidden;     /* 行全体ははみ出しさせない */
  }

  /* メーター：固定幅（押し出し禁止） */
  .proMeterBox,
  .meterBox{
    width: 140px;
    min-width: 140px;
    max-width: 140px;
    height: 100%;
    border-radius: 12px;
    overflow: hidden;
    flex: 0 0 140px;
  }

  /* イメージャ：正方形固定（押し出し禁止） */
  .proImagerBox,
  .imagerBox{
    width: 190px;
    min-width: 190px;
    max-width: 190px;
    height: 100%;
    border-radius: 12px;
    overflow: hidden;
    flex: 0 0 190px;
  }

  /* ファイルリスト：残り幅全部。min-width:0 を必ず入れる（これが無いと width:0 が起きやすい） */
  .proFileListBox.fileListBox,
  .proFileListBox,
  .fileListBox{
    flex: 1 1 auto;
    min-width: 0;
    height: 100%;
    border-radius: 12px;
    overflow: hidden; /* 中だけスクロール */
  }

  /* ここが DevTools で width:0 になっていた実体。強制的に幅を持たせる */
  #proFileDock{
    display: flex;
    flex-direction: column;
    flex: 1 1 auto;
    min-width: 0;
    height: 100%;
    overflow: hidden;
  }

  /* リスト本体は中でスクロール */
  #proFileListWrap{
    flex: 1 1 auto;
    min-height: 0;
    overflow: auto;
  }

  /* キャンバスが親にフィットするように */
  #meterCanvas,
  #imagerCanvas{
    width: 100% !important;
    height: 100% !important;
    display: block;
  }

  /* CUEメニュー内：ボタンが2段折り返しにならないように（見た目のみ） */
  .cueMenu .row,
  #cueMenu .row,
  .cueMenuRow{
    display: flex;
    gap: 10px;
    flex-wrap: nowrap;
    align-items: center;
  }
  .cueMenu .row > *,
  #cueMenu .row > *{
    min-width: 0;
  }

  /* ===== FIX: .proBottomRow width collapse (was 180px) ===== */
  #analyzersRow .proBottomRow,
  .workBottom .proBottomRow{
    width: 100% !important;       /* ★横幅180px固定を解除 */
    flex: 1 1 auto !important;    /* ★flex-basis固定(180px)を打ち消す */
    min-width: 0 !important;
    box-sizing: border-box !important;
  }

  /* 子要素が幅0にならないための再保証 */
  #analyzersRow .proFileListBox,
  #analyzersRow #proFileDock{
    flex: 1 1 auto !important;
    min-width: 0 !important;
  }

  /* ファイルリスト内部は縦スクロール */
  #analyzersRow #proFileListWrap{
    height: 100% !important;
    overflow: auto !important;
    min-height: 0 !important;
  }
  /* ===== end ===== */

  /* ===== end ===== */

  /* ===== Bottom analyzers layout hardening (2026) ===== */
  /* 下部行：必ず横いっぱいを占有し、子が押し出されても幅0にならない */
  #analyzersRow, .analyzersRow, .analyzers {
    width: 100% !important;
    min-width: 0 !important;
    height: 210px !important;
    min-height: 0 !important;
    flex: 0 0 210px !important;
  }
  .bottomRow, .proBottomRow {
    display: flex !important;
    align-items: stretch !important;
    gap: 12px !important;
    width: 100% !important;
    min-width: 0 !important;
    height: 210px !important;           /* 少し増やす：ファイルリスト領域を広げる */
    flex: 0 0 210px !important;
    overflow: hidden !important;
  }

  /* メーター：固定幅 */
  .bottomRow .meterBox, .bottomRow .proMeterBox {
    width: 140px !important;
    min-width: 140px !important;
    height: 100% !important;
    border-radius: 12px !important;
    overflow: hidden !important;
  }

  /* イメージャ：正方形固定（高さに追従） */
  .bottomRow .imagerBox, .bottomRow .proImagerBox {
    width: 210px !important;            /* bottomRowの高さと揃えると正方形に見える */
    min-width: 210px !important;
    height: 100% !important;
    border-radius: 12px !important;
    overflow: hidden !important;
  }

  /* ファイルリスト：残り全部。幅0禁止。左下見切れ対策で内側padding */
  .bottomRow .fileListBox, .bottomRow .proFileListBox {
    flex: 1 1 auto !important;
    min-width: 0 !important;
    height: 100% !important;
    border-radius: 12px !important;
    overflow: hidden !important;
    padding: 4px 8px 14px 8px;   /* 左下見切れ対策 */
    box-sizing: border-box !important;
  }

  /* これが幅0になっていた本丸：必ず伸びるように固定 */
  #proFileDock, .proFileDock {
    flex: 1 1 auto !important;
    min-width: 0 !important;
    width: auto !important;
    height: 100% !important;
    overflow: auto !important;
    position: relative !important;
  }

  /* 波形ビュー縦幅を現状の約80%へ */
  .waveWrap{
    flex: 0 0 auto !important;
    min-height: 0 !important;
  }

  /* 左パネルがflex縦なら、波形部分を少し抑える */
  .panel.left, .left.panel{
    display: flex !important;
    flex-direction: column !important;
    min-height: 0 !important;
  }
  .panel.left .waveWrap, .left.panel .waveWrap{
    flex: 1 1 auto !important;
    min-height: 0 !important;
  }

  /* 左パネルがgridなら、grid-template-rows を「1fr 210px」にする */
  .workCol{
    grid-template-rows: 1fr 210px !important;
  }
  .workBottom{
    height: 210px !important;
    min-height: 210px !important;
  }

  /* CUEメニュー内ボタンの折り返し防止 */
  .cueTopControls{
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: nowrap;
  }
  .cueTopControls > *{
    min-width: 0;
  }
  .cueTopControls button,
  .cueTopControls .btn{
    white-space: nowrap;
  }
  .cueTopControls input{
    flex: 1;
    min-width: 0;
  }
  /* ===== /Bottom analyzers layout hardening ===== */

  /* ===== FIX: bottom row (meter/imager/file list) collapsing to width:0 ===== */
  /* analyzersRow は「下段」を縦方向のスタックとして固定（row化すると proBottomRow が幅180扱いで潰れる） */
  #analyzersRow,
  .workBottom.analyzers{
    display: flex !important;
    flex-direction: column !important;
    width: 100% !important;
    min-width: 0 !important;
    min-height: 0 !important;
  }

  /* proBottomRow は “高さ180pxの段” であり、幅を100%保証する */
  .proBottomRow,
  .bottomRow{
    width: 100% !important;
    flex: 0 0 180px !important;   /* column時は高さとして効く */
    box-sizing: border-box !important;
    min-width: 0 !important;
  }

  /* 中身（ファイルリスト側）が 0 幅にならないための保険 */
  .proBottomRow .proFileListBox,
  .fileListBox,
  #proFileDock,
  .proFileDock{
    flex: 1 1 0% !important;
    min-width: 0 !important;
  }

  /* ===== Stability patch: bottom row width + cue pair layout ===== */
  .bottomRow,
  .proBottomRow,
  #analyzersRow,
  .analyzers{
    width: 100% !important;
    min-width: 0 !important;
    flex-basis: auto !important;
  }
  .fileListBox,
  .proFileListBox,
  #proFileDock,
  .proFileDock,
  #proFileListWrap{
    min-width: 0 !important;
  }
  #proFileDock{
    flex: 1 1 auto !important;
    overflow: hidden !important;
  }
  #proFileListWrap{
    flex: 1 1 auto !important;
    overflow: hidden !important;
  }
  .proFileList{
    overflow: auto !important;
  }
  .cuePairTop,
  .cuePairBottom{
    display: flex !important;
    align-items: center !important;
    gap: 10px !important;
    flex-wrap: nowrap !important;
    min-width: 0 !important;
  }
  .cuePairTop{
    white-space: nowrap !important;
  }
  .cuePairTop .pairRow{
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: nowrap;
    min-width: 0;
  }
  .cuePairBottom{
    overflow: hidden !important;
  }
  .cuePairBottom .linkMiniLabel{
    white-space: nowrap !important;
    flex: 0 0 auto !important;
  }
  #pairSeconds{
    flex: 0 0 auto !important;
    width: 84px !important;
    max-width: 84px !important;
  }
  /* ===== /Stability patch ===== */

  /* ===== UI adjustments: logo size, drag strip, bottom layout ===== */
  #dragStrip{
    display: none !important;
    height: 0 !important;
  }
  #titlebarDrag{
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: var(--titlebar-drag-h);
    -webkit-app-region: drag;
    z-index: 9999;
    background: transparent;
    contain: layout paint;
  }
  #titlebarDrag::before{
    content:"";
    position:absolute;
    top:0;
    left:0;
    width: 88px;
    height: var(--titlebar-drag-h);
    -webkit-app-region: no-drag;
  }
  .appHeader,
  #appHeader,
  .headerBar,
  .topHeader,
  .menuBar,
  .topBar,
  .toolbarWrap{
    -webkit-app-region: drag;
  }
  button,
  a,
  input,
  textarea,
  select,
  [role="button"],
  .noDrag{
    -webkit-app-region: no-drag;
  }

  .workCol{
    grid-template-rows: minmax(var(--wave-min-h), 1fr) var(--fileList-min-h) !important;
  }
  .workBottom,
  #analyzersRow,
  .analyzersRow,
  .analyzers,
  .bottomRow,
  .proBottomRow{
    height: var(--bottom-line-h) !important;
    min-height: var(--bottom-line-h) !important;
    flex: 0 0 var(--bottom-line-h) !important;
  }
  .waveWrap{
    min-height: var(--wave-min-h) !important;
  }

  .meterBox,
  .proMeterBox,
  .imagerBox,
  .proImagerBox{
    height: var(--bottom-line-h) !important;
    min-height: var(--bottom-line-h) !important;
    box-sizing: border-box;
  }
  .meterBox,
  .proMeterBox{
    padding-bottom: 10px;
    overflow: visible;
  }
  .imagerBox,
  .proImagerBox{
    padding-bottom: 12px;
    overflow: visible;
    box-sizing: border-box;
  }
  .imagerBox canvas,
  .proImagerBox canvas{
    height: 100% !important;
    width: 100% !important;
    display: block;
  }

  .fileListBox,
  .proFileListBox{
    min-height: var(--bottom-line-h);
    height: var(--bottom-line-h);
    overflow: hidden;
  }
  /* ==== FINAL OVERRIDES: PRO-only visual parity (must win) ==== */
  #proFilterWrap.proOnlyDisabled #proFilterStatus{ display:none !important; }
  #proFilterWrap.proOnlyDisabled #proFilterStub{ display:inline-flex !important; }
  #proFilterWrap:not(.proOnlyDisabled) #proFilterStub{ display:none !important; }
  #proFilterWrap.proOnlyDisabled::after{ content: none !important; }

  /* 履歴ボタンを他.btnと同じ“PRO無効ボタン”の見た目に揃える（サイズだけ調整） */
  #proJobMini.btn.proJobMini{
    height:32px !important;
    padding: 9px 10px !important;
    border-radius:12px !important;
    display:inline-flex !important;
    align-items:center !important;
    gap:8px !important;
  }

  #proFilterStub.btn.proFilterStub{
    height:32px !important;
    padding: 9px 10px !important;
    border-radius:12px !important;
    display:inline-flex !important;
    align-items:center !important;
    gap:8px !important;
  }
  /* ============================================================
     FINAL OVERRIDES (Bottom layout truth)
     - Fix meter bottom crop (rounded corners)
     - Align meter/imager/file list bottoms
     - Keep file dock controls sane (no scattered buttons)
     ============================================================ */

  /* ① bottomRow の高さを“1つ”に統一（他の競合は無視） */
  :root{
    --wcBottomH: 240px;      /* 下段高さの真実（他の --bottomH/--bottom-line-h は無視） */
    --wcBottomGap: 12px;
    --wcBottomPad: 10px;
    --wcMeterW: 120px;
    --wcImagerS: 240px;      /* bottomHと合わせると正方形 */
  }

  /* bottomコンテナは必ずこの高さで、子はstretch */
  .workBottom,
  #analyzersRow,
  .analyzersRow,
  .analyzers,
  .bottomRow,
  .proBottomRow{
    height: var(--wcBottomH) !important;
    min-height: var(--wcBottomH) !important;
    max-height: var(--wcBottomH) !important;
    display: flex !important;
    align-items: stretch !important;
    gap: var(--wcBottomGap) !important;
    padding: var(--wcBottomPad) !important;
    box-sizing: border-box !important;
    overflow: hidden !important;  /* はみ出しは許可しない */
    transform: none !important;   /* 変な持ち上げ禁止 */
  }

  /* ② メーター：はみ出しの主因を潰す（box-sizing + padding 제거 + 100%） */
  .meterBox,
  .proMeterBox,
  .meterBlock{
    width: var(--wcMeterW) !important;
    min-width: var(--wcMeterW) !important;
    max-width: var(--wcMeterW) !important;
    flex: 0 0 var(--wcMeterW) !important;
    height: 100% !important;
    min-height: 0 !important;
    padding: 0 !important;          /* ←これが重要（見かけ高さ増加を防ぐ） */
    box-sizing: border-box !important;
    overflow: hidden !important;     /* 親で切られないよう、自分でクリップ */
    border-radius: 12px !important;
    display: flex !important;
    align-items: stretch !important;
  }

  /* canvas は枠に追従 */
  #meterCanvas{
    width: 100% !important;
    height: 100% !important;
    display: block !important;
  }

  /* ③ イメージャ：下端揃え（上に浮く原因を潰す） */
  .imagerBox,
  .proImagerBox,
  .imagerBlock{
    width: var(--wcImagerS) !important;
    min-width: var(--wcImagerS) !important;
    max-width: var(--wcImagerS) !important;
    flex: 0 0 var(--wcImagerS) !important;
    height: 100% !important;
    min-height: 0 !important;
    padding: 0 !important;
    box-sizing: border-box !important;
    overflow: hidden !important;
    border-radius: 12px !important;
    display: flex !important;
    align-items: stretch !important;
    justify-content: stretch !important;
    transform: none !important;
    margin: 0 !important;
  }
  #imagerCanvas{
    width: 100% !important;
    height: 100% !important;
    display: block !important;
  }

  /* ④ ファイルリスト：残り幅を全部、縦は100%で下端揃え */
  .fileListBox,
  .proFileListBox,
  #proFileDock,
  .proFileDock{
    flex: 1 1 auto !important;
    min-width: 0 !important;
    height: 100% !important;
    min-height: 0 !important;
    box-sizing: border-box !important;
    overflow: hidden !important;
    border-radius: 12px !important;
    display: flex !important;
    flex-direction: column !important;
  }

  /* ⑤ “ボタン群＋フィルター” の位置を上げて、見切れ/右詰め過ぎを防ぐ */
  .proFileDockTop{
    flex: 0 0 auto !important;
    display: flex !important;
    align-items: center !important;
    justify-content: space-between !important;
    gap: 8px !important;
    padding: 4px 8px 6px !important;   /* ←上側を詰める（常識的に） */
    flex-wrap: wrap !important;        /* 縮小時は2段に逃がして重なり防止 */
    min-width: 0 !important;
  }

  /* 左右ブロックの折り返し/押し潰れ対策 */
  .proFileDockLeft{
    display: flex !important;
    gap: 6px !important;
    flex-wrap: nowrap !important;
    flex: 1 1 100% !important;
    min-width: 0 !important;
    overflow: hidden !important;
    justify-content: flex-start !important;
  }
  .proFileDockRight{
    display: flex !important;
    gap: 6px !important;
    align-items: center !important;
    flex-wrap: nowrap !important;
    justify-content: flex-end !important;
    flex: 0 0 auto !important;
    min-width: 0 !important; /* 右側の謎スペースを撤廃 */
  }

  /* フィルター等が “右に寄りすぎて見切れる” のを防ぐ（wrapのmin-width問題を潰す） */
  .proOnlyWrap{
    min-width: 0 !important;
    max-width: 100% !important;
  }
  .proOnlyWrap .btn,
  .proOnlyWrap select{
    min-width: 0 !important;
    max-width: 100% !important;
  }
  .proBtnGroup{
    display:inline-flex !important;
    align-items:center !important;
    gap:6px !important;
    flex:0 0 auto !important;
    white-space:nowrap !important; /* バッジ落ち防止 */
  }
  .proBtnGroup .proBadge{
    flex:0 0 auto !important;
    white-space:nowrap !important;
  }
  .proFileDockLeft{
    min-width: 0 !important;
    overflow: hidden !important;
  }
  .proFileDockLeft .btn{
    white-space: nowrap !important;
  }

  /* リスト本体：上の余白を詰め、下端は切れない */
  #proFileListWrap,
  .proFileListWrap{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: hidden !important;
  }
  .proFileList{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: auto !important;
    padding: 4px 8px 10px !important;  /* ←上を詰めて左右との隙間感を揃える */
  }
  .proFileRow{
    padding: 4px 8px !important;
  }
  #proFileDock .proFileList{
    padding: 4px 8px !important;
  }
  .waveWrap{
    gap: var(--gap) !important;
  }
  .waveBox{
    border-radius:12px !important;
    overflow:hidden !important;
  }
  .transport{
    border-radius:12px !important;
    padding:8px 10px !important;
  }
  /* ===== FINAL: PRO badge is ALWAYS outside (no overlay) ===== */
  .proOnlyWrap,
  .proBtnGroup,
  #proJobMiniWrap,
  #proFilterWrap{
    position: relative !important;
    display: inline-flex !important;
    align-items: center !important;
    gap: 6px !important;
    white-space: nowrap !important;
    flex: 0 0 auto !important;
    min-width: 0 !important;
  }
  .proBadge{
    position: static !important;
    top: auto !important;
    right: auto !important;
    transform: none !important;
    margin: 0 !important;
    z-index: auto !important;
    pointer-events: none !important;
    white-space: nowrap !important;
  }
  .proOnlyWrap .btn,
  .proBtnGroup .btn,
  #proJobMiniWrap .btn,
  #proFilterWrap .btn,
  #proFilterWrap select{
    padding-right: 12px !important;
  }
  .proFileDockRight{
    min-width: 0 !important;
    overflow: visible !important;
  }
  .proFileDockLeft{
    flex: 1 1 auto !important;
    min-width: 0 !important;
    overflow: hidden !important;
  }
  .proFileDockLeft .btn{
    max-width: 100% !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    white-space: nowrap !important;
  }
  #proFilterWrap{
    flex: 0 0 auto !important;
  }
  /* ===== FINAL: Imager follows UI alignment (no square lock) ===== */
  .imagerBox,
  .proImagerBox,
  .imagerBlock{
    width: auto !important;
    height: 100% !important;
    flex: 1 1 auto !important;
    aspect-ratio: auto !important;
  }
  .imagerBlock{
    height: 100% !important;
    min-height: 0 !important;
  }
  /* FINAL OVERRIDES active selectors:
     - .proFileDockTop/.proFileDockLeft/.proFileDockRight (wrap + no overlap)
     - .imagerBlock/.imagerBox/.proImagerBox (height:100% alignment)
     - :root --wcBottomH (single source of truth) */
  .imagerBox canvas,
  .proImagerBox canvas,
  .imagerBlock canvas{
    width: 100% !important;
    height: 100% !important;
    display: block !important;
  }
  .bottomRow,
  .proBottomRow{
    padding: 10px !important;
    align-items: stretch !important;
  }
  .meterBox,
  .imagerBox,
  .fileListBox{
    padding: 0 !important;
    overflow: hidden !important;
    border-radius: 12px !important;
  }
  /* ===== /UI adjustments ===== */
</style></head><body>
<div id="titlebarDrag"></div>
<!-- ICON SPRITE (no emoji) -->
<svg aria-hidden="true" focusable="false" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg">
<symbol id="ico-folder" viewbox="0 0 24 24">
<path d="M3 6a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6z" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
</symbol>
<symbol id="ico-puzzle" viewbox="0 0 24 24">
<path d="M8 2a2 2 0 0 0-2 2v1H5a2 2 0 0 0-2 2v2h1a2 2 0 1 1 0 4H3v2a2 2 0 0 0 2 2h1v1a2 2 0 0 0 2 2h2v-1a2 2 0 1 1 4 0v1h2a2 2 0 0 0 2-2v-1h1a2 2 0 0 0 2-2v-2h-1a2 2 0 1 1 0-4h1V7a2 2 0 0 0-2-2h-1V4a2 2 0 0 0-2-2h-2v1a2 2 0 1 1-4 0V2H8z" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
</symbol>
<symbol id="ico-file-text" viewbox="0 0 24 24">
<path d="M14 2H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7l-5-5z" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
<path d="M14 2v5h5" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
<path d="M8 13h8M8 17h8M8 9h3" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"></path>
</symbol>
<symbol id="ico-check" viewbox="0 0 24 24">
<path d="M20 6 9 17l-5-5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"></path>
</symbol>
<symbol id="ico-clipboard-check" viewbox="0 0 24 24">
<path d="M9 2h6a2 2 0 0 1 2 2v2h-2V5H9v1H7V4a2 2 0 0 1 2-2z" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
<path d="M7 6h10a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2z" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
<path d="M9 14l2 2 4-4" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"></path>
</symbol>
<symbol id="ico-download" viewbox="0 0 24 24">
<path d="M12 3v10" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"></path>
<path d="M8 11l4 4 4-4" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
<path d="M4 17v3a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-3" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</symbol>
<symbol id="ico-paperclip" viewbox="0 0 24 24">
<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</symbol>
<symbol id="ico-gear" viewbox="0 0 24 24">
<path d="M12 8.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7z" fill="none" stroke="currentColor" stroke-width="2"></path>
<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="2"></path>
</symbol>
</svg>
<div aria-hidden="true" id="dropOverlay"><div class="box"><div class="big">WAVをドロップして読み込み</div></div></div><div class="small"></div><div class="app">
<div aria-hidden="true" id="progressOverlay">
  <div class="box" role="status" aria-live="polite" aria-atomic="true">
    <div class="meta">
      <div class="msg" id="progMsg">処理中…</div>
      <div class="pct" id="progPct">0%</div>
    </div>
    <div class="bar"><div id="progBar"></div></div>
    <div class="sub" id="progSub"> </div><div class="rowBetween" style="margin-top:10px;gap:10px"><div class="muted" id="progHint" style="font-size:11px;color:rgba(229,231,235,.72)"></div><button class="btn" id="btnProgCancel" type="button" style="display:none">キャンセル</button></div>
  </div>
</div>
<div aria-hidden="true" id="bulkOverlay">
  <div class="box" role="status" aria-live="polite" aria-atomic="true">
    <div class="meta">
      <div class="msg" id="bulkMsg">一括処理中…</div>
      <div class="pct" id="bulkPct">0%</div>
    </div>
    <div class="bar"><div id="bulkBar"></div></div>
    <div class="sub" id="bulkSub"> </div>
    <div class="sub" id="bulkNow"> </div>
  </div>
</div>
<header class="appHeader">
  <div class="hdrLeft">
    <div class="brand">
      <span aria-hidden="true" class="brandMark">
        <img alt="" class="brandLogo" src="./wavcue-logo-set.svg"/>
      </span>
    </div>
    <div class="btnRow"><input accept=".wav,audio/wav,audio/wave" hidden="" id="fileInput" type="file"/><button class="btn" id="btnBrowse" type="button"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-folder" xlink:href="#ico-folder"></use></svg>ファイルを開く</button><span class="pill" id="statusPill">ファイル未選択</span><span class="pill fileName" id="fileName">-</span></div>
  </div>
  <div class="hdrMid"></div>
  <div class="hdrRight">
    <div class="btnRow"><button class="btn" id="btnChunk" type="button"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-puzzle" xlink:href="#ico-puzzle"></use></svg>チャンク/ログ</button><button class="btn" disabled="" id="btnCmcd" type="button"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-file-text" xlink:href="#ico-file-text"></use></svg>cmcd入力</button><button class="btn" id="btnPdfAttach" title="WAVへファイルを添付（LIST/adtl/file）"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-paperclip" xlink:href="#ico-paperclip"></use></svg>ファイル添付</button><button class="btn" disabled="" id="btnStdCheck" type="button"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-clipboard-check" xlink:href="#ico-clipboard-check"></use></svg>規格チェック</button><button class="btn good" disabled="" id="btnExport" type="button"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-download" xlink:href="#ico-download"></use></svg>書き出し</button></div>
    <span id="tierBadge" class="tierBadge--demo">DEMO</span>
        <div class="headerActions"><button aria-label="設定" class="btn" id="btnSettings" title="設定" type="button"><svg aria-hidden="true" class="btnIcon" focusable="false"><use href="#ico-gear" xlink:href="#ico-gear"></use></svg></button></div>
  </div>
</header>
<div id="licenseBanner" role="status" aria-live="polite"></div>
<dialog id="standardGraceDialog" class="standardGraceDialog" data-lock-close="1" aria-labelledby="standardGraceTitle" aria-describedby="standardGraceMessage">
  <div class="stdGraceBody">
    <div class="stdGraceTitle" id="standardGraceTitle">Standard認証のご案内</div>
    <div class="stdGraceMsg" id="standardGraceMessage">Standard認証が切れました。1時間後に書き出しのみ停止します。ネット接続を確認して再認証してください。</div>
  </div>
  <div class="stdGraceActions">
    <button class="btn primary" id="standardGraceOk" type="button">OK</button>
  </div>
</dialog>
<div class="main"><div class="left panel workCol"><div class="workTop"><div class="sectionHead"><div class="title"><b></b><span></span></div><div class="row"><span class="pill mono" id="timeHud">00:00.000</span><span class="pill mono" id="zoomHud">x1.00 / v1.00</span></div></div><div class="waveWrap"><div class="waveBox" id="waveBox"><canvas id="wave"></canvas><canvas id="cueCanvas"></canvas></div><div aria-label="transport" class="transport"><button class="tbtn" disabled="" id="btnPlay" type="button"><span class="ticon">▶︎</span> 再生</button><button class="tbtn" disabled="" id="btnPause" type="button"><span class="ticon ticonStop"></span> 停止</button><div class="tsep"></div><button class="tbtn" disabled="" id="btnZoomIn" type="button">＋ 横</button><button class="tbtn" disabled="" id="btnZoomOut" type="button">－ 横</button><div class="tsep"></div><button class="tbtn" disabled="" id="btnVZoomIn" type="button">＋ 縦</button><button class="tbtn" disabled="" id="btnVZoomOut" type="button">－ 縦</button><div class="thint mono">Space: 再生/停止　T/R: 横ズーム　Shift+T/R: 縦ズーム</div></div></div></div><div class="workBottom analyzers analyzersRow" id="analyzersRow"><div class="bottomRow"><div class="meterBox"><canvas id="meterCanvas"></canvas></div><div class="imagerBox"><canvas id="imagerCanvas"></canvas></div><div class="fileListBox"><div id="proFileDock" class="proFileDock">
  <div class="proFileDockTop">
    <div class="proFileDockLeft">
      <div class="proOnlyWrap" id="proBtnBulkImportWrap">
        <span class="proBtnGroup">
          <button id="proBtnBulkImport" class="btn" type="button"><span class="btnLabel">一括読み込み</span></button>
          <span class="proBadge">PRO</span>
        </span>
        <span class="proTooltip">Proで利用できます</span>
        <input accept=".wav,audio/wav,audio/wave" hidden="" id="proBulkInput" multiple="" type="file"/>
      </div>
      <div class="proOnlyWrap" id="proBtnBatchCheckWrap">
        <span class="proBtnGroup">
          <button id="proBtnBatchCheck" class="btn" type="button"><span class="btnLabel">一括チェック</span></button>
          <span class="proBadge">PRO</span>
        </span>
        <span class="proTooltip">Proで利用できます</span>
      </div>
      <div class="proOnlyWrap" id="proBtnBatchExportWrap">
        <span class="proBtnGroup">
          <button id="proBtnBatchExport" class="btn" type="button"><span class="btnLabel">まとめて書き出し</span></button>
          <span class="proBadge">PRO</span>
        </span>
        <span class="proTooltip">Proで利用できます</span>
      </div>
    </div>
    <div class="proFileDockRight">
      <div class="proOnlyWrap proFilterWrap" id="proFilterWrap">
        <button id="proFilterStub" class="btn proFilterStub" type="button" aria-disabled="true">
          <span class="btnLabel" id="proFilterStubLabel">全て</span>
        </button>
        <select id="proFilterStatus" class="proSelect btn">
          <option value="all">全て</option>
          <option value="unverified">未確認</option>
          <option value="ok">規格OK</option>
          <option value="ng">規格NG</option>
          <option value="unexported">未書き出し</option>
          <option value="exported">書き出し済み</option>
        </select>
        <span class="proBadge">PRO</span>
        <span class="proTooltip">Proで利用できます</span>
      </div>
      <div class="proOnlyWrap" id="proJobMiniWrap">
        <button id="proJobMini" class="btn proJobMini" type="button" title="履歴">
          <span id="proJobMiniText">履歴</span>
        </button>
        <span class="proBadge">PRO</span>
        <span class="proTooltip">Proで利用できます</span>
      </div>
    </div>
  </div>

  <div id="proFileListWrap" class="proFileListWrap">
        <div id="proFileList" class="proFileList" tabindex="0"></div>
  </div>

  <dialog id="proHistoryDialog" class="proHistoryDialog modal">
    <div class="modalHead">
      <div class="title">
        <b>履歴</b>
        <span class="muted" id="proHistorySubtitle">一括処理のログ</span>
      </div>
    </div>
    <div class="modalBody">
      <div class="proHistoryLayout">
        <div class="proHistoryList" id="proHistoryList"></div>
        <div id="proJobPanel" class="proJobPanel">
          <div class="proJobPanelHeader">
            <div class="proJobTitleRow">
              <div class="proJobTitle" id="proJobTitle">詳細ログ</div>
              <div id="proJobFailBadge" class="proJobBadge">—</div>
            </div>
            <div class="proJobHeaderBtns">
              <button id="proJobCopy" class="btnMini">コピー</button>
              <button id="proJobClear" class="btnMini">クリア</button>
            </div>
          </div>

          <div class="proJobProgressWrap">
            <div id="proJobProgressBar" class="proJobProgressBar"></div>
          </div>

          <div class="proJobMetaRow">
            <div id="proJobNow" class="proJobNow">—</div>
            <div>
              <span id="proJobCount">0/0</span>
              <span style="margin-left:10px" id="proJobStat">OK:0 / 失敗:0</span>
            </div>
          </div>

          <div id="proJobFailList" class="proJobFailList"></div>
          <div id="proJobExportList" class="proJobExportList" style="display:none"></div>

          <div id="proJobLog" class="proJobLog"></div>

          <div class="proJobFooter">
            <button id="proJobRetryFailed" class="btn">失敗のみ再実行</button>
            <button id="proJobCancel" class="btnGhost">停止</button>
          </div>
        </div>
      </div>
    </div>
  </dialog>
</div></div></div></div></div><aside class="panel right cueSide" id="cueSide"><div class="sectionHead"><div class="title"><b>CUEメニュー</b><span>CUE一覧 / 追加 / 移動 / 削除</span></div></div><div class="sidePad"><div class="card"><div class="rowBetween"><label>CUE追加（再生ヘッド位置）</label><span class="pill mono" id="cueCount">0</span></div><div class="row cueButtonsRow cueTopControls cuePairTop" style="margin-top:8px;align-items:center"><div class="pairRow"><button class="btn" disabled="" id="btnAddPair" type="button">＋ STANDBY→END 追加</button><div class="linkMini" title="ON: STANDBY/END を同じ間隔で連動移動 / OFF: 個別に移動"><label class="switch"><input checked="" id="chkLinkPair" type="checkbox"/><span class="slider"></span></label><span class="linkMiniLabel">連動移動</span></div></div></div><div class="row cueButtonsRow cuePairBottom" style="margin-top:6px;align-items:center"><span class="linkMiniLabel">秒数（STANDBY→END間隔）</span><input id="pairSeconds" style="width:84px" type="text" value="20"/></div><div class="row cueButtonsRow" style="margin-top:8px;gap:8px;align-items:center">
<select class="btnSel" disabled="" id="selBcLabel" style="flex:1;min-width:220px">
<option disabled="" selected="" value="">BC$キューを選択…</option>
<optgroup label="基本">
<option value="BC$START">BC$START（マーク）</option>
<option value="BC$STANDBY">BC$STANDBY（待機）</option>
<option value="BC$CM">BC$CM（CMキュー）</option>
<option value="BC$END">BC$END（本編終了）</option>
<option value="BC$STOP">BC$STOP（停止）</option>
<option value="BC$FILE">BC$FILE（次STANDBYへ）</option>
<option value="BC$PAUSE">BC$PAUSE（一時停止）</option>
</optgroup>
<optgroup label="UTL（汎用）">
<option value="BC$UTL1">BC$UTL1</option>
<option value="BC$UTL2">BC$UTL2</option>
<option value="BC$UTL3">BC$UTL3</option>
<option value="BC$UTL4">BC$UTL4</option>
</optgroup>
<optgroup label="NOTE（添付用 / 先頭固定）">
<option value="BC$NOTE1">BC$NOTE1</option>
<option value="BC$NOTE2">BC$NOTE2</option>
<option value="BC$NOTE3">BC$NOTE3</option>
<option value="BC$NOTE4">BC$NOTE4</option>
<option value="BC$NOTE5">BC$NOTE5</option>
<option value="BC$NOTE6">BC$NOTE6</option>
<option value="BC$NOTE7">BC$NOTE7</option>
<option value="BC$NOTE8">BC$NOTE8</option>
<option value="BC$NOTE9">BC$NOTE9</option>
</optgroup>
</select>
<button class="btn" disabled="" id="btnAddBcLabel" style="padding:6px 10px;font-size:12px" type="button">＋ 追加</button>
</div><div style="margin-top:10px"><label>任意Label</label><div class="row" style="margin-top:6px"><input id="customLabel" placeholder="例) CLIENT / CM / NOTE ..." type="text"/><button class="btn" disabled="" id="btnAddCustom" type="button">＋ 追加</button></div></div></div><div class="cueTableWrap"><table><thead><tr><th style="width:42%">Label</th><th style="width:28%">TIME</th><th style="width:30%">操作</th></tr></thead><tbody id="cueBody"></tbody></table></div></div></aside></div><dialog data-dirty-guard="1" id="chunkDialog"><div class="modalHead"><div class="title"></div></div><div class="modalBody chunkModalBody"><div class="chunkTabs"><div aria-label="bext / cmcd / ログ 切り替え" class="tabBar" role="tablist"><button aria-selected="true" class="tabBtn active" data-tab="bext" role="tab" type="button">bext</button><button aria-selected="false" class="tabBtn" data-tab="cmcd" role="tab" type="button">cmcd</button><button aria-selected="false" class="tabBtn" data-tab="log" role="tab" type="button">ログ</button><button aria-selected="false" class="tabBtn" data-tab="diff" role="tab" type="button">差分</button></div><div class="tabPanels"><!-- bext --><div aria-label="bext panel" class="tabPanel active" data-tabpanel="bext" role="tabpanel"><div class="chunkSectionTitle"><b>bext</b><span class="chunkMeta" id="bextMeta">—</span></div><div class="kvGrid" id="bextViewGrid"></div><div class="fieldBlock" style="margin-top:12px"><label>CodingHistory（任意）</label><textarea id="bextArea" placeholder="例) A=PCM,F=48000,W=16,M=stereo,T=...
（複数行可 / CRLF推奨）"></textarea></div></div><!-- cmcd --><div aria-label="cmcd panel" class="tabPanel" data-tabpanel="cmcd" role="tabpanel"><div class="chunkSectionTitle"><b>cmcd</b><span class="chunkMeta" id="cmcdMeta">—</span></div><div class="cmcdGridWrap"><div class="kvGrid" id="cmcdViewGrid"></div></div><details class="advBox" style="margin-top:12px"><summary>cmcd（読み取り専用）</summary><div class="fieldBlock" style="margin-top:10px"><label>cmcdテキスト</label><textarea id="cmcdRawArea" placeholder="読み込むとここに表示されます（自動）" readonly=""></textarea></div></details><div style="margin-top:10px"></div></div><!-- log --><div aria-label="log panel" class="tabPanel" data-tabpanel="log" role="tabpanel"><div class="chunkSectionTitle"><b>ログ</b><span class="chunkMeta">（読み取り専用）</span></div><div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap"><button class="btn" id="btnLogExport" type="button">ログを書き出し</button><button class="btn" id="btnLogCopy" type="button">ログをコピー</button></div><div class="chunkPresence" id="chunkPresenceBox" style="margin-top:10px;padding:10px 12px;border:1px solid #2a2f37;border-radius:12px;background:rgba(255,255,255,0.02)"><div class="rowBetween" style="align-items:flex-start;gap:10px"><div style="font-weight:700">保持情報（参照）</div><div class="muted" style="font-size:12px">編集不可</div></div><div class="kvGrid" id="chunkPresenceGrid" style="margin-top:10px"></div></div><div class="logBox logBoxSmall logBoxTall" id="logBox2"></div></div>
<!-- diff -->
<div aria-label="diff panel" class="tabPanel" data-tabpanel="diff" role="tabpanel">
  <div class="chunkSectionTitle"><b>差分</b><span class="chunkMeta">（変更前 / 変更後）</span></div>
  <div class="diffBox" id="diffBox">—</div>
  <div class="muted" style="font-size:12px;margin-top:10px;line-height:1.45">
    ※ ここは「保存前の変更サマリ」です。書き出し時にはレポート(.txt)も生成できます。
  </div>
</div>
</div></div></div></div></dialog><dialog class="dlg" data-dirty-guard="1" id="cmcdDialog">
  <div class="dlgBox cmcdBox">
    <div class="dlgHead" style="display:flex;align-items:flex-start;gap:14px;justify-content:space-between">
      <div>
        <div class="dlgTitle">cmcd入力</div>
              </div>
      <div class="scTopRow" style="margin-left:auto;gap:10px;align-items:center">
        <span class="muted scPresetLbl" style="font-size:12px">プリセット</span>
        <select aria-label="cmcdプリセット" class="btnSel" id="cmcd_preset"></select>
      </div>
    </div>

    <div style="display:flex;align-items:center;gap:10px;margin:10px 0 8px">
      <div class="tabBar" role="tablist" aria-label="cmcd タブ">
        <button class="tabBtn active" type="button" role="tab" aria-selected="true" data-tab="cmcdIn">入力</button>
        <button class="tabBtn" type="button" role="tab" aria-selected="false" data-tab="cmcdPreset">プリセット</button>
      </div>
    </div>

    <div class="tabPanels" style="min-height:0">
      <div class="tabPanel active" role="tabpanel" data-tabpanel="cmcdIn">
        <div class="cmcdGrid"></div>
        <div class="cmcdActions">
          <button class="btn" id="btnCmcdClear" type="button">クリア</button>
          <button class="btn good" id="btnCmcdApply" type="button">反映</button>
        </div>
      </div>

      <div class="tabPanel" role="tabpanel" data-tabpanel="cmcdPreset">
        <div id="cmcdPresetMgr" style="padding:2px 2px 0">
          <div class="scPresetGrid" style="display:grid;grid-template-columns:160px 1fr;gap:8px 10px;margin-top:10px">
            <div class="muted">プリセット</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
              <select aria-label="既存cmcdプリセットを選択して編集" class="scPmPickSel" id="cmcd_pm_pick" style="min-width:280px;max-width:100%">
                <option value="" selected disabled hidden>プリセットを選択して編集</option>
                <option value="__new__" hidden>新規作成</option>
              </select>
              <button class="btn" id="cmcd_pm_new" style="border-radius:999px;padding:8px 12px" type="button">新規作成</button>
              <button class="btn" id="cmcd_pm_sortBtn" style="border-radius:999px;padding:8px 12px" type="button">並び替え</button>
              <button class="btn" id="cmcd_pm_delete" style="border-radius:999px;padding:8px 12px" type="button">削除</button>
            </div>

            <div id="cmcd_pm_sortPanel" style="display:none;grid-column:1/-1;margin-top:6px;padding:10px;border:1px dashed var(--line);border-radius:14px;background:transparent">
              <div class="muted" style="font-size:12px;margin-bottom:8px">ドラッグで並び替えできます。</div>
              <div class="scSortList" id="cmcd_pm_sortList"></div>
            </div>

            <div class="muted">名前</div>
            <div><input class="txt" id="cmcd_pm_name" placeholder="例: 放送基準A" style="width:min(520px,100%)" type="text"/></div>

            <div class="muted">内容</div>
            <div class="cmcdPmContent">
              <div class="cmcdGrid" id="cmcd_pm_grid"></div>
              <div class="cmcdPmActions" style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-top:10px">
                <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
                  <button class="btn" id="cmcd_pm_clone" style="border-radius:999px;padding:8px 12px" type="button">複製</button>
                  <button class="btn" id="cmcd_pm_import" style="border-radius:999px;padding:8px 12px" type="button">インポート</button>
                  <button class="btn" id="cmcd_pm_export" style="border-radius:999px;padding:8px 12px" type="button">エクスポート</button>
                </div>
                <div style="display:flex;gap:10px;align-items:center">
                  <button class="btn good" id="cmcd_pm_save" style="border-radius:999px;padding:8px 12px" type="button">保存</button>
                </div>
              </div>
              </div>
          </div>
        </div>
      </div>
    </div>

  </div>
</dialog><!-- ===== PDF ATTACH ===== --><dialog class="dlg" id="pdfAttachDialog"><div class="dlgHead"><div class="dlgTitle">ファイル添付</div></div><div class="dlgSub"><span class="attachDescSmall">
      CSV / PDF / XML / TEXT をWAVへ添付します。既に添付があるWAVを読み込んだ場合もここで確認できます。
    </span>
    </div><div class=\"pdfZone\" id="pdfAttachDrop"><div class="attachHintBox"><div class="pdfZoneTitle">ここにファイルをドラッグ＆ドロップ</div><div class="pdfZoneSub">または <button class="btn" id="btnPdfAttachPick" type="button">ファイルを選択</button><input accept=".pdf,.csv,.xml,.txt,.text,application/pdf,text/csv,application/csv,application/xml,text/xml,text/plain" id="pdfAttachInput" style="display:none" type="file"/></div><div class="pdfZoneHint">最大9件 / ドラッグで順序を変更できます</div></div></div><div class="attachListWrap"><div class="attachListHead"><div>添付一覧</div><div class="attachCount" id="attachCount">0/9</div></div><div class="attachList" id="attachList" role="listbox" aria-label="添付一覧"></div><div class="attachOrderHint">上から順に <b>#1〜#9</b> として扱われます（並び替えで番号が変わります）</div></div><div class="pdfActions"><button class="btn" id="btnPdfAttachView">確認（ビューア）</button><button class="btn" disabled="" id="btnPdfAttachDownload">ダウンロード</button><button class="btn" id="btnPdfAttachClear">解除</button></div><div class="pdfGrid" style="grid-template-columns: 1fr;"><label class="pdfRow"><span class="pdfKey">添付ファイル名</span><input class="pdfVal" id="pdfAttachName" placeholder="未添付" readonly=""/></label><label class="pdfRow"><span class="pdfKey">状態</span><input class="pdfVal" id="pdfAttachStatus" placeholder="未添付" readonly=""/></label></div></dialog><dialog class="dlg" id="pdfViewDialog" style="max-width:min(1100px, 96vw); width:min(1100px, 96vw);"><div class="dlgHead"><div class="dlgTitle">添付ファイルビューア</div></div><div class="pdfViewerWrap"><iframe class="pdfViewerFrame" id="pdfViewerFrame" title="PDF Viewer"></iframe><textarea class="fileTextPreview" id="fileTextPreview" readonly="" spellcheck="false"></textarea></div></dialog><!-- ===== /PDF ATTACH ===== -->
<!-- ===== Export Check (pre-export modal) ===== -->
<dialog class="exportCheckDialog" id="exportCheckDialog">
<div class="modalHead ecModalHead">
<div class="title ecTitle">
<b>書き出し前チェック</b>
<span class="muted" id="ec_range">—</span>
</div>
<div class="row" style="gap:10px;align-items:center;justify-content:flex-end">
  <button class="btn good" id="exportCheckRun" style="padding:8px 12px;border-radius:999px" type="button">書き出し</button>
</div>
</div>
<div class="modalBody">
<div aria-label="書き出し前チェック結果" class="ecTable" id="ec_table">
<div class="ecColHead">項目</div><div class="ecColHead">結果</div>
<div class="ecKey">Integrated LUFS</div><div class="ecVal" id="ec_lufs">—</div>
<div class="ecKey">TruePeak</div><div class="ecVal" id="ec_tp">—</div>
<div class="ecKey">サンプルレート</div><div class="ecVal" id="ec_sr">—</div>
<div class="ecKey">bit深度</div><div class="ecVal" id="ec_bd">—</div>
<div class="ecKey">チャンネル</div><div class="ecVal" id="ec_ch">—</div>
<div class="ecKey">本編秒数</div><div class="ecVal" id="ec_len">—</div>
<div class="ecKey">クリッピング</div><div class="ecVal" id="ec_clip">—</div>
<div class="ecKey">無音</div><div class="ecVal" id="ec_silence">—</div>
<div class="ecKey">ファイル</div><div class="ecVal" id="ec_file">—</div>
<div class="ecKey" id="ec_k_cuecount">CUE数</div><div class="ecVal" id="ec_cuecount">—</div>
<div class="ecKey" id="ec_k_noteuniq">NOTEラベル</div><div class="ecVal" id="ec_noteuniq">—</div>
<div class="ecKey" id="ec_k_plst">plst</div><div class="ecVal" id="ec_plst">—</div>
<div class="ecKey" id="ec_k_lblenc">ラベル文字</div><div class="ecVal" id="ec_lblenc">—</div>
</div>
<div class="fieldBlock" style="margin-top:14px">
<label style="display:flex;align-items:center;justify-content:space-between;gap:8px">
<span>CUE（TIME / 種別）</span>
<span class="muted" style="font-size:12px">（一覧）</span>
</label>
<div class="ecCueList" id="ec_cues">—</div>
</div>
<details class="advBox" style="margin-top:14px">
<summary>変更サマリ（変更前 / 変更後）</summary>
<div class="ecDiffBox" id="ec_diffBox">—</div>

</details>

</div>
</dialog>
<dialog id="exportQcNgDialog" class="modal">
  <div class="modalHead">
    <div class="title"><b>規格チェックの確認</b></div>
  </div>
  <div class="modalBody">
    <h3 style="margin:0 0 8px 0">規格チェックでNGがあります</h3>
    <div style="opacity:.9;font-size:13px;line-height:1.5">
      NG項目があります。このまま書き出しを続行しますか？
    </div>
    <div id="exportQcNgList" style="margin-top:10px;display:grid;gap:6px"></div>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">
      <button type="button" class="btn" id="exportQcNgCancelBtn">キャンセル</button>
      <button type="button" class="btn primary" id="exportQcNgProceedBtn">このまま書き出す</button>
    </div>
  </div>
</dialog>
<dialog id="bulkExportNgDialog" class="modal bulkNgDialog">
  <div class="modalHead">
    <div class="title"><b>一括書き出しの警告</b></div>
  </div>
  <div class="modalBody">
    <div class="bulkNgDesc">規格NGが含まれます。修正を推奨しますが、このまま続行できます。</div>
    <div id="bulkExportNgList" class="bulkNgList"></div>
    <div class="bulkNgActions">
      <button type="button" class="btn" id="bulkExportNgCancel">キャンセル</button>
      <button type="button" class="btn primary" id="bulkExportNgProceed">このまま続行</button>
    </div>
  </div>
</dialog>
<!-- ===== Standard Check (separate modal) ===== -->
<dialog class="exportCheckDialog stdCheckDialog" data-dirty-guard="1" id="stdCheckDialog">
<div class="modalHead ecModalHead">
<div class="title ecTitle">
<b>規格チェック</b>
<span class="muted" id="sc_scope">全体</span>
</div>
<div class="scTopRow">
<span class="muted scPresetLbl" style="font-size:12px">プリセット</span>
<select aria-label="局別プリセット（編集・保存可）" class="btnSel" data-no-dirty="1" id="sc_preset"></select>
<button class="btn" id="sc_run" style="padding:8px 12px;border-radius:999px" type="button">チェック</button>
</div>
</div>
<div class="modalBody">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
<div aria-label="規格チェック タブ" class="tabBar" role="tablist">
<button aria-controls="sc_resultsPane" aria-selected="true" class="tabBtn active" id="sc_tab_results" role="tab" type="button">チェック</button>
<button aria-controls="sc_presetMgr" aria-selected="false" class="tabBtn" id="sc_tab_preset" role="tab" type="button">プリセット編集</button>
</div>
</div>
<div class="scPresetMgr" id="sc_presetMgr" style="display:none;padding:12px;border:1px solid var(--line);border-radius:16px;background:transparent">
<div class="scPmHeadRow" style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
<div style="display:flex;align-items:baseline;gap:10px;flex-wrap:wrap">
</div>
</div>
<input id="sc_pm_id" type="hidden"/>
<input id="sc_pm_desc" type="hidden"/>
<div class="scPresetGrid" style="display:grid;grid-template-columns:160px 1fr;gap:8px 10px;margin-top:10px">
<div class="muted">プリセット</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
<select aria-label="既存プリセットを選択して編集" class="scPmPickSel" id="sc_pm_pick" style="min-width:280px;max-width:100%">
<option disabled="" hidden="" selected="" value="">プリセットを選択して編集</option>
<option hidden="" value="__new__">新規作成</option>
</select>
<button class="btn" id="sc_pm_new" style="border-radius:999px;padding:8px 12px" type="button">新規作成</button>
<button class="btn" id="sc_pm_sort" style="border-radius:999px;padding:8px 12px" type="button">並び替え</button>
<button class="btn warn" id="sc_pm_delete" style="border-radius:999px;padding:8px 12px" type="button">削除</button>
</div>
<div id="sc_pm_sortPanel" style="display:none;grid-column:1/-1;margin-top:8px;padding:10px;border:1px dashed var(--line);border-radius:14px;background:transparent">
<div class="muted" style="font-size:12px;margin-bottom:8px">ドラッグで並び替えできます。</div>
<div class="scSortList" id="sc_pm_sortList"></div>
</div>
<div class="muted">名前</div>
<div><input class="txt" id="sc_pm_name" placeholder="例: 放送基準A" style="width:100%" type="text"/></div>
<div class="muted">ラウドネス値</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
<div style="display:flex;gap:6px;align-items:center">
<input class="txt mono" id="sc_pm_target" step="0.1" style="width:140px" type="number"/>
<span class="muted" style="font-size:12px">LUFS</span>
</div>
<div style="display:flex;gap:6px;align-items:center">
<span class="muted">許容範囲 ±</span>
<input class="txt mono" id="sc_pm_tol" step="0.1" style="width:120px" type="number"/>
<span class="muted" style="font-size:12px">LU</span>
</div>
</div>
<div class="muted">TruePeak 上限</div>
<div style="display:flex;gap:6px;align-items:center">
<input class="txt mono" id="sc_pm_tpmax" step="0.1" style="width:180px" type="number"/>
<span class="muted" style="font-size:12px">dBTP</span>
</div>
<div class="muted">サンプルレート</div>
<div>
<select class="btnSel" id="sc_pm_srsel" style="width:240px">
<option value="">制限なし</option>
<option value="44100">44100</option>
<option value="48000">48000</option>
<option value="96000">96000</option>
</select>
</div>
<div class="muted">bit深度</div>
<div>
<select class="btnSel" id="sc_pm_bitssel" style="width:240px">
<option value="">制限なし</option>
<option value="16">16</option>
<option value="24">24</option>
<option value="32">32</option>
</select>
</div>
<div class="muted">チャンネル</div>
<div>
<select class="btnSel" id="sc_pm_chsel" style="width:240px">
<option value="">制限なし</option>
<option value="2">ステレオ</option>
<option value="1">モノラル</option>
</select>
</div>
<div class="muted">無音許容範囲</div>
<div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
<input class="txt mono" id="sc_pm_silmin" step="0.01" style="width:100px" type="number" value="0.00"/>
<span class="muted" style="font-size:12px">〜</span>
<input class="txt mono" id="sc_pm_silmax" step="0.01" style="width:100px" type="number" value="0.50"/>
<span class="muted" style="font-size:12px">秒（前/後それぞれ）</span>
</div>
</div>
<div class="scPresetMgrBtns" style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
<button class="btn" id="sc_pm_clone" style="border-radius:999px;padding:8px 12px" type="button">複製</button>
<button class="btn" id="sc_pm_import" style="border-radius:999px;padding:8px 12px" type="button">インポート</button>
<button class="btn" id="sc_pm_export" style="border-radius:999px;padding:8px 12px" type="button">エクスポート</button>
<button class="btn good" id="sc_pm_save" style="border-radius:999px;padding:8px 12px" type="button">保存</button>
</div>
<div class="muted" id="sc_pm_hint" style="margin-top:8px;font-size:12px">—</div>
</div>
<div id="sc_resultsPane">
<div aria-label="規格チェック結果" class="ecTable" id="sc_table">
<div class="ecColHead">項目</div><div class="ecColHead">目標</div><div class="ecColHead">結果</div>
<div class="ecKey">Integrated LUFS</div><div class="ecTarget" id="sc_lufs_t">—</div><div class="ecVal" id="sc_lufs">—</div>
<div class="ecKey">TruePeak</div><div class="ecTarget" id="sc_tp_t">—</div><div class="ecVal" id="sc_tp">—</div>
<div class="ecKey">サンプルレート</div><div class="ecTarget" id="sc_sr_t">—</div><div class="ecVal" id="sc_sr">—</div>
<div class="ecKey">bit深度</div><div class="ecTarget" id="sc_bd_t">—</div><div class="ecVal" id="sc_bd">—</div>
<div class="ecKey">チャンネル</div><div class="ecTarget" id="sc_ch_t">—</div><div class="ecVal" id="sc_ch">—</div>
<div class="ecKey">クリッピング</div><div class="ecTarget" id="sc_clip_t">—</div><div class="ecVal" id="sc_clip">—</div>
<div class="ecKey">無音</div><div class="ecTarget" id="sc_silence_t">—</div><div class="ecVal" id="sc_silence">—</div>
</div>
<div class="scFixBox">
<div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
<b>ラウドネスノーマライズ</b>
<span class="muted" id="sc_fixState">未適用</span>
</div>
<div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px">
<button class="btn" id="sc_fix" type="button">補正を実行</button> <span class="muted" id="sc_fixInfo">—</span>
</div>
<div class="muted" style="margin-top:8px">
        補正を適用した状態で書き出します。<br/>元に戻す：Ctrl/⌘+Z
      </div>
</div>
</div>
</div>
</dialog>
<!-- ===== /Standard Check ===== -->
<dialog id="ngDetailDialog" class="modal">
  <div class="modalHead">
    <div class="title">
      <b>NG詳細</b>
      <span class="muted" id="ngDetailFile">—</span>
    </div>
  </div>
  <div class="modalBody">
    <div class="ngDetailList" id="ngDetailList"></div>
  </div>
</dialog>
<dialog class="settingsDialog" id="settingsDialog">
  <div aria-atomic="true" aria-live="polite" class="toastHost" data-toast-host="settings"></div>
  <div class="modalHead">
    <div class="title">
      <b>設定</b>
      <span class="muted">バックアップ管理</span>
    </div>
  </div>
  <div class="modalBody">
    <div class="settingsGrid">
      <section class="settingsCard" style="grid-column:1/-1">
        <h3>バックアップ管理</h3>
        <div class="muted" id="settingsBackupDemoNote" style="display:none;margin-top:-4px;margin-bottom:8px;">Demoではバックアップ機能は利用できません。</div>
        <div class="settingsBlock">
          <div class="settingsBlockTitle">状態・操作</div>
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <button class="btn" data-settings-folder="backups" type="button">バックアップを開く</button>
            <button class="btn danger" id="settingsCleanupNow" type="button">今すぐ完全クリーンアップ</button>
            <button class="btn" id="settingsResetRecommended" type="button">設定を初期化（推奨に戻す）</button>
          </div>
          <div class="muted" id="settingsBackupStatus">バックアップ状況: —</div>
          <div class="muted" id="settingsCleanupResult"></div>
          <div class="muted" id="settingsCleanupProgress"></div>
        </div>
        <div class="settingsBlock">
          <div class="settingsBlockTitle">自動クリーンアップ</div>
          <div class="switchWrap">
            <label class="switch">
              <input id="settingsAutoCleanup" type="checkbox"/>
              <span class="slider"></span>
            </label>
            <div class="switchText">
              <span class="switchLabel"><strong>自動クリーンアップ（古いバックアップを削除）</strong></span>
              <span class="muted">書き出し完了後に実行します</span>
            </div>
          </div>
        </div>
        <div class="settingsBlock">
          <div class="settingsBlockTitleRow">
            <div class="settingsBlockTitle">保存ルール</div>
            <span class="settingsBadge" id="settingsRulesBadge">推奨</span>
          </div>
          <div class="rulesCard">
            <div class="rulesGrid">
              <label class="settingsField">
                <span class="muted">保存期間</span>
                <select id="settingsRetentionDays">
                  <option value="7">7日</option>
                  <option value="14">14日</option>
                  <option value="30">30日（推奨）</option>
                  <option value="90">90日</option>
                  <option value="36500">無制限（注意）</option>
                </select>
                <span class="fieldNote">無制限は容量が増え続けます</span>
              </label>
              <label class="settingsField">
                <span class="muted">使用容量上限</span>
                <select id="settingsBackupQuotaGB">
                  <option value="5">5GB（推奨）</option>
                  <option value="10">10GB</option>
                  <option value="25">25GB</option>
                  <option value="50">50GB</option>
                  <option value="9999">制限なし（注意）</option>
                </select>
                <span class="fieldNote is-empty">　</span>
              </label>
              <label class="settingsField">
                <span class="muted">最低保持数</span>
                <select id="settingsMinKeepCount">
                  <option value="5">5件</option>
                  <option value="10">10件</option>
                  <option value="20">20件（推奨）</option>
                  <option value="50">50件</option>
                </select>
                <span class="fieldNote is-empty">　</span>
              </label>
              <label class="settingsField">
                <span class="muted">削除方法</span>
                <select id="settingsDeleteMethod">
                  <option value="trash">ゴミ箱へ移動（推奨）</option>
                  <option value="delete">完全に削除（注意）</option>
                </select>
                <span class="fieldNote">完全削除は元に戻せません</span>
              </label>
            </div>
          </div>
          <div class="rulesNote">保存期間と容量上限のどちらかに到達すると、古いものから削除されます（最低保持数は残します）</div>
        </div>
        <button class="btn" id="settingsSave" type="button">設定を保存</button>
        <div class="settingsHint" id="settingsToastDebug">debug line: —</div>
      </section>
      <section class="settingsCard" style="grid-column:1/-1">
        <h3>ログ</h3>
        <div class="settingsLog" id="settingsLog">準備完了</div>
      </section>
    </div>
  </div>
</dialog>
<dialog class="confirmDialog" id="settingsCleanupConfirm">
  <div class="modalHead">
    <div class="title">
      <b>完全クリーンアップを実行しますか？</b>
    </div>
  </div>
  <div class="modalBody">
    <div class="confirmBody">
      <ul class="confirmList">
        <li>保存ルールを無視してバックアップを削除します</li>
        <li>最低保持数は適用されません</li>
        <li>この操作は元に戻せません</li>
      </ul>
      <div class="confirmActions">
        <button class="btn" id="settingsCleanupConfirmCancel" type="button">キャンセル</button>
        <button class="btn danger" id="settingsCleanupConfirmRun" type="button">完全クリーンアップを実行</button>
      </div>
    </div>
  </div>
</dialog>
<!-- ===== /Export Check ===== -->
<script>
(function(){
  "use strict";

  if (typeof window.infoLog !== "function") window.infoLog = function(){};
  if (typeof window.infoLogThrottled !== "function") window.infoLogThrottled = function(){};

  const __origLog = console.log.bind(console);
  const __origInfo = (console.info ? console.info.bind(console) : __origLog);
  const SUPPRESSED_TAGS = new Set(["UI", "DND", "PRO", "SETTINGS", "CUE", "IMPORT", "EXPORT"]);

  const readEnabledSet = () => {
    try {
      const raw = window.localStorage ? window.localStorage.getItem("wavcue_log") : "";
      const value = (raw || "").trim();
      if (!value || value === "0") return new Set();
      if (value === "*") return new Set(["*"]);
      return new Set(
        value
          .split(",")
          .map((entry) => entry.trim())
          .filter(Boolean)
          .map((entry) => entry.toUpperCase())
      );
    } catch (err) {
      __origLog("Log gate localStorage error:", err);
      return new Set();
    }
  };

  const extractTag = (args) => {
    if (!args || args.length === 0) return null;
    const text = String(args[0]);
    if (!text.startsWith("[")) return null;
    const match = text.match(/^\[([A-Za-z0-9_-]+)\]/);
    if (!match) return null;
    return match[1].toUpperCase();
  };

  const shouldLog = (tag, enabledSet) => {
    if (enabledSet.has("*")) return true;
    if (tag && enabledSet.has(tag)) return true;
    if (!tag) return true;
    return !SUPPRESSED_TAGS.has(tag);
  };

  console.log = (...args) => {
    try {
      const enabledSet = readEnabledSet();
      const tag = extractTag(args);
      if (shouldLog(tag, enabledSet)) {
        return __origLog(...args);
      }
    } catch (err) {
      __origLog("Log gate error:", err);
      return __origLog(...args);
    }
  };

  console.info = (...args) => {
    try {
      const enabledSet = readEnabledSet();
      const tag = extractTag(args);
      if (shouldLog(tag, enabledSet)) {
        return __origInfo(...args);
      }
    } catch (err) {
      __origLog("Log gate error:", err);
      return __origInfo(...args);
    }
  };
})();

/* ===============================
   License Core (single safe API)
================================ */
const LicenseCore = (()=> {
  const listeners = new Set();
  const tierRank = { demo: 0, standard: 1, pro: 2 };
  const LICENSE_TEXT = Object.freeze({
    exportStandardRequired: "書き出しはStandard以上で利用できます。",
    exportAuthExpired: "認証が確認できないため書き出しのみ停止しています。",
    bulkImportPro: "一括読み込みはProで利用できます。",
    bulkCheckPro: "一括チェックはProで利用できます。",
    bulkExportPro: "一括書き出しはProで利用できます。",
    historyPro: "履歴はProで利用できます。",
    presetDemo: "プリセットはStandard以上で利用できます。",
    backupDemo: "Demoではバックアップ機能は利用できません。",
    demoNotice: "体験版です。1週間・書き出し20回までお試しできます。",
    demoExpiredBanner: "体験版の利用期間が終了しました。ライセンスをご購入ください",
    demoExportLimitBanner: "体験版の書き出し回数制限に達しました。ライセンスをご購入ください",
    demoExpiredToast: "体験版の利用期間が終了しました。ライセンスをご購入ください",
    demoExportLimitToast: "体験版の書き出し回数制限に達しました。ライセンスをご購入ください",
    standardAuthToast: "Standard認証が切れました。書き出しのみ停止します。",
    standardGraceModal: "Standard認証が切れました。1時間後に書き出しのみ停止します。\nネット接続を確認して再認証してください。",
    standardGraceBanner: "認証が切れています（猶予中）。ネット接続を確認して再認証してください。",
    standardAuthBanner: "認証が切れています（書き出しのみ停止）。ネット接続を確認して再認証してください。",
  });
  const policy = {
    bulkImport: { minTier: "pro", reason: "pro-only" },
    bulkCheck: { minTier: "pro", reason: "pro-only" },
    bulkExport: { minTier: "pro", reason: "pro-only" },
    history: { minTier: "pro", reason: "pro-only" },
    exportSingle: { minTier: "demo", reason: "standard-required" },
    preset: { minTier: "standard", reason: "standard-required" },
    backup: { minTier: "standard", reason: "standard-required" },
  };
  const stateCache = {
    tier: "demo",
    source: "fallback",
    updatedAt: Date.now(),
  };
  let _lastStdHardExpired = null;
  const DEMO_TRIAL_MS = 7 * 24 * 60 * 60 * 1000;
  const DEMO_EXPORT_MAX = 20;
  const STANDARD_AUTH_FRESH_MS = 60 * 60 * 1000;
  const STANDARD_AUTH_GRACE_MS = 60 * 60 * 1000;
  const LS_STATE_KEYS = [
    "wavcue_license_state",
    "wavcue_license",
    "wavcue_license_v1",
    "wavcue_license_info",
  ];
  const LS_KEY_LAST = "wavcue_license_key";
  const LS_DEMO_ACTIVATED_AT = "wavcue_demo_activated_at";
  const LS_DEMO_EXPORT_OK_COUNT = "wavcue_demo_export_ok_count";
  const LS_STANDARD_LAST_ONLINE_OK_AT = "wavcue_standard_last_online_ok_at";
  const LS_STANDARD_GRACE_STARTED_AT = "wavcue_std_grace_started_at";
  const LS_STANDARD_GRACE_EXPIRES_AT = "wavcue_std_grace_expires_at";
  const LS_STANDARD_GRACE_MODAL_SHOWN_FOR_STARTED_AT = "wavcue_std_grace_modal_shown_for_started_at";

  const readNumber = (key)=>{
    try{
      const raw = localStorage?.getItem?.(key);
      if(raw == null) return null;
      const num = Number(raw);
      return Number.isFinite(num) ? num : null;
    }catch(_){ return null; }
  };
  const writeNumber = (key, value)=>{
    try{
      if(!localStorage?.setItem) return;
      if(value == null) localStorage.removeItem(key);
      else localStorage.setItem(key, String(Math.trunc(value)));
    }catch(_){}
  };
  const readDemoActivatedAt = ()=> readNumber(LS_DEMO_ACTIVATED_AT);
  const ensureDemoActivatedAt = (now)=>{
    const existing = readDemoActivatedAt();
    if(existing) return existing;
    const stamp = Number.isFinite(now) ? now : Date.now();
    writeNumber(LS_DEMO_ACTIVATED_AT, stamp);
    return stamp;
  };
  const readDemoExportOkCount = ()=> readNumber(LS_DEMO_EXPORT_OK_COUNT) || 0;
  const setDemoExportOkCount = (count)=>{
    const safe = Math.max(0, Math.trunc(count || 0));
    writeNumber(LS_DEMO_EXPORT_OK_COUNT, safe);
    return safe;
  };
  const bumpDemoExportOkCount = ()=>{
    const next = setDemoExportOkCount(readDemoExportOkCount() + 1);
    return next;
  };
  const readStandardLastOnlineOkAt = ()=> readNumber(LS_STANDARD_LAST_ONLINE_OK_AT);
  const touchStandardLastOnlineOkAt = (now)=>{
    const stamp = Number.isFinite(now) ? now : Date.now();
    writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
    return stamp;
  };
  const readStandardGraceStartedAt = ()=> readNumber(LS_STANDARD_GRACE_STARTED_AT);
  const readStandardGraceExpiresAt = ()=> readNumber(LS_STANDARD_GRACE_EXPIRES_AT);
  const readStandardGraceModalShownFor = ()=> readNumber(LS_STANDARD_GRACE_MODAL_SHOWN_FOR_STARTED_AT);
  const writeStandardGraceState = (startedAt, expiresAt)=>{
    writeNumber(LS_STANDARD_GRACE_STARTED_AT, startedAt);
    writeNumber(LS_STANDARD_GRACE_EXPIRES_AT, expiresAt);
  };
  const clearStandardGraceState = ()=>{
    writeNumber(LS_STANDARD_GRACE_STARTED_AT, null);
    writeNumber(LS_STANDARD_GRACE_EXPIRES_AT, null);
    writeNumber(LS_STANDARD_GRACE_MODAL_SHOWN_FOR_STARTED_AT, null);
  };
  const markStandardGraceModalShownFor = (startedAt)=>{
    writeNumber(LS_STANDARD_GRACE_MODAL_SHOWN_FOR_STARTED_AT, startedAt);
  };
  const getDemoInfo = (now, ensureActivation)=>{
    const stamp = Number.isFinite(now) ? now : Date.now();
    const activatedAt = ensureActivation ? ensureDemoActivatedAt(stamp) : readDemoActivatedAt();
    const exportOkCount = readDemoExportOkCount();
    const expiresAt = activatedAt ? (activatedAt + DEMO_TRIAL_MS) : null;
    const remainingMs = expiresAt ? Math.max(0, expiresAt - stamp) : DEMO_TRIAL_MS;
    const remainingDays = Math.max(0, Math.ceil(remainingMs / (24 * 60 * 60 * 1000)));
    const remainingExports = Math.max(0, DEMO_EXPORT_MAX - exportOkCount);
    const isExpired = !!(expiresAt && stamp > expiresAt);
    const isExportLimit = remainingExports <= 0;
    const isLocked = isExpired || isExportLimit;
    const demoBlockedReason = isExpired
      ? "demo_expired"
      : (isExportLimit ? "demo_export_limit" : null);
    return {
      activatedAt,
      expiresAt,
      remainingDays,
      exportOkCount,
      remainingExports,
      isExpired,
      isExportLimit,
      isLocked,
      demoBlockedReason,
    };
  };
  const getStandardInfo = (now)=>{
    const stamp = Number.isFinite(now) ? now : Date.now();
    const lastOnlineOkAt = readStandardLastOnlineOkAt();
    const elapsed = lastOnlineOkAt ? Math.max(0, stamp - lastOnlineOkAt) : STANDARD_AUTH_FRESH_MS + 1;
    const remainingMs = Math.max(0, STANDARD_AUTH_FRESH_MS - elapsed);
    const remainingMinutes = Math.max(0, Math.ceil(remainingMs / (60 * 1000)));
    const expiresAt = lastOnlineOkAt ? (lastOnlineOkAt + STANDARD_AUTH_FRESH_MS) : null;
    const isValidNow = remainingMs > 0;
    return {
      auth: {
        lastOkAt: lastOnlineOkAt,
        expiresAt,
        isValidNow,
        remainingMinutes,
      },
    };
  };

  const normalizeTier = (raw)=>{
    const t = String(raw || "").toLowerCase();
    if(!t) return null;
    if(t.includes("pro")) return "pro";
    if(t.includes("standard") || t.includes("std") || t.includes("wavcue_standard")) return "standard";
    if(t.includes("demo") || t.includes("trial") || t.includes("free")) return "demo";
    return null;
  };

  const normalizeKeyTier = (rawKey)=>{
    const t = String(rawKey || "").trim().toLowerCase();
    if(!t) return null;
    if(t === "wavcue_standard_test" || t === "wavcue_standard") return "standard";
    if(t.includes("standard") || t.includes("wavcue_standard")) return "standard";
    if(t.includes("pro")) return "pro";
    if(t.includes("demo")) return "demo";
    return null;
  };

  const decideTier = (keyTier, normalizedStateTier)=>{
    if(keyTier === "pro") return "pro";
    if(keyTier === "standard") return "standard";
    if(keyTier === "demo") return "demo";
    if(normalizedStateTier === "pro") return "pro";
    if(normalizedStateTier === "standard") return "standard";
    if(normalizedStateTier === "demo") return "demo";
    return "demo";
  };

  const normalizeState = (raw)=>{
    if(!raw) return null;
    if(typeof raw === "string"){
      const tier = normalizeTier(raw);
      return tier ? { tier } : null;
    }
    if(typeof raw === "object"){
      const tier =
        normalizeTier(raw.tier) ||
        normalizeTier(raw.plan) ||
        normalizeTier(raw.type) ||
        normalizeTier(raw.licenseTier) ||
        normalizeTier(raw.level) ||
        normalizeTier(raw.product) ||
        null;
      const inferred =
        tier ||
        (raw.isPro ? "pro" : null) ||
        (raw.isStandard ? "standard" : null) ||
        (raw.isDemo ? "demo" : null);
      return inferred ? { tier: inferred } : null;
    }
    return null;
  };

  const setCache = (next, source)=>{
    if(!next || !next.tier) return stateCache;
    stateCache.tier = next.tier;
    stateCache.source = source || stateCache.source;
    stateCache.updatedAt = Date.now();
    listeners.forEach((fn)=>{ try{ fn({ ...stateCache }); }catch(_){ } });
    return { ...stateCache };
  };

  const readLocalState = ()=>{
    try{
      if(!window.localStorage) return null;
      for(const key of LS_STATE_KEYS){
        const raw = localStorage.getItem(key);
        if(!raw) continue;
        try{
          const parsed = JSON.parse(raw);
          const norm = normalizeState(parsed);
          if(norm) return norm;
        }catch(_){
          const norm = normalizeState(raw);
          if(norm) return norm;
        }
      }
    }catch(_){}
    return null;
  };

  const readWindowSync = ()=>{
    try{
      const candidates = [
        window.__wavcueLicenseState,
        window.WavCue?.licenseState,
        window.WavCue?.license,
        window.wavcue?.licenseState,
        window.wavcue?.licenseInfo,
      ];
      for(const raw of candidates){
        const norm = normalizeState(raw);
        if(norm) return norm;
      }
    }catch(_){}
    return null;
  };

  const readWindowAsync = async ()=>{
    const fns = [
      window.wavcue?.getLicenseStateSafe,
      window.wavcue?.getLicenseState,
      window.wavcue?.getLicenseInfo,
    ].filter((fn)=> typeof fn === "function");
    for(const fn of fns){
      try{
        const res = await fn();
        const norm = normalizeState(res);
        if(norm) return norm;
      }catch(_){}
    }
    return null;
  };

  const init = ()=>{
    try{
      _refreshState("init", { touchOnline: true });
      void readWindowAsync().then((asyncState)=>{
        if(asyncState){
          setCache(asyncState, "windowAsync");
          _refreshState("async", { touchOnline: true });
        }
      }).catch((e)=>{
        console.error("[License] non-fatal", e);
      });
    }catch(e){
      console.error("[License] non-fatal", e);
    }
    return { ...stateCache };
  };

  const buildState = (base, options = {})=>{
    const now = Date.now();
    const tier = (base && base.tier) ? base.tier : "demo";
    if(options.touchOnline && tier === "standard"){
      touchStandardLastOnlineOkAt(now);
    }
    const demo = getDemoInfo(now, tier === "demo");
    const standard = getStandardInfo(now);
    const strictAuth = standard?.auth?.isValidNow !== false;
    let graceStartedAt = readStandardGraceStartedAt();
    let graceExpiresAt = readStandardGraceExpiresAt();
    if(tier === "standard"){
      if(strictAuth){
        if(graceStartedAt != null || graceExpiresAt != null || readStandardGraceModalShownFor() != null){
          clearStandardGraceState();
        }
        graceStartedAt = null;
        graceExpiresAt = null;
      }else{
        const hasGrace = Number.isFinite(graceStartedAt) && Number.isFinite(graceExpiresAt) && graceExpiresAt > graceStartedAt;
        if(!hasGrace){
          graceStartedAt = now;
          graceExpiresAt = now + STANDARD_AUTH_GRACE_MS;
          writeStandardGraceState(graceStartedAt, graceExpiresAt);
        }
      }
    }
    const graceEligible = tier === "standard";
    const isInGrace = graceEligible && !strictAuth && Number.isFinite(graceExpiresAt) && now < graceExpiresAt;
    const isHardExpired = graceEligible && !strictAuth && (!Number.isFinite(graceExpiresAt) || now >= graceExpiresAt);
    const graceRemainingMinutes = isInGrace
      ? Math.max(0, Math.ceil((graceExpiresAt - now) / (60 * 1000)))
      : 0;
    if(standard?.auth){
      standard.auth.isInGrace = !!isInGrace;
      standard.auth.isHardExpired = !!isHardExpired;
      standard.auth.graceStartedAt = graceEligible && Number.isFinite(graceStartedAt) ? graceStartedAt : null;
      standard.auth.graceExpiresAt = graceEligible && Number.isFinite(graceExpiresAt) ? graceExpiresAt : null;
      standard.auth.graceRemainingMinutes = graceRemainingMinutes;
    }
    if(tier === "standard"){
      standard.exportBlockedReason = isHardExpired ? "standard_auth_expired" : null;
    }else{
      standard.exportBlockedReason = null;
    }
    return { ...base, tier, demo, standard };
  };

  const getStateSafeInternal = (options = {})=>{
    try{
      const local = readLocalState();
      if(local) return buildState({ ...stateCache, ...local }, options);
      const sync = readWindowSync();
      if(sync) return buildState({ ...stateCache, ...sync }, options);
      return buildState({ ...stateCache }, options);
    }catch(e){
      console.error("[License] non-fatal", e);
      return buildState({ tier: "demo", source: "fallback", updatedAt: Date.now() }, options);
    }
  };

  let _lastRefreshSummary = "";
  const _refreshState = (reason, options = {})=>{
    const next = getStateSafeInternal({ touchOnline: options.touchOnline });
    stateCache.tier = next.tier;
    stateCache.source = reason || stateCache.source;
    stateCache.updatedAt = Date.now();
    const payload = { ...stateCache, demo: next.demo, standard: next.standard };
    listeners.forEach((fn)=>{ try{ fn(payload); }catch(_){ } });

    const demoBlocked = next.demo?.demoBlockedReason || "none";
    const stdStrict = next.standard?.auth?.isValidNow !== false;
    const stdInGrace = !!next.standard?.auth?.isInGrace;
    const stdHardExpired = !!next.standard?.auth?.isHardExpired;
    const stdBlocked = next.standard?.exportBlockedReason || "none";
    const summary = `${next.tier}|${demoBlocked}|${stdStrict}|${stdInGrace}|${stdHardExpired}|${stdBlocked}`;
    const isChange = summary !== _lastRefreshSummary;
    const shouldLog = (reason === "debug" || reason === "key")
      || (reason === "tick" && isChange);
    if(shouldLog){
      console.log(`[License] refresh reason=${reason || "unknown"} tier=${next.tier} strict=${stdStrict} grace=${stdInGrace} hard=${stdHardExpired} stdExportBlocked=${stdBlocked}`);
    }
    if(next.tier === "standard"){
      if(_lastStdHardExpired === false && stdHardExpired === true){
        if(typeof window.safeToast === "function"){
          window.safeToast(LICENSE_TEXT.standardAuthToast, "warn");
        }
      }
      _lastStdHardExpired = stdHardExpired;
      if(stdInGrace){
        const startedAt = next.standard?.auth?.graceStartedAt;
        const shownFor = readStandardGraceModalShownFor();
        if(Number.isFinite(startedAt) && shownFor !== startedAt){
          const dlg = document.getElementById("standardGraceDialog");
          if(dlg){
            if(!dlg.open){
              try{ dlg.showModal(); }catch(_){ dlg.open = true; }
            }
            markStandardGraceModalShownFor(startedAt);
          }
        }
      }
    }else{
      _lastStdHardExpired = null;
    }
    if(isChange) _lastRefreshSummary = summary;
    return payload;
  };

  const getStateSafe = ()=> _refreshState("get", { touchOnline: false });

  const isDemoLocked = (st)=> {
    const info = st?.demo || getDemoInfo(Date.now(), true);
    return !!info?.isLocked;
  };
  const isStandardAuthFresh = (st)=>{
    const info = st?.standard || getStandardInfo(Date.now());
    return !!info?.auth?.isValidNow;
  };

  const guard = (action, ctx)=>{
    try{
      const st = getStateSafeInternal({ touchOnline: false });
      const tier = (st && st.tier) ? st.tier : "demo";
      const rule = policy[action] || { minTier: "demo" };
      let ok = (tierRank[tier] ?? 0) >= (tierRank[rule.minTier] ?? 0);
      let reason = ok ? undefined : (rule.reason || "restricted");
      if(action === "exportSingle" && tier === "standard" && st?.standard?.auth?.isHardExpired){
        ok = false;
        reason = "standard-auth-expired";
      }
      if(action === "exportSingle" && tier === "demo" && isDemoLocked(st)){
        ok = false;
        reason = st?.demo?.demoBlockedReason || "demo_expired";
      }
      if(action === "preset" && tier === "demo"){
        ok = false;
        reason = "demo-locked";
      }
      if(action === "backup" && tier === "demo"){
        ok = false;
        reason = "demo-locked";
      }
      if(action === "history" && tier !== "pro"){
        ok = false;
        reason = "pro-only";
      }
      const res = { ok, tier, reason };
      const reasonTxt = reason ? ` reason=${reason}` : "";
      console.log(`[License] tier=${tier} action=${action} ok=${ok ? 1 : 0}${reasonTxt}`);
      return res;
    }catch(e){
      console.error("[License] non-fatal", e);
      return { ok: true, tier: "demo" };
    }
  };

  const setKeySafe = async (key)=>{
    try{
      const value = String(key || "").trim();
      if(!value) return { ok: false, reason: "empty" };
      const keyTier = normalizeKeyTier(value);
      try{ localStorage?.setItem?.(LS_KEY_LAST, value); }catch(_){}
      const fns = [
        window.wavcue?.setLicenseKey,
        window.wavcue?.activateLicense,
        window.wavcue?.setLicense,
      ].filter((fn)=> typeof fn === "function");
      if(!fns.length){
        if(keyTier) setCache({ tier: keyTier }, "activationKey");
        _refreshState("key", { touchOnline: true });
        return { ok: true };
      }
      const res = fns[0](value);
      let next = res;
      if(res && typeof res.then === "function"){
        try{
          next = await res;
        }catch(e){
          console.error("[License] non-fatal", e);
          return { ok: false, reason: "activation-failed" };
        }
      }
      const norm = normalizeState(next);
      const decidedTier = decideTier(keyTier, norm?.tier);
      setCache({ tier: decidedTier }, norm ? "activation" : "activationKey");
      if(decidedTier === "standard") touchStandardLastOnlineOkAt(Date.now());
      _refreshState("key", { touchOnline: true });
      return { ok: true };
    }catch(e){
      console.error("[License] non-fatal", e);
      return { ok: false, reason: "exception" };
    }
  };

  const onChange = (fn)=>{
    if(typeof fn !== "function") return ()=>{};
    listeners.add(fn);
    return ()=> listeners.delete(fn);
  };

  const resetDemoTrial = ()=>{
    writeNumber(LS_DEMO_ACTIVATED_AT, null);
    writeNumber(LS_DEMO_EXPORT_OK_COUNT, null);
  };

  const recordExportOk = ()=>{
    const st = getStateSafeInternal({ touchOnline: false });
    if(st?.tier !== "demo") return null;
    return bumpDemoExportOkCount();
  };

  const peekState = ()=> getStateSafeInternal({ touchOnline: false });

  const debug = {
    resetDemo: ()=>{
      resetDemoTrial();
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] resetDemo");
    },
    setDemoActivatedAt: (ts)=>{
      const stamp = Number.isFinite(ts) ? ts : Date.now();
      writeNumber(LS_DEMO_ACTIVATED_AT, stamp);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] setDemoActivatedAt", stamp);
      return stamp;
    },
    forceDemoExpired: ()=>{
      const expiredAt = Date.now() - (DEMO_TRIAL_MS + 1000);
      writeNumber(LS_DEMO_ACTIVATED_AT, expiredAt);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] forceDemoExpired", expiredAt);
    },
    setDemoExportOkCount: (n)=>{
      const count = setDemoExportOkCount(n);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] setDemoExportOkCount", count);
      return count;
    },
    setStandardLastOnlineOkAt: (ms)=>{
      const stamp = Number.isFinite(ms) ? ms : Date.now();
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] setStandardLastOnlineOkAt", stamp);
      return stamp;
    },
    setStandardAuthFresh: (fresh)=>{
      const stamp = fresh ? Date.now() : (Date.now() - (STANDARD_AUTH_FRESH_MS + 1000));
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] setStandardAuthFresh", !!fresh);
      return stamp;
    },
    forceStandardAuthStale: ()=>{
      const stamp = Date.now() - (STANDARD_AUTH_FRESH_MS + 1000);
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] forceStandardAuthStale", stamp);
      return stamp;
    },
    getDebugState: ()=>{
      const st = _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] state", st);
      return st;
    },
    expireDemoNow: ()=>{
      const expiredAt = Date.now() - (DEMO_TRIAL_MS + 1000);
      writeNumber(LS_DEMO_ACTIVATED_AT, expiredAt);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] expireDemoNow");
      return expiredAt;
    },
    resetDemoLimits: ()=>{
      const now = Date.now();
      writeNumber(LS_DEMO_ACTIVATED_AT, now);
      writeNumber(LS_DEMO_EXPORT_OK_COUNT, 0);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] resetDemoLimits");
      return now;
    },
    setStandardAuthLastOkAt: (ms)=>{
      const stamp = Number.isFinite(ms) ? ms : Date.now();
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] setStandardAuthLastOkAt", stamp);
      return stamp;
    },
    expireStandardAuthNow: ()=>{
      const stamp = Date.now() - (STANDARD_AUTH_FRESH_MS + 1000);
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] expireStandardAuthNow");
      return stamp;
    },
    startStandardGraceNow: ()=>{
      const now = Date.now();
      const stamp = now - (STANDARD_AUTH_FRESH_MS + 1000);
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      writeStandardGraceState(now, now + STANDARD_AUTH_GRACE_MS);
      writeNumber(LS_STANDARD_GRACE_MODAL_SHOWN_FOR_STARTED_AT, null);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] startStandardGraceNow", now);
      return now;
    },
    forceStandardHardExpireNow: ()=>{
      const now = Date.now();
      const stamp = now - (STANDARD_AUTH_FRESH_MS + 1000);
      const startedAt = now - (STANDARD_AUTH_GRACE_MS + 60 * 1000);
      const expiresAt = now - (60 * 1000);
      writeNumber(LS_STANDARD_LAST_ONLINE_OK_AT, stamp);
      writeStandardGraceState(startedAt, expiresAt);
      _refreshState("debug", { touchOnline: false });
      console.log("[LicenseDebug] forceStandardHardExpireNow", { startedAt, expiresAt });
      return { startedAt, expiresAt };
    },
    refreshLicense: ()=>{
      return _refreshState("debug", { touchOnline: false });
    },
  };

  return {
    init,
    getStateSafe,
    guard,
    setKeySafe,
    onChange,
    isDemoLocked,
    isStandardAuthFresh,
    recordExportOk,
    resetDemoTrial,
    peekState,
    LICENSE_TEXT,
    debug,
    refreshTick: ()=> _refreshState("tick", { touchOnline: false }),
  };
})();
window.WavCueLicense = {
  init: LicenseCore.init,
  getStateSafe: LicenseCore.getStateSafe,
  guard: LicenseCore.guard,
  setKeySafe: LicenseCore.setKeySafe,
  onChange: LicenseCore.onChange,
  resetDemoTrial: LicenseCore.resetDemoTrial,
  recordExportOk: LicenseCore.recordExportOk,
  debug: LicenseCore.debug,
  __debugSetDemoActivatedAt: LicenseCore.debug.setDemoActivatedAt,
  __debugSetDemoExportOkCount: LicenseCore.debug.setDemoExportOkCount,
  __debugSetStandardLastOnlineOkAt: LicenseCore.debug.setStandardLastOnlineOkAt,
  __debugSetStandardAuthFresh: LicenseCore.debug.setStandardAuthFresh,
  __debugExpireDemoNow: LicenseCore.debug.expireDemoNow,
  __debugResetDemoLimits: LicenseCore.debug.resetDemoLimits,
  __debugSetStandardAuthLastOkAt: LicenseCore.debug.setStandardAuthLastOkAt,
  __debugExpireStandardAuthNow: LicenseCore.debug.expireStandardAuthNow,
  __debugStartStandardGraceNow: LicenseCore.debug.startStandardGraceNow,
  __debugForceStandardHardExpireNow: LicenseCore.debug.forceStandardHardExpireNow,
  __debugRefreshLicense: LicenseCore.debug.refreshLicense,
};
LicenseCore.init();
setInterval(()=>{ try{ LicenseCore.refreshTick?.(); }catch(_){ } }, 30000);

const LICENSE_TEXT = LicenseCore.LICENSE_TEXT;
let _tierBadgeLast = null;
let _proUiTierLast = null;
const updateTierBadge = (state)=>{
  try{
    const badge = document.getElementById("tierBadge");
    if(!badge) return;
    const tierRaw = state && state.tier ? state.tier : "demo";
    const tier = String(tierRaw).toLowerCase();
    const label = tier === "pro" ? "PRO" : tier === "standard" ? "STANDARD" : "DEMO";
    badge.textContent = label;
    badge.classList.remove("tierBadge--demo", "tierBadge--standard", "tierBadge--pro");
    const cls = tier === "pro" ? "tierBadge--pro" : tier === "standard" ? "tierBadge--standard" : "tierBadge--demo";
    badge.classList.add(cls);
    if(tier !== _tierBadgeLast){
      console.log(`[TierBadge] tier=${tier}`);
      _tierBadgeLast = tier;
    }
  }catch(e){
    console.error("[License] non-fatal", e);
  }
};

const applyProUi = (state)=>{
  try{
    const tierRaw = state && state.tier ? state.tier : "demo";
    const tier = String(tierRaw).toLowerCase();
    const isPro = tier === "pro";
    const configs = [
      { wrapId: "proBtnBulkImportWrap", btnId: "proBtnBulkImport" },
      { wrapId: "proBtnBatchCheckWrap", btnId: "proBtnBatchCheck" },
      { wrapId: "proBtnBatchExportWrap", btnId: "proBtnBatchExport" },
      { wrapId: "proFilterWrap", btnId: "proFilterStatus" },
      { wrapId: "proJobMiniWrap", btnId: "proJobMini" },
    ];
    configs.forEach(({ wrapId, btnId })=>{
      const wrap = document.getElementById(wrapId);
      const btn = document.getElementById(btnId);
      if(btn && "disabled" in btn) btn.disabled = !isPro;
      if(wrap) wrap.classList.toggle("proOnlyDisabled", !isPro);
    });
    if(tier !== _proUiTierLast){
      console.log(`[ProUI] tier=${tier} bulkButtons=${isPro ? "enabled" : "disabled"}`);
      _proUiTierLast = tier;
    }
  }catch(e){
    console.error("[ProUI] non-fatal", e);
  }
};

let _demoStartupNoticeShown = false;
let _demoExportNoticeShown = false;
const buildDemoRemainingParts = (remainingDays, remainingExports)=>{
  const parts = [];
  if(Number.isFinite(remainingDays)){
    parts.push({ label: "日", value: remainingDays });
  }
  if(Number.isFinite(remainingExports)){
    parts.push({ label: "回", value: remainingExports });
  }
  return parts;
};
const renderDemoRemainingNode = (parts)=>{
  const root = document.createElement("span");
  root.className = "demoRemainingText";
  const label = document.createElement("span");
  label.textContent = "DEMO 残り：";
  root.appendChild(label);
  parts.forEach((part, idx)=>{
    const value = document.createElement("span");
    value.className = "demoRemainingValue";
    if(Number(part.value) <= 1) value.classList.add("demoRemainingValue--low");
    value.textContent = String(part.value);
    const suffix = document.createElement("span");
    suffix.textContent = part.label;
    root.appendChild(value);
    root.appendChild(suffix);
    if(idx < parts.length - 1){
      const sep = document.createElement("span");
      sep.textContent = " / ";
      root.appendChild(sep);
    }
  });
  return root;
};
const renderDemoRemainingChip = (parts)=>{
  const chip = document.createElement("span");
  chip.className = "demoRemainingChip";
  const inner = renderDemoRemainingNode(parts);
  chip.appendChild(inner);
  return chip;
};
const updateDemoRemainingBanner = (state)=>{
  try{
    const banner = document.getElementById("licenseBanner");
    const tierRaw = state && state.tier ? state.tier : "demo";
    const tier = String(tierRaw).toLowerCase();
    const demoInfo = state?.demo;
    const isDemo = tier === "demo";
    const isDemoLocked = isDemo && !!demoInfo?.isLocked;
    const remainingExports = Number.isFinite(demoInfo?.remainingExports) ? demoInfo.remainingExports : null;
    const remainingDays = Number.isFinite(demoInfo?.remainingDays) ? demoInfo.remainingDays : null;
    const parts = buildDemoRemainingParts(remainingDays, remainingExports);
    const hasRemaining = parts.length > 0;
    const showDemoRemaining = isDemo && !isDemoLocked && hasRemaining;
    const bannerMeta = state?.standard?.auth || {};
    const standardInGrace = tier === "standard" && !!bannerMeta.isInGrace;
    const standardHardExpired = tier === "standard" && !!bannerMeta.isHardExpired;
    const hasStandardBanner = standardInGrace || standardHardExpired;
    const hasDemoLockBanner = isDemoLocked;
    let mode = "none";
    if(hasStandardBanner || hasDemoLockBanner){
      mode = showDemoRemaining ? "chip" : "banner";
    }else if(showDemoRemaining){
      mode = "demo";
    }
    console.debug("[DemoRemainingBanner] update", { tier, remainingDays, remainingExports, rendered: mode !== "none", mode });
    if(!banner) return;
    if(mode === "none") return;
    // Banner content is assembled in applyLicenseUi after this helper.
  }catch(e){
    console.error("[DemoRemainingUI] non-fatal", e);
  }
};
const applyLicenseUi = (state)=>{
  try{
    const tierRaw = state && state.tier ? state.tier : "demo";
    const tier = String(tierRaw).toLowerCase();
    const demoInfo = state?.demo;
    const isDemo = tier === "demo";
    const demoBlockedReason = demoInfo?.demoBlockedReason || null;
    const isDemoLocked = isDemo && !!demoInfo?.isLocked;
    const remainingDays = Number.isFinite(demoInfo?.remainingDays) ? demoInfo.remainingDays : null;
    const remainingExports = Number.isFinite(demoInfo?.remainingExports) ? demoInfo.remainingExports : null;
    const demoParts = buildDemoRemainingParts(remainingDays, remainingExports);
    const showDemoRemaining = isDemo && !isDemoLocked && demoParts.length > 0;
    const standardAuth = state?.standard?.auth || {};
    const standardInGrace = tier === "standard" && !!standardAuth.isInGrace;
    const standardHardExpired = tier === "standard" && !!standardAuth.isHardExpired;
    const standardExportAllowed = tier !== "standard" || !standardHardExpired;
    const banner = document.getElementById("licenseBanner");
    if(banner){
      let bannerText = "";
      let bannerMeta = "";
      let isStandardBanner = false;
      let isGraceBanner = false;
      let isDemoBanner = false;
      let hasChip = false;
      if(isDemoLocked){
        bannerText = (demoBlockedReason === "demo_export_limit")
          ? LICENSE_TEXT.demoExportLimitBanner
          : LICENSE_TEXT.demoExpiredBanner;
      }else if(tier === "standard" && standardInGrace){
        bannerText = LICENSE_TEXT.standardGraceBanner;
        if(Number.isFinite(standardAuth.graceRemainingMinutes) && standardAuth.graceRemainingMinutes > 0){
          bannerMeta = `あと${standardAuth.graceRemainingMinutes}分`;
        }
        isStandardBanner = true;
        isGraceBanner = true;
      }else if(tier === "standard" && standardHardExpired){
        bannerText = LICENSE_TEXT.standardAuthBanner;
        isStandardBanner = true;
      }
      while(banner.firstChild) banner.removeChild(banner.firstChild);
      if(bannerText){
        const textSpan = document.createElement("span");
        textSpan.className = "licenseBannerText";
        textSpan.textContent = bannerText;
        banner.appendChild(textSpan);
        if(bannerMeta){
          const metaSpan = document.createElement("span");
          metaSpan.className = "licenseBannerMeta";
          metaSpan.textContent = bannerMeta;
          banner.appendChild(metaSpan);
        }
        if(showDemoRemaining){
          banner.appendChild(renderDemoRemainingChip(demoParts));
          hasChip = true;
        }
      }else if(showDemoRemaining){
        banner.appendChild(renderDemoRemainingNode(demoParts));
        isDemoBanner = true;
      }
      banner.classList.toggle("licenseBanner--standard", isStandardBanner);
      banner.classList.toggle("licenseBanner--grace", isGraceBanner);
      banner.classList.toggle("licenseBanner--demo", isDemoBanner);
      banner.classList.toggle("licenseBanner--withChip", hasChip);
      banner.classList.toggle("show", !!bannerText || isDemoBanner);
    }
    if(isDemo && !_demoStartupNoticeShown){
      _demoStartupNoticeShown = true;
      if(window.safeToast) window.safeToast(LICENSE_TEXT.demoNotice, "info");
    }
    const setDisabled = (el, disabled)=>{
      if(!el || !("disabled" in el)) return;
      el.disabled = !!disabled;
    };
    const lockEditEls = [
      "btnExport",
      "btnStdCheck",
      "btnAddCustom",
      "btnAddPair",
      "btnAddBcLabel",
      "selBcLabel",
      "customLabel",
      "pairSeconds",
    ].map(id=> document.getElementById(id));
    lockEditEls.forEach(el=> setDisabled(el, isDemoLocked));
    if(tier === "standard"){
      setDisabled(document.getElementById("btnExport"), !standardExportAllowed);
    }

    const presetDisabled = isDemo;
    const presetEls = [
      "sc_tab_preset",
      "sc_presetManage",
      "sc_pm_pick",
      "sc_pm_new",
      "sc_pm_sort",
      "sc_pm_clone",
      "sc_pm_import",
      "sc_pm_export",
      "sc_pm_save",
      "sc_pm_delete",
      "sc_pm_id",
      "sc_pm_desc",
      "sc_pm_name",
      "sc_pm_target",
      "sc_pm_tol",
      "sc_pm_tpmax",
      "sc_pm_srsel",
      "sc_pm_bitssel",
      "sc_pm_chsel",
      "sc_pm_silmin",
      "sc_pm_silmax",
    ].map(id=> document.getElementById(id));
    presetEls.forEach(el=> setDisabled(el, presetDisabled));

    const backupDisabled = isDemo;
    const backupEls = [
      "settingsCleanupNow",
      "settingsResetRecommended",
      "settingsAutoCleanup",
      "settingsRetentionDays",
      "settingsBackupQuotaGB",
      "settingsMinKeepCount",
      "settingsDeleteMethod",
      "settingsSave",
      "settingsCleanupConfirmRun",
    ].map(id=> document.getElementById(id));
    backupEls.forEach(el=> setDisabled(el, backupDisabled));
    document.querySelectorAll("[data-settings-folder]").forEach((el)=> setDisabled(el, backupDisabled));
    const demoNote = document.getElementById("settingsBackupDemoNote");
    if(demoNote) demoNote.style.display = backupDisabled ? "block" : "none";
  }catch(e){
    console.error("[License] non-fatal", e);
  }
  try{ updateDemoRemainingBanner(state); }catch(_){}
};

Promise.resolve(window.WavCueLicense?.getStateSafe?.()).then(updateTierBadge).catch((e)=>{
  console.error("[License] non-fatal", e);
});
Promise.resolve(window.WavCueLicense?.getStateSafe?.()).then(applyProUi).catch((e)=>{
  console.error("[ProUI] non-fatal", e);
});
Promise.resolve(window.WavCueLicense?.getStateSafe?.()).then(applyLicenseUi).catch((e)=>{
  console.error("[License] non-fatal", e);
});
if(typeof window.WavCueLicense?.onChange === "function"){
  window.WavCueLicense.onChange((st)=> updateTierBadge(st));
  window.WavCueLicense.onChange((st)=> applyProUi(st));
  window.WavCueLicense.onChange((st)=> applyLicenseUi(st));
}
(function(){
  const log = ()=>{
    const el = document.querySelector('.bottomRow') || document.querySelector('.proBottomRow');
    if(!el) return;
    const height = getComputedStyle(el)?.height;
    console.log("[UI][bottom] FINAL_OVERRIDES applied", height);
  };
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", ()=> requestAnimationFrame(log), { once: true });
  }else{
    requestAnimationFrame(log);
  }
})();

const guardBulkImport = (ctx)=> LicenseCore.guard("bulkImport", ctx);
const guardBulkCheck = (ctx)=> LicenseCore.guard("bulkCheck", ctx);
const guardBulkExport = (ctx)=> LicenseCore.guard("bulkExport", ctx);
const guardExport = (ctx)=> LicenseCore.guard("exportSingle", ctx);
const guardHistory = (ctx)=> LicenseCore.guard("history", ctx);
const guardPreset = (ctx)=> LicenseCore.guard("preset", ctx);
const guardBackup = (ctx)=> LicenseCore.guard("backup", ctx);
window.guardBulkImport = guardBulkImport;
window.guardBulkCheck = guardBulkCheck;
window.guardBulkExport = guardBulkExport;
window.guardExport = guardExport;
window.guardHistory = guardHistory;
window.guardPreset = guardPreset;
window.guardBackup = guardBackup;
window._guardBulkImport = guardBulkImport;
window._guardBulkCheck = guardBulkCheck;
window._guardBulkExport = guardBulkExport;
window._guardExport = guardExport;
window._guardExportSingle = guardExport;
window._guardHistory = guardHistory;
window._guardPreset = guardPreset;
window._guardBackup = guardBackup;

(() => {
"use strict";

/* =====================================================================
   WavCue - Code Organization Notes (no behavior change)
   ---------------------------------------------------------------------
   This file remains a single HTML for prototype distribution.
   For maintainability, use the section headers below and the structured
   window.WavCue.api.modules map (added at the bottom) to navigate.

   Sections (approx):
   1) State / Config / DOM cache
   2) Progress overlay (_prog)
   3) RIFF parsing helpers (parseRiffChunks, _riffExtractChunkPayload)
   4) CUE & LIST-adtl (parseWavCues, normalizeCueIds, buildCueChunks)
   5) Attachments (PDF / CSV / XML / TEXT)
   6) QC / Self-Verify
   7) Export / Save (exportWav, rebuildWaveFromOriginal*)
   8) UI (dialogs, tabs, renderers)
   9) Boot
   ===================================================================== */
/* @ts-check */

// Ensure preset import/export never fails due to missing toast helpers.
// Use window.safeToast(...) everywhere (never ReferenceError).

document.documentElement.classList.toggle("is-mac", !!window.platform?.isMac);
document.documentElement.classList.toggle("is-win", !!window.platform?.isWindows);
/* =============================================================================
  WavCue — Sectioned (HTML single-file)
  - Code cleanup pass: 2026-01-07 (no behavior change intended)
  - Base: v5_8_8_attachdesc_small_remove_diffnote
  - 目的: 今後の機能追加に備え、コードを“論理セクション”で整理（挙動変更なし）
  - 方針: 既存の関数/変数名・処理順・UI挙動は維持。コメント/区画/軽いエイリアスのみ追加。
  - セクション: CFG / STATE / DOM / UTIL / AUDIO_PARSE / AUDIO_BUILD / PDF_ATTACH
              / CUE / QC_EXPORTCHECK / UI / BOOT
============================================================================= */


/**
 * Internal configuration constants.
 * Keep user-facing UI free of dev strings; this is for maintainability only.
 */

/* ===============================
   CFG (constants)
================================ */

const CFG = Object.freeze({
  PDF_NAME_MAX_BYTES: 128,
  STDCHK_SILENCE_THRESHOLD_DB: -60,
  STDCHK_CLIP_SAMPLE_THRESH: 0.9999,
  PRO_AUDIO_CACHE_CAP_MB: 768,
  PRO_AUDIO_CACHE_MARGIN: 0.92,
  PRO_AUDIO_CACHE_LOW_WATER: 0.80,

    // 規格チェッカー（局別プリセット：編集・保存可 / 初期値）
  QC_DEFAULT_PRESET_ID: "minhouren_default",
  QC_PRESETS: [
    {
      id: "minhouren_default",
      name: "デフォルト",
      targetLufs: -24,
      tolLufs: 1.0,
      maxTruePeakDb: -1.0,
      allowedSampleRates: [48000],
      allowedBits: [16],
      allowedChannels: [2],
      silenceMinSec: 0.0,
      silenceMaxSec: 0.5,
    }
  ],
});

// App version (prototype)
const APP_VERSION = "v5_10_28";



/* ===============================
   STATE (single source of truth)
================================ */

const state = {
  file: null,
  audioUrl: null,
  audioEl: null,
  audioCtx: null,
  buffer: null,
  sr: 48000,
  fileSr: null,         // original WAV fmt sampleRate
  fileBlockAlign: null, // original WAV fmt blockAlign
  fileTotalSamples: null,// original data samples (dataSize/blockAlign)
  peaks: null,
  zoom: 1,
  vZoom: 1,
  scrollPx: 0,
  playheadSec: 0,
  isPlaying: false,
  playStartSec: 0, // 再生開始位置（停止時に戻す）
  rafId: 0,
  cues: [],
  nextCueId: 1,
  draggingCueId: null,
  dragOffsetSec: 0,
  dragPair: null,  // {stId,enId,gap,dragLabel}
  linkPair: true,
  srcAb: null,
  srcChunks: null,
  cmcdLayout: null,
  cmcdBytes: null,

  // cmcdプリセット
  cmcdPresetId: "",
  cmcdUserPresetsLoaded: false,
  cmcdUserPresets: [],

  // 規格チェック / 自動レベル補正
  qcPresetId: null,
  qcPresetOrder: [],
  qcHasRun: false,
  qcUserPresetsLoaded: false,
  qcUserPresetsHydrated: false,
  qcUserPresetsDirty: false,
  qcUserPresets: [],
  scLast: null,
  scActiveTab: "results",
  origBuffer: null,
  procApplied: false,
  procDataPayload: null, // Uint8Array (PCM payload) when auto-fix applied
  procInfo: null,        // {totalDb:number, gainDb:number, tpSafetyDb:number}
  previewUrl: null,      // Blob URL for preview playback when processed

  attachments: [],      // [{id,name,bytes,kind,mime,cueId,_storeId}]
  attachSel: 0,
  pdfAttach: null,        // legacy alias: selected attachment (auto-maintained)
  pdfViewUrl: null,
  cueRenderLog: { fileId: null, cueCount: null },
  activeFileId: null,
  ui: { isLoadingWav: false },
};

// Alias for future refactors (no functional impact)
const APP_STATE = state;
const CMCD_KEYS = ["Ver", "素材略号", "素材コード", "共通コード", "局内コード1", "局内コード2", "素材制作日", "素材制作時間", "広告主名", "広告主担当者", "広告主連絡先", "広告会社名", "広告会社担当者", "広告会社連絡先", "制作会社名", "制作会社担当者", "制作会社連絡先", "ポスプロ名", "ポスプロ担当者", "ポスプロ連絡先", "素材タイトル", "素材秒数", "使用放送局名", "使用開始日", "使用開始時間", "素材有効開始日", "素材有効開始時刻", "素材有効最終日", "素材有効最終時刻", "制作会社コメント1", "制作会社コメント2", "ポスプロコメント1", "ポスプロコメント2", "広告会社コメント1", "広告会社コメント2", "放送局コメント1", "放送局コメント2"];
const CMCD_KEYS_UI = ["Ver", "素材略号", "素材コード", "共通コード", "局内コード1", "局内コード2", "素材制作日", "素材制作時間", "広告主名", "広告主担当者", "広告主連絡先", "広告会社名", "広告会社担当者", "広告会社連絡先", "制作会社名", "制作会社担当者", "制作会社連絡先", "ポスプロ名", "ポスプロ担当者", "ポスプロ連絡先", "素材タイトル", "素材秒数", "使用放送局名", "使用開始日", "使用開始時間", "素材有効開始日", "素材有効開始時刻", "素材有効最終日", "素材有効最終時刻", "制作会社コメント1", "ポスプロコメント1", "広告会社コメント1", "放送局コメント1"];

function _cmcdSlotForKey(key){
  const i = CMCD_KEYS.indexOf(key);
  if(i<0) return null;
  return CMCD_FIXED_SLOTS[i];
}
 // UIに出す項目（コメント2系は非表示）

const CMCD_FIXED_SLOTS = [[0, 2], [2, 16], [18, 16], [34, 24], [58, 16], [74, 16], [90, 10], [100, 8], [108, 64], [172, 32], [204, 64], [268, 64], [332, 32], [364, 64], [428, 64], [492, 32], [524, 64], [588, 64], [652, 32], [684, 64], [748, 128], [876, 6], [882, 8], [890, 10], [900, 8], [908, 10], [918, 8], [926, 10], [936, 8], [944, 128], [1072, 128], [1200, 128], [1328, 128], [1456, 128], [1584, 128], [1712, 128], [1840, 208]]; // [start,len] × CMCD_KEYS



/* ===============================
   DOM helpers
================================ */

const $ = (id)=> document.getElementById(id);

/* ===============================
   MODAL SHELL (outside click + x + dirty confirm)
================================ */
const _dialogDirtyText = "変更内容が保存されていません。閉じますか？";
function _dialogCloseWithGuard(dlg){
  if(!dlg) return;
  const guard = dlg.dataset.dirtyGuard === "1";
  const dirty = dlg.dataset.dirty === "1";
  if(guard && dirty){
    const ok = confirm(_dialogDirtyText);
    if(!ok) return;
  }
  dlg.dataset.dirty = "0";
  try{ dlg.close(); }catch(_){ dlg.open = false; }
}
function _dialogMarkDirty(e){
  const dlg = e.currentTarget;
  const el = e.target;
  if(!dlg || !el || !el.tagName) return;
  if(el.closest && el.closest("[data-no-dirty]")) return;
  const tag = el.tagName.toLowerCase();
  if(tag !== "input" && tag !== "textarea" && tag !== "select") return;
  if(el.disabled || el.readOnly) return;
  dlg.dataset.dirty = "1";
}
function _wireDialogShell(dlg){
  if(!dlg || dlg.dataset.shellWired === "1") return;
  if(dlg.classList.contains("toastLayer")) return;
  if(dlg.dataset.lockClose === "1"){
    dlg.dataset.shellWired = "1";
    dlg.addEventListener("cancel", (e)=>{ e.preventDefault(); });
    return;
  }
  dlg.dataset.shellWired = "1";
  dlg.classList.add("dialogShell");
  const head = dlg.querySelector(".modalHead, .dlgHead");
  if(!head){
    dlg.classList.add("dialogShellBare");
  }
  if(!dlg.querySelector(".modalCloseBtn")){
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "modalCloseBtn";
    btn.setAttribute("aria-label", "閉じる");
    btn.textContent = "×";
    btn.addEventListener("click", ()=> _dialogCloseWithGuard(dlg));
    dlg.appendChild(btn);
  }
  if(dlg.dataset.closeLogged !== "1"){
    dlg.dataset.closeLogged = "1";
    const name = dlg.id || dlg.getAttribute("aria-label") || (dlg.className || "dialog");
    console.log(`[UI] closeBtn layout modal=${name}`);
  }
  dlg.addEventListener("click", (e)=>{ if(e.target === dlg) _dialogCloseWithGuard(dlg); });
  dlg.addEventListener("cancel", (e)=>{ e.preventDefault(); _dialogCloseWithGuard(dlg); });
  dlg.addEventListener("close", ()=>{ dlg.dataset.dirty = "0"; });
  if(dlg.dataset.dirtyGuard === "1"){
    dlg.addEventListener("input", _dialogMarkDirty, true);
    dlg.addEventListener("change", _dialogMarkDirty, true);
  }
}
function _initDialogShells(){
  document.querySelectorAll("dialog").forEach(_wireDialogShell);
}
function _initStandardGraceDialog(){
  const dlg = $("standardGraceDialog");
  const okBtn = $("standardGraceOk");
  const msg = $("standardGraceMessage");
  if(!dlg || !okBtn) return;
  if(msg && typeof LICENSE_TEXT?.standardGraceModal === "string"){
    msg.textContent = LICENSE_TEXT.standardGraceModal;
  }
  okBtn.addEventListener("click", ()=>{
    try{ dlg.close(); }catch(_){ dlg.open = false; }
  });
}
function _initUiDialogs(){
  _initDialogShells();
  _initStandardGraceDialog();
}
if(document.readyState === "loading"){
  document.addEventListener("DOMContentLoaded", _initUiDialogs);
}else{
  _initUiDialogs();
}


/* ===============================
   PROGRESS (Load / Export)
================================ */
const _prog = (()=> {
  let ov=null, msg=null, sub=null, pctEl=null, bar=null, hint=null, cancelBtn=null;
  let token = 0;
  let visible = false;
  let lastUpdate = 0;
  let watchdogId = 0;
  let abortCtrl = null;
  let cancelled = false;

  const TIMEOUT_MS = 9000; // phase stall hint

  function _ensure(){
    if(ov) return;
    ov = $("progressOverlay");
    msg = $("progMsg");
    sub = $("progSub");
    pctEl = $("progPct");
    bar = $("progBar");
    hint = $("progHint");
    cancelBtn = $("btnProgCancel");
    if(cancelBtn && !cancelBtn._bound){
      cancelBtn._bound = true;
      cancelBtn.addEventListener('click', ()=>{
        cancelled = true;
        try{ if(abortCtrl) abortCtrl.abort(); }catch(_){ }
        try{ cancelBtn.style.display = 'none'; }catch(_){ }
        try{ if(hint) hint.textContent = 'キャンセルしました。'; }catch(_){ }
      });
    }
  }

  function _paint(){
    return new Promise((resolve)=>{
      requestAnimationFrame(()=> resolve());
    });
  }

  async function _yieldUI(){
    // paint now + yield one tick so text/width updates are actually visible
    await _paint();
    await new Promise(r=>setTimeout(r,0));
  }

  function set(pct, m, s){
    _ensure();
    lastUpdate = Date.now();
    if(hint) hint.textContent = '';
    if(m!=null) msg.textContent = String(m);
    if(s!=null) sub.textContent = String(s);
    if(pct==null){
      bar.classList.add("indet");
      bar.style.width = "40%";
      pctEl.textContent = "";
    }else{
      const p = clamp(Number(pct)||0, 0, 1);
      bar.classList.remove("indet");
      bar.style.width = `${Math.round(p*100)}%`;
      pctEl.textContent = `${Math.round(p*100)}%`;
    }
  }

  function _startWatchdog(){
    if(watchdogId) return;
    watchdogId = setInterval(()=>{
      if(!visible) return;
      const dt = Date.now() - (lastUpdate||0);
      if(dt > TIMEOUT_MS){
        try{
          if(hint && !hint.textContent){
            hint.textContent = "処理が長い場合があります（重い処理中）";
          }
          if(cancelBtn) cancelBtn.style.display = "inline-flex";
        }catch(_){}
      }
    }, 500);
  }
  function _stopWatchdog(){
    if(!watchdogId) return;
    try{ clearInterval(watchdogId); }catch(_){}
    watchdogId = 0;
  }

  function show(m, s, ctrl){
    _ensure();
    abortCtrl = ctrl || abortCtrl || null;
    cancelled = false;
    visible = true;
    set(null, m||"処理中…", s||"");
    ov.classList.add("show");
    _startWatchdog();
  }

  function hide(){
    _ensure();
    visible = false;
    _stopWatchdog();
    abortCtrl = null;
    if(cancelBtn) try{ cancelBtn.style.display = 'none'; }catch(_){ }
    ov.classList.remove("show");
  }

  async function step(pct, m, s){
    set(pct, m, s);
    await _yieldUI();
  }

  /**
   * Run a task with the overlay guaranteed to close.
   * - AbortError is treated as "silent cancel" (no 100%/完了表示)
   */
  async function run(m, s, fn){
    const my = ++token;
    abortCtrl = new AbortController();
    show(m, s, abortCtrl);
    await _yieldUI();
    try{
      const api = {
        set: (pct, mm, ss)=>{ if(my===token) set(pct, mm, ss); },
        step: async(pct, mm, ss)=>{ if(my===token){ await step(pct, mm, ss); } },
        yield: async()=>{ if(my===token){ await _yieldUI(); } },
        signal: abortCtrl ? abortCtrl.signal : null,
        cancelled: ()=> !!cancelled
      };
      const res = await fn(api);
      if(my===token){
        await step(1, m||"処理中…", "完了");
        hide();
      }
      return res;
    }catch(err){
      if(my===token){
        if(err && err.name === "AbortError"){
          // user cancelled picker etc.
          hide();
          return null;
        }
        set(null, m||"処理中…", "エラー");
        await _yieldUI();
        hide();
      }
      throw err;
    }
  }

  return { show, hide, set, step, run, yield:_yieldUI };
})();
window._prog = _prog;

function _readFileArrayBufferWithProgress(file, onProg){
  return new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onerror = ()=> reject(fr.error || new Error("File read failed"));
    fr.onabort = ()=> reject(new Error("File read aborted"));
    fr.onprogress = (e)=>{
      if(typeof onProg === "function"){
        if(e && e.lengthComputable) onProg(e.loaded / e.total);
        else onProg(null);
      }
    };
    fr.onload = ()=> resolve(fr.result);
    fr.readAsArrayBuffer(file);
  });
}

/* ===============================
   HISTORY (Undo / Redo)
================================ */

/* ===== Undo / Redo (Cmd/Ctrl+Z , Cmd/Ctrl+Shift+Z) =====
   - App-level history for non-destructive edits (CUE / chunk text / cmcd / PDF attach)
   - Avoid storing large audio buffers; keep only editable state.
*/
const _undo = {
  past: [],
  future: [],
  max: 120,
  lock: false,
};

const _pdfStore = new Map(); // id -> Uint8Array
let _pdfStoreNextId = 1;

function _pdfStorePut(u8){
  try{
    const id = _pdfStoreNextId++;
    const bytes = (u8 instanceof Uint8Array) ? u8.slice() : new Uint8Array(u8||[]);
    _pdfStore.set(id, bytes);
    return id;
  }catch(_){
    return null;
  }
}
function _pdfStoreGet(id){
  try{
    if(id==null) return null;
    const v = _pdfStore.get(id);
    return (v instanceof Uint8Array) ? v : null;
  }catch(_){ return null; }
}

function _captureUndoState(){
  const cmcd = {};
  try{
    document.querySelectorAll("[data-cmcd]").forEach((el)=>{
      const k = el.getAttribute("data-cmcd");
      if(k) cmcd[k] = (el.value ?? "").toString();
    });
  }catch(_){}

  const cues = (Array.isArray(state.cues) ? state.cues : []).map(c=>({
    id: c.id >>> 0,
    label: String(c.label ?? ""),
    sec: Number(c.sec ?? 0),
  })).sort((a,b)=>a.id-b.id);

  const out = {
    cues,
    nextCueId: state.nextCueId >>> 0,
    linkPair: !!state.linkPair,
    zoom: Number(state.zoom ?? 1),
    vZoom: Number(state.vZoom ?? 1),
    scrollPx: Number(state.scrollPx ?? 0),
    playheadSec: Number(state.playheadSec ?? 0),
    pairSeconds: ($("pairSeconds")?.value ?? "").toString(),
    bext: ($("bextArea")?.value ?? "").toString(),
    ixml: (null?.value ?? "").toString(),
    cmcd,
    // attachments are NOT part of Undo (safety)
  };
  return out;
}
function _undoSig(s){
  try{ return JSON.stringify(s); }catch(_){ return String(Math.random()); }
}
function _undoPushSnapshot(snapshot){
  if(_undo.lock) return;
  if(!state.buffer) return; // only after WAV load
  if(!snapshot) return;
  const sig = _undoSig(snapshot);
  const lastSig = _undo.past.length ? _undo.past[_undo.past.length-1].sig : null;
  if(sig === lastSig) return;
  _undo.past.push({sig, snapshot});
  if(_undo.past.length > _undo.max) _undo.past.shift();
  _undo.future.length = 0;
}
function undoCheckpoint(){
  // Call BEFORE mutating any undoable state
  if(_undo.lock) return;
  if(!state.buffer) return;
  _undoPushSnapshot(_captureUndoState());
  try{ scheduleDiffUpdate(); }catch(_){ }
}
function undoReset(){
  try{
    _undo.past.length = 0;
    _undo.future.length = 0;
  }catch(_){}
}
function _applyUndoState(s){
  if(!s) return;
  _undo.lock = true;
  try{
    // restore basic view state
    if(Number.isFinite(s.zoom)) state.zoom = clamp(s.zoom, 1, 32);
    if(Number.isFinite(s.vZoom)) state.vZoom = clamp(s.vZoom, 0.25, 10);
    if(Number.isFinite(s.scrollPx)) state.scrollPx = Math.max(0, s.scrollPx);

    // restore cues
    state.cues = (Array.isArray(s.cues) ? s.cues : []).map(c=>({
      id: c.id >>> 0,
      label: String(c.label ?? ""),
      sec: Number(c.sec ?? 0),
    }));
    state.nextCueId = (s.nextCueId >>> 0) || ((state.cues.reduce((m,c)=>Math.max(m,c.id),0)+1)>>>0);

    // restore pair link + ui
    state.linkPair = !!s.linkPair;
    const chk = $("chkLinkPair");
    if(chk) chk.checked = state.linkPair;
    if(!state.linkPair) state.dragPair = null;

    // restore form fields
    const ps = $("pairSeconds"); if(ps) ps.value = (s.pairSeconds ?? ps.value ?? "").toString();
    const be = $("bextArea"); if(be) be.value = (s.bext ?? "").toString();
    const ix = null;   if(ix) ix.value = (s.ixml ?? "").toString();

    // restore cmcd
    if(s.cmcd && typeof s.cmcd === "object"){
      try{
        for(const k of Object.keys(s.cmcd)){
          const el = document.querySelector(`[data-cmcd="${CSS.escape(k)}"]`);
          if(el) el.value = (s.cmcd[k] ?? "").toString();
        }
      }catch(_){}
      try{ cmcdBuildBytesFromInputs(); }catch(_){}
    }

    // attachments are NOT part of Undo (safety) — keep current attachments as-is

    // restore playhead (optional)
    if(Number.isFinite(s.playheadSec)){
      try{ setPlayhead(s.playheadSec); ensureVisibleSec(s.playheadSec); }catch(_){}
    }

  }finally{
    _undo.lock = false;
  }

  // redraw / refresh UI
  try{ renderCues(); }catch(_){}
  try{ updateButtons(); }catch(_){}
  try{ drawAll(); }catch(_){}
  try{ refreshChunkDialogViews(); }catch(_){}
}

function undoDo(){
  if(_undo.lock) return;
  if(!_undo.past.length) return;
  const prev = _undo.past.pop();
  const cur = _captureUndoState();
  _undo.future.push({sig:_undoSig(cur), snapshot:cur});
  _applyUndoState(prev.snapshot);
}
function redoDo(){
  if(_undo.lock) return;
  if(!_undo.future.length) return;
  const next = _undo.future.pop();
  const cur = _captureUndoState();
  _undo.past.push({sig:_undoSig(cur), snapshot:cur});
  if(_undo.past.length > _undo.max) _undo.past.shift();
  _applyUndoState(next.snapshot);
}

// Track text-like edits on blur (do not override native per-field undo while typing)
function _bindUndoOnBlur(el){
  if(!el) return;
  let snap = null;
  el.addEventListener("focus", ()=>{
    if(_undo.lock) return;
    if(!state.buffer) return;
    snap = _captureUndoState();
  });
  el.addEventListener("blur", ()=>{
    if(_undo.lock) return;
    if(!state.buffer) return;
    if(!snap) return;
    const after = _captureUndoState();
    if(_undoSig(after) !== _undoSig(snap)) _undoPushSnapshot(snap);
    snap = null;
  });
}

// Install after UI is ready
function installUndoTracking(){
  try{
    _bindUndoOnBlur($("bextArea"));
    _bindUndoOnBlur(null);
    _bindUndoOnBlur($("pairSeconds"));
    _bindUndoOnBlur($("customLabel"));

    // cmcd inputs are created lazily -> delegate on dialog
    const cmcdDlg = $("cmcdDialog");
    if(cmcdDlg){
      let snap = null;
      cmcdDlg.addEventListener("focusin", (e)=>{
        const t = e.target;
        if(!(t && t.getAttribute && t.getAttribute("data-cmcd"))) return;
        if(_undo.lock || !state.buffer) return;
        snap = _captureUndoState();
      });
      cmcdDlg.addEventListener("focusout", (e)=>{
        const t = e.target;
        if(!(t && t.getAttribute && t.getAttribute("data-cmcd"))) return;
        if(_undo.lock || !state.buffer) return;
        if(!snap) return;
        const after = _captureUndoState();
        if(_undoSig(after) !== _undoSig(snap)) _undoPushSnapshot(snap);
        snap = null;
      });
    }
  }catch(_){}
}
/* ===== /Undo / Redo ===== */


/* Logging */
function nowTime(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function log(msg){
  const line = document.createElement("div");
  line.className = "logLine";
  line.textContent = `[${nowTime()}] ${msg}`;
  const box = $("logBox");
  if(box) box.prepend(line);
  const box2 = $("logBox2");
  if(box2){ const line2 = line.cloneNode(true); box2.prepend(line2); }



/* ===== ProTools+ v2 UX helpers (toast + shortcuts) ===== */

/* ===============================
   UI: Toast / Logging surface
================================ */

function getToastHostTarget(){
  const modal = document.querySelector("dialog:modal"); // open modal dialog (top-layer)
  const root = document.getElementById("toastRoot");
  if(!root) return null;

  // If modal exists, move toastRoot into the modal to guarantee top-layer visibility
  if(modal){
    // ensure toastRoot is inside modal (append keeps same node)
    if(!modal.contains(root)){
      modal.appendChild(root);
    }
  }else{
    // ensure toastRoot is directly under body (for normal pages)
    if(root.parentElement !== document.body){
      document.body.appendChild(root);
    }
  }
  return root;
}

function toast(msg, type="ok", timeout=2600){
  const targetContainer = getToastHostTarget();
  if(!targetContainer) return;

  console.log("[Toast] show:", msg, "target:", targetContainer);

  const t = document.createElement("div");
  t.className = `toast ${type}`;

  const ic = document.createElement("div");
  ic.className = "ic";
  ic.textContent = type==="err" ? "!" : (type==="warn" ? "…" : "OK");

  const m = document.createElement("div");
  m.className = "msg";
  m.textContent = String(msg ?? "");

  t.appendChild(ic);
  t.appendChild(m);
  targetContainer.appendChild(t);

  const settingsToastDebug = document.getElementById("settingsToastDebug");
  if(settingsToastDebug) settingsToastDebug.textContent = `debug line: ${msg}`;

  // fade-in (no transform animation)
  requestAnimationFrame(()=>{ try{ t.classList.add("in"); }catch(_){ } });

  window.setTimeout(()=>{
    t.classList.add("out");
    window.setTimeout(()=>{ try{ t.remove(); }catch(_){ } }, 200);
  }, timeout);
}

window.safeToast = function(message, type="ok", timeout=2600){
  toast(message, type, timeout);
};

// Only toast for major ops & errors (avoid spam)
function maybeToastFromLog(msg){
  try{
    const s = String(msg || "");
    // Avoid double toasts when loading a WAV that already contains a PDF
    if(state && state.ui && state.ui.isLoadingWav){
      if(s.includes("ファイルを添付しました") || s.includes("添付ファイルを認識しました")) return;
    }
    if(s.startsWith("ERROR:") || s.startsWith("Error:") || s.startsWith("Export failed") || s.includes("失敗")){
      toast(s.replace(/^ERROR:\s*/,"").trim() || s, "err", 3600);
      return;
    }
    if(s.includes("書き出し完了") || s.includes("ファイルを添付しました") || s.includes("添付ファイルを認識しました")){
      toast(s.replace(/^OK:\s*/,"").trim() || s, "ok", 2600);
      return;
    }
    if(s.startsWith("WARN:")){
      // show only user-actionable warnings
      if(s.includes("先にWAV") || s.includes("WAV以外")){
        toast(s.replace(/^WARN:\s*/,"").trim() || s, "warn", 3200);
      }
      return;
    }
  }catch(_){}
}

/* ===== /ProTools+ v2 UX helpers ===== */
  try{ maybeToastFromLog(msg); }catch(_){ }
}

/* --- WavCue diagnostics (no behavior change) --- */
(function(){
  if (typeof window.WAVCUE_DIAG !== "boolean") window.WAVCUE_DIAG = true;

  if (typeof window.diagLog !== "function") {
    window.diagLog = function(tag, msg, obj){
      try{
        if (!window.WAVCUE_DIAG) return;
        if (obj !== undefined) console.log(tag, msg, obj);
        else console.log(tag, msg);
      }catch(_){}
    };
  }

  if (typeof window.diagErr !== "function") {
    window.diagErr = function(tag, msg, err){
      try{
        console.error(tag, msg, err || "");
      }catch(_){}
    };
  }
})();

if (typeof window.diagState !== "function") {
  window.diagState = function(extra){
    try{
      const st = (typeof window.getState === "function") ? window.getState() : window.state;
      const cueCount = Array.isArray(st?.cues) ? st.cues.length : 0;
      const activeFileId = window.activeFileId || window.activeId
        || ((typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null);
      return Object.assign({ activeFileId, cueCount }, extra || {});
    }catch(_){
      return extra || {};
    }
  };
}

/* --- compat: prevent ReferenceError for cmcd scan helpers --- */
(function(){
  if (typeof window.findCmcdInTextChunks !== "function") {
    window.findCmcdInTextChunks = function(){
      try{
        console.warn("[ARTIFACT][CMCD] findCmcdInTextChunks missing -> skip");
        return null;
      }catch(_){ return null; }
    };
  }
})();

/* --- CMCD: compat + hard guard (do not break import) --- */
(function(){
  if (typeof window._cmcdInputsHasValues === "function") return;

  // if legacy function exists, alias it
  if (typeof window.cmcdInputsHasValues === "function") {
    window._cmcdInputsHasValues = window.cmcdInputsHasValues;
    return;
  }

  // fallback: detect any non-empty value in object
  window._cmcdInputsHasValues = function(obj){
    try{
      if(!obj || typeof obj !== "object") return false;
      for(const k of Object.keys(obj)){
        const v = obj[k];
        if(v == null) continue;
        if(typeof v === "string" && v.trim() !== "") return true;
        if(typeof v === "number" && Number.isFinite(v)) return true;
        if(typeof v === "boolean" && v) return true;
        if(typeof v === "object"){
          if(Array.isArray(v) && v.length) return true;
          const s = JSON.stringify(v);
          if(s && s !== "{}" && s !== "[]") return true;
        }
      }
      return false;
    }catch(_){
      return false;
    }
  };
})();

/* --- CMCD extractor (real implementation; must not throw) --- */
(function(){
  window.findCmcdInTextChunks = function(textChunks, fileId){
    try{
      if (!Array.isArray(textChunks) || textChunks.length === 0) return null;

      const tryParseJSON = (s)=>{
        try{
          const obj = JSON.parse(s);
          if(obj && typeof obj === "object") return obj;
        }catch(_){}
        return null;
      };
      const KEY_HINTS = (window.CMCD_KEYS_UI || []).concat([
        "共通コード","局内コード","素材秒数","素材タイトル","素材略号","素材コード",
        "ポスプロコメント","放送局コメント","COMMENT","NOTE","CLIENT"
      ]);
      const hasHint = (txt)=> KEY_HINTS.some(k=>txt.includes(k));

      const normalizeChunks = textChunks.map((c)=>{
        if(typeof c === "string") return { id: "text", text: c };
        if(c && typeof c === "object"){
          const id = String(c.id || c.chunkId || c.name || "chunk");
          const text = String(c.text || c.headText || c.preview || "");
          return { id, text };
        }
        return { id: "chunk", text: String(c) };
      });

      // marker scan (future-proof placeholders; best-effort)
      const MARKERS = ["WAVCUE_CMCD:", "WAVCUE:CMCD=", "WVCMCD:"];
      for(const {id, text} of normalizeChunks){
        if(!text) continue;
        for(const m of MARKERS){
          const p = text.indexOf(m);
          if(p >= 0){
            let cand = text.slice(p + m.length).trim();
            const b1 = cand.indexOf("{");
            const b2 = cand.lastIndexOf("}");
            if(b1 >= 0 && b2 > b1) cand = cand.slice(b1, b2 + 1);
            const obj = tryParseJSON(cand);
            if(obj){
              const keysPreview = Object.keys(obj).slice(0, 12);
              console.log("[ARTIFACT][CMCD] found by marker", { fileId, src: `chunk:${id}`, len: cand.length });
              console.log("[CMCD]", "found", { fileId, source: `chunk:${id}`, nonEmptyCount: keysPreview.length, keysPreview });
              return obj;
            }
          }
        }
      }

      // JSON/key-hint scan
      for(const {id, text} of normalizeChunks){
        if(!text || !hasHint(text)) continue;
        const b1 = text.indexOf("{");
        const b2 = text.lastIndexOf("}");
        if(b1 >= 0 && b2 > b1){
          const cand = text.slice(b1, b2 + 1);
          const obj = tryParseJSON(cand);
          if(obj){
            const keysPreview = Object.keys(obj).slice(0, 12);
            console.log("[ARTIFACT][CMCD] found by key-hints", { fileId, src: `chunk:${id}`, len: cand.length });
            console.log("[CMCD]", "found", { fileId, source: `chunk:${id}`, nonEmptyCount: keysPreview.length, keysPreview });
            return obj;
          }
        }
        const kvObj = {};
        text.split(/\r?\n/).forEach(line=>{
          const idx = line.indexOf(":");
          if(idx>0){
            const k = line.slice(0, idx).trim();
            const v = line.slice(idx+1).trim();
            if(k && v) kvObj[k] = v;
          }
        });
        if(Object.keys(kvObj).length){
          const keysPreview = Object.keys(kvObj).slice(0, 12);
          console.log("[CMCD]", "found", { fileId, source: `chunk:${id}`, nonEmptyCount: keysPreview.length, keysPreview });
          return kvObj;
        }
      }

      // XML fallback
      for(const {id, text} of normalizeChunks){
        if(!text) continue;
        const idLower = id.toLowerCase();
        if(!(idLower.includes("ixml") || idLower.includes("axml") || text.includes("<"))){
          continue;
        }
        const m = text.match(/<WAVCUE_CMCD>([\s\S]*?)<\/WAVCUE_CMCD>/i)
          || text.match(/<cmcd>([\s\S]*?)<\/cmcd>/i);
        if(m && m[1]){
          const cand = m[1].trim();
          const obj = tryParseJSON(cand);
          if(obj){
            const keysPreview = Object.keys(obj).slice(0, 12);
            console.log("[ARTIFACT][CMCD] found in XML tag", { fileId, src: `chunk:${id}`, len: cand.length });
            console.log("[CMCD]", "found", { fileId, source: `chunk:${id}`, nonEmptyCount: keysPreview.length, keysPreview });
            return obj;
          }
        }
      }

      console.warn("[CMCD]", "notfound", { fileId, checked: ["chunk","ixml","list","bext"], note: "preserve existing" });
      console.warn("[ARTIFACT][CMCD] not found in textChunks", { fileId });
      return null;
    }catch(e){
      console.warn("[ARTIFACT][CMCD] extractor failed (non-fatal)", e);
      return null;
    }
  };
})();

/* --- normalize rec artifacts (cmcd/pdf) : prevent undefined crash --- */
(function(){
  if (typeof window.normalizeRecArtifacts === "function") return;

  /* --- safe summarize + deep find helpers (no behavior change) --- */
  if (typeof window.safeCloneLite !== "function") {
    window.safeCloneLite = function(obj){
      try{
        if (!obj || typeof obj !== "object") return obj;
        // shallow clone only + drop huge binary-like fields
        const out = Array.isArray(obj) ? obj.slice(0, 50) : {};
        const keys = Object.keys(obj).slice(0, 120);
        for (const k of keys){
          const v = obj[k];
          if (v instanceof ArrayBuffer) continue;
          if (typeof Buffer !== "undefined" && v && v.constructor && v.constructor.name === "Buffer") continue;
          if (Array.isArray(v) && v.length > 2000) { out[k] = v.slice(0, 50); continue; }
          out[k] = v;
        }
        return out;
      }catch(e){ return null; }
    };
  }

  if (typeof window.summarizeKeys !== "function") {
    window.summarizeKeys = function(obj, label){
      try{
        if (!obj || typeof obj !== "object") return;
        const keys = Object.keys(obj);
        console.log("[MIGRATE][KEYS]", label || "", {keyCount: keys.length, keys: keys.slice(0, 60)});
      }catch(e){}
    };
  }

  if (typeof window.deepFindByKey !== "function") {
    window.deepFindByKey = function(root, matcher, maxHits){
      const hits = [];
      const seen = new Set();
      const limit = maxHits || 20;

      function walk(node, path, depth){
        if (!node || typeof node !== "object") return;
        if (seen.has(node)) return;
        seen.add(node);
        if (depth > 5) return;

        const keys = Object.keys(node);
        for (const k of keys){
          const v = node[k];
          const p = path ? (path + "." + k) : k;

          try{
            if (matcher(k, v, p)) {
              hits.push({path: p, key: k, type: Array.isArray(v) ? "array" : typeof v});
              if (hits.length >= limit) return;
            }
          }catch(_){}

          if (v && typeof v === "object"){
            walk(v, p, depth + 1);
            if (hits.length >= limit) return;
          }
        }
      }
      walk(root, "", 0);
      return hits;
    };
  }

  function sliceBytes(buf, start, len){
    try{
      if(!buf) return new Uint8Array();
      const u8 = (buf instanceof Uint8Array) ? buf : new Uint8Array(buf);
      return u8.slice(start, start + len);
    }catch(_){ return new Uint8Array(); }
  }
  function u8StartsWith(u8, asciiString){
    try{
      if(!u8 || !asciiString) return false;
      for(let i=0;i<asciiString.length;i++){
        if(u8[i] !== asciiString.charCodeAt(i)) return false;
      }
      return true;
    }catch(_){ return false; }
  }
  function tryDecodeUtf8(u8, maxLen){
    try{
      const lim = Math.max(0, Math.min(u8.length, maxLen || 65536));
      return new TextDecoder("utf-8", {fatal:false}).decode(u8.slice(0, lim));
    }catch(_){ return ""; }
  }
  function decodeLatin1(u8, maxLen){
    try{
      const lim = Math.max(0, Math.min(u8.length, maxLen || 65536));
      let out = "";
      for(let i=0;i<lim;i++){
        out += String.fromCharCode(u8[i]);
      }
      return out;
    }catch(_){ return ""; }
  }
  function asciiPreview(u8, maxLen){
    try{
      const lim = Math.max(0, Math.min(u8.length, maxLen || 64));
      let out = "";
      for(let i=0;i<lim;i++){
        const ch = u8[i];
        out += (ch >= 0x20 && ch <= 0x7e) ? String.fromCharCode(ch) : ".";
      }
      return out;
    }catch(_){ return ""; }
  }
  function parseInfoSubchunks(u8){
    try{
      const out = {};
      const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
      const u32 = (o)=>dv.getUint32(o,true);
      const str4 = (o)=>String.fromCharCode(u8[o],u8[o+1],u8[o+2],u8[o+3]);
      if(u8.length < 4 || str4(0) !== "INFO") return out;
      let off = 4;
      while(off + 8 <= u8.length){
        const id = str4(off);
        const size = u32(off+4);
        const dataOff = off + 8;
        const end = Math.min(u8.length, dataOff + size);
        const txt = tryDecodeUtf8(u8.slice(dataOff, end), 65536).replace(/\0/g,"").trim();
        if(txt) out[id] = txt;
        off = end + (size % 2);
      }
      return out;
    }catch(_){ return {}; }
  }
  function findPdfChunks(chunks, fileBuf){
    try{
      if(typeof pdfFindAllInWav === "function"){
        const list = pdfFindAllInWav(fileBuf) || [];
        return Array.isArray(list) ? list.slice(0,9) : [];
      }
    }catch(_){ }
    try{
      if(!Array.isArray(chunks)) return [];
      const out = [];
      for(const ch of chunks){
        const id = ch?.id || "";
        const off = ch?.dataOff;
        const size = ch?.size;
        if(!off || !size) continue;
        const u8 = new Uint8Array(fileBuf, off, Math.min(size, 8));
        if(u8StartsWith(u8, "%PDF-")){
          const bytes = new Uint8Array(fileBuf, off, size);
          out.push({ name: "attached.pdf", bytes, kind: "PDF", mime: "application/pdf" });
        }
      }
      return out.slice(0,9);
    }catch(_){ return []; }
  }
  function findCmcdInTextChunks(chunks, fileBuf, fileId){
    try{
      if(!Array.isArray(chunks)) return null;
      const targets = new Set(["axml","iXML","INFO","bext","JUNK","LIST","ID3 ","ICMT","ISFT"]);
      const keys = ["Ver4","Ver","共通コード","素材秒数","素材タイトル","素材略号","素材コード","局内コード","ポスプロコメント","放送局コメント","COMMENT","NOTE","CLIENT"];
      const keyHit = (txt)=> keys.some(k=>txt.includes(k));
      const parseText = (txt, mode, chunkId)=>{
        if(!txt) return null;
        if(!keyHit(txt)) return null;
        try{
          const m = txt.match(/\{[\s\S]*?\}/);
          if(m){
            const obj = JSON.parse(m[0]);
            if(obj && typeof obj === "object"){
              console.log("[ARTIFACT][CMCD]", "found", { fileId, chunkId, mode, keys: Object.keys(obj).slice(0, 12) });
              return obj;
            }
          }
        }catch(_){ }
        const obj = {};
        txt.split(/\r?\n/).forEach(line=>{
          const idx = line.indexOf(":");
          if(idx>0){
            const k = line.slice(0, idx).trim();
            const v = line.slice(idx+1).trim();
            if(k && v) obj[k] = v;
          }
        });
        if(Object.keys(obj).length){
          console.log("[ARTIFACT][CMCD]", "found", { fileId, chunkId, mode, keys: Object.keys(obj).slice(0, 12) });
          return obj;
        }
        return null;
      };
      for(const ch of chunks){
        const id = String(ch?.id || "");
        if(!targets.has(id)) continue;
        const off = ch?.dataOff;
        const size = ch?.size;
        if(!off || !size) continue;
        if(id === "LIST"){
          const listType = tryDecodeUtf8(new Uint8Array(fileBuf, off, Math.min(size, 4)), 4);
          if(listType === "INFO"){
            const u8 = new Uint8Array(fileBuf, off, Math.min(size, 65536));
            const info = parseInfoSubchunks(u8);
            const text = Object.values(info).join("\n");
            const parsed = parseText(text, "info", "LIST:INFO");
            if(parsed) return parsed;
          }
        }
        const u8 = new Uint8Array(fileBuf, off, Math.min(size, 65536));
        const txt = tryDecodeUtf8(u8, 65536);
        const parsedUtf8 = parseText(txt, "utf8", id);
        if(parsedUtf8) return parsedUtf8;
        const latin = decodeLatin1(u8, 65536);
        const parsedLatin = parseText(latin, "latin1", id);
        if(parsedLatin) return parsedLatin;
      }
      // fallback: scan all chunks quickly
      for(const ch of chunks){
        const id = String(ch?.id || "");
        const off = ch?.dataOff;
        const size = ch?.size;
        if(!off || !size) continue;
        const u8 = new Uint8Array(fileBuf, off, Math.min(size, 65536));
        const txt = tryDecodeUtf8(u8, 65536);
        const parsedUtf8 = parseText(txt, "utf8", id);
        if(parsedUtf8) return parsedUtf8;
        const latin = decodeLatin1(u8, 65536);
        const parsedLatin = parseText(latin, "latin1", id);
        if(parsedLatin) return parsedLatin;
      }
    }catch(_){ }
    try{ console.warn("[ARTIFACT][CMCD]", "not found", { fileId }); }catch(_){ }
    return null;
  }
  // --- CMCD parser for artifact scan (D&D full-load) ---
  // NOTE: scanArtifactsFromFile() expects this to exist.
  function cmcdParseFromPayload(u8){
    try{
      if(!u8) return { obj:null, rawText:"" };
      // normalize to exactly 2048 bytes
      const buf = new Uint8Array(2048);
      buf.fill(0);
      if(u8 instanceof Uint8Array){
        buf.set(u8.slice(0, 2048), 0);
      }else{
        // allow ArrayBuffer etc
        const tmp = new Uint8Array(u8);
        buf.set(tmp.slice(0, 2048), 0);
      }

      const obj = {};
      const ver = (buf[0] | (buf[1] << 8)) >>> 0;
      obj["Ver"] = String(ver);

      // CMCD_KEYS / _cmcdSlotForKey / _sjisDecode are declared elsewhere in this file
      if(typeof CMCD_KEYS !== "undefined" && typeof _cmcdSlotForKey === "function"){
        for(const key of CMCD_KEYS){
          if(key === "Ver") continue;
          const sl = _cmcdSlotForKey(key);
          if(!sl) continue;
          const s = sl[0], len = sl[1];
          const raw = buf.slice(s, s + len);
          const end = raw.indexOf(0);
          const cut = (end >= 0) ? raw.slice(0, end) : raw;
          let txt = "";
          try{
            if(typeof _sjisDecode === "function") txt = _sjisDecode(cut);
            else txt = new TextDecoder("utf-8").decode(cut);
          }catch(_e){
            try{ txt = new TextDecoder("utf-8").decode(cut); }catch(_e2){ txt = ""; }
          }
          obj[key] = String(txt || "").replace(/\s+$/g, "");
        }
      }

      // decide whether it's "real" CMCD (ignore Ver-only)
      let hasReal = false;
      for(const k of Object.keys(obj)){
        if(k === "Ver") continue;
        const v = obj[k];
        if(typeof v === "string" && v.trim() !== ""){
          hasReal = true;
          break;
        }
      }
      if(!hasReal){
        return { obj:null, rawText:"" };
      }

      // rawText (debug)
      let rawText = "";
      try{
        if(typeof CMCD_KEYS_UI !== "undefined" && Array.isArray(CMCD_KEYS_UI)){
          rawText = CMCD_KEYS_UI.map(k => `${k}: ${obj[k] || ""}`).join("\n");
        }
      }catch(_){ rawText = ""; }

      return { obj, rawText };
    }catch(e){
      try{ console.warn("[CMCD] cmcdParseFromPayload failed", e); }catch(_){}
      return { obj:null, rawText:"" };
    }
  }
  function scanArtifactsFromFile(fileBuf, chunks, fileId){
    try{
      const chunkIdsSample = Array.isArray(chunks) ? chunks.map(c=>c?.id).filter(Boolean).slice(0, 60) : [];
      try{
        if(Array.isArray(chunks)){
          const sample = chunks.slice(0, 60).map((c)=>{
            const id = c?.id || "";
            const size = c?.size || 0;
            let headAscii = "";
            try{
              if(fileBuf && c?.dataOff != null && size){
                const u8 = new Uint8Array(fileBuf, c.dataOff, Math.min(size, 64));
                headAscii = asciiPreview(u8, 64);
              }
            }catch(_){ }
            return { id, size, headAscii };
          });
          console.log("[ARTIFACT][CHUNKS]", { fileId, count: chunks.length, sample });
          let previewed = 0;
          for(const c of chunks){
            if(previewed >= 10) break;
            const id = String(c?.id || "");
            if(!id) continue;
            const off = c?.dataOff;
            const size = c?.size;
            if(!off || !size) continue;
            const u8 = new Uint8Array(fileBuf, off, Math.min(size, 65536));
            const headAscii = asciiPreview(u8, 64);
            const idLower = id.toLowerCase();
            const candidate = ["ixml","axml","list","info","bext","junk","id3 ","icmt","isft"].some(k=>idLower.includes(k))
              || headAscii.includes("{") || headAscii.includes("Ver") || headAscii.includes("cmcd") || headAscii.includes("素材");
            if(candidate){
              const headText = tryDecodeUtf8(u8, 300).slice(0, 300);
              console.log("[ARTIFACT][PREVIEW]", { fileId, id, headText });
              previewed += 1;
            }
          }
        }
      }catch(_){ }
      let cmcdInputs = null;
      let cmcdText = "";
      try{
        if(Array.isArray(chunks)){
          const cmcdChunk = chunks.find(c=>c && c.id==="cmcd");
          if(cmcdChunk && fileBuf){
            const u8 = new Uint8Array(fileBuf, cmcdChunk.dataOff, Math.min(cmcdChunk.size, 2048));
            if(typeof cmcdParseFromPayload === "function"){
              const parsed = cmcdParseFromPayload(u8);
              cmcdInputs = parsed?.obj || null;
              cmcdText = parsed?.rawText || "";
            }
          }
        }
      }catch(_){ }
      if(!cmcdInputs){
        try{
          const textChunks = [];
          if(Array.isArray(chunks)){
            for(const ch of chunks.slice(0, 60)){
              const id = String(ch?.id || "");
              const off = ch?.dataOff;
              const size = ch?.size;
              if(!id || !off || !size) continue;
              const u8 = new Uint8Array(fileBuf, off, Math.min(size, 65536));
              const fullText = tryDecodeUtf8(u8, 65536);
              const headText = fullText.slice(0, 300);
              textChunks.push({ id, text: fullText, headText });
              if(id === "LIST"){
                const listType = tryDecodeUtf8(new Uint8Array(fileBuf, off, Math.min(size, 4)), 4);
                if(listType === "INFO"){
                  const info = parseInfoSubchunks(u8);
                  const text = Object.values(info).join("\n");
                  textChunks.push({ id: "LIST:INFO", text });
                }
              }
            }
          }
          if(typeof window.findCmcdInTextChunks === "function"){
            cmcdInputs = window.findCmcdInTextChunks(textChunks, fileId);
          }else{
            console.warn("[ARTIFACT][CMCD] findCmcdInTextChunks missing (scan)");
          }
        }catch(_){ }
      }
      const attachments = findPdfChunks(chunks, fileBuf);
      const cmcdLen = (()=>{ try{ return cmcdInputs ? JSON.stringify(cmcdInputs).length : 0; }catch(_){ return 0; } })();
      console.log("[ARTIFACT]", "scan", { fileId, pdfFound: attachments.length, cmcdFound: !!cmcdInputs, cmcdLen, chunkIdsSample });
      return { cmcdInputs, cmcdText, attachments };
    }catch(_){
      return { cmcdInputs: null, cmcdText: "", attachments: [] };
    }
  }
  window._artifactScan = window._artifactScan || scanArtifactsFromFile;

  window.normalizeRecArtifacts = function(rec, stateLike){
    try{
      if (!rec || typeof rec !== "object") return rec;

      // cmcd: normalize to string
      if (typeof rec.cmcd !== "string") {
        const cand =
          (rec.cmcd != null) ? rec.cmcd :
          rec.cmcdText ?? rec.cmcdValue ??
          rec.meta?.cmcd ?? rec.bwfj?.cmcd ??
          stateLike?.cmcd ?? stateLike?.meta?.cmcd ?? "";
        if(cand){
          rec.cmcd = (typeof cand === "string") ? cand : String(cand);
        }else if(rec.cmcd == null){
          rec.cmcd = "";
        }
      }

      // attachments: normalize to array
      if (!Array.isArray(rec.attachments)) {
        const ac =
          rec.attachments ??
          rec.pdfs ?? rec.pdfAttachments ?? rec.attachedPdfs ??
          rec.meta?.attachments ?? rec.meta?.pdfs ??
          rec.bwfj?.attachments ?? rec.bwfj?.pdfs ??
          stateLike?.attachments ?? stateLike?.pdfs ?? [];
        rec.attachments = Array.isArray(ac) ? ac : (ac ? [ac] : []);
      }

      console.log("[MIGRATE]", "normalizeRecArtifacts", {
        fileId: rec.fileId || rec.id || null,
        cmcdLen: rec.cmcd ? rec.cmcd.length : 0,
        pdfCount: rec.attachments ? rec.attachments.length : 0
      });
      return rec;
    }catch(e){
      console.error("[MIGRATE]", "normalizeRecArtifacts:error", e);
      return rec;
    }
  };
})();

/*
[REGRESSION CHECKLIST - DO NOT BREAK]
1) Multi D&D: drop 4 files -> logs show fullLoad done for all -> then all done.
2) Switch active file: waveform + cue list + cue badge update WITHOUT any click.
3) Cue edit on waveform: move/add/delete -> cue list + badge update immediately.
4) Cue edit on list: time edit/delete -> waveform + badge update immediately.
5) No console red errors (ReferenceError / Uncaught(in promise)).
*/

/* --- WavCue: UI hard refresh + safe helpers (do not throw) --- */
(function(){
  if (typeof window.safeCall !== "function") {
    window.safeCall = function(fn, ...args){
      try{
        if (typeof fn === "function") return fn(...args);
      }catch(e){
        console.error("[safeCall] failed", e);
      }
    };
  }

  if (typeof window.getState !== "function") {
    window.getState = function(){
      try{
        if (!window.state || typeof window.state !== "object") window.state = {};
        return window.state;
      }catch(e){
        console.error("[getState] failed, fallback {}", e);
        window.state = {};
        return window.state;
      }
    };
    try{ window.getState(); }catch(_){}
  }

  if (typeof window.requestFullRefresh !== "function") {
    window.requestFullRefresh = function(reason){
      try{
        const r1 = ()=>{
          // try common render/update functions if they exist
          window.safeCall(window.refreshUI);
          window.safeCall(window.refreshUIFromRec);
          window.safeCall(window.forceRedraw);
          window.safeCall(window.renderWaveform);
          window.safeCall(window.renderCueList);
          window.safeCall(window.updateBadges);
        };
        const r2 = ()=>{ // second frame to flush layout/paint dependencies
          window.safeCall(window.forceRedraw);
          window.safeCall(window.renderWaveform);
          window.safeCall(window.renderCueList);
          window.safeCall(window.updateBadges);
        };
        if (typeof window.diagLog === "function") window.diagLog("[UI]", "requestFullRefresh", window.diagState({ reason }));
        console.log("[UI] requestFullRefresh", reason);
        requestAnimationFrame(()=>{ r1(); requestAnimationFrame(r2); });
      }catch(e){
        console.error("[UI] requestFullRefresh failed", e);
        if (typeof window.diagErr === "function") window.diagErr("[UI]", "requestFullRefresh failed", e);
      }
    };
  }
})();

/* --- WavCue: unified commitAll (never throw) --- */
(function(){
  if (typeof window.commitAll === "function") return;

  window.commitAll = function(reason, opts){
    try{
      // prefer "all edits" commits if exist
      if (typeof window.commitEdits === "function") window.commitEdits(reason, opts);
      else if (typeof window.commitEdit === "function") window.commitEdit(reason, opts);
      else if (typeof window.saveEdits === "function") window.saveEdits(reason, opts);
      else if (typeof window.commitCues === "function") window.commitCues(reason, opts);
      else if (typeof window.commitCueEdits === "function") window.commitCueEdits(reason, opts);
      else console.warn("[commitAll] no commit function found", reason, opts);

      // badges + repaint
      window.safeCall(window.updateBadges);
      if (typeof window.requestFullRefresh === "function") window.requestFullRefresh("commitAll:" + (reason||""));
      console.log("[commitAll]", reason, opts || {});
      if (typeof window.diagLog === "function") window.diagLog("[commitAll]", reason || "", window.diagState(opts || {}));
    }catch(e){
      console.error("[commitAll] failed", e);
      if (typeof window.diagErr === "function") window.diagErr("[commitAll]", "failed", e);
      try{ if (typeof window.requestFullRefresh==="function") window.requestFullRefresh("commitAll:error"); }catch(_){}
    }
  };
})();

/* Utils */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function fourccToU32(s){
  const b0=s.charCodeAt(0)&255, b1=s.charCodeAt(1)&255, b2=s.charCodeAt(2)&255, b3=s.charCodeAt(3)&255;
  return ((b0) | (b1<<8) | (b2<<16) | (b3<<24)) >>> 0;
}


// ----- Diagnostics helpers -----
function _errMsg(err){
  try{ return (err && err.message) ? String(err.message) : String(err); }catch(_){ return String(err); }
}
function logError(userMsg, err, level="ERROR"){
  // userMsg: short, Japanese
  // err: detailed
  try{ log(`${level}: ${userMsg}`); }catch(_){}
  try{ log(`DETAIL: ${_errMsg(err)}`); }catch(_){}
  try{ console.error(userMsg, err); }catch(_){}
  try{ safeToast(userMsg, level==="ERROR" ? "err" : "warn", 3200); }catch(_){}
}
function _makeAbortError(msg="Aborted"){
  try{ return new DOMException(msg, "AbortError"); }catch(_){ const e=new Error(msg); e.name="AbortError"; return e; }
}
function _ensureNotCancelled(sig){
  try{
    if(sig && sig.aborted) throw _makeAbortError();
  }catch(err){ throw err; }
}

// ----- Container validation (early fail for RF64/W64/invalid RIFF size) -----
function detectWavContainer(ab){
  try{
    if(!(ab instanceof ArrayBuffer)) return {ok:false, kind:"unknown", reason:"バッファ形式が不正です"};
    if(ab.byteLength < 16) return {ok:false, kind:"unknown", reason:"ファイルが小さすぎます"};
    const dv = new DataView(ab);
    const str4=(o)=>String.fromCharCode(dv.getUint8(o),dv.getUint8(o+1),dv.getUint8(o+2),dv.getUint8(o+3));
    const id0 = str4(0);
    const wave = str4(8);
    if(id0==="RF64") return {ok:false, kind:"RF64", reason:"RF64（64bit RIFF）形式は現在未対応です"};
    if(id0==="RIFX") return {ok:false, kind:"RIFX", reason:"RIFX（ビッグエンディアンRIFF）形式は現在未対応です"};
    if(id0==="RIFF"){
      if(wave!=="WAVE") return {ok:false, kind:"RIFF", reason:"RIFFですがWAVE形式ではありません"};
      const riffSize = dv.getUint32(4, true) >>> 0;
      const expected = riffSize + 8;
      // allow some writers to pad/ignore size; but huge mismatch is suspicious
      const delta = Math.abs(expected - ab.byteLength);
      if(expected > ab.byteLength + 16) return {ok:false, kind:"RIFF", reason:"RIFFサイズがファイル長を超えています（破損の可能性）"};
      if(delta > 8*1024*1024 && expected < ab.byteLength - 16) return {ok:false, kind:"RIFF", reason:"RIFFサイズが不自然です（破損の可能性）"};
      return {ok:true, kind:"RIFF", reason:""};
    }
    // best-effort Wave64 detection: starts with 'riff' (lowercase) on some dumps; treat as unsupported
    if(id0==="riff" || id0==="W64 "){
      return {ok:false, kind:"W64", reason:"W64（Wave64）形式の可能性があります（現在未対応）"};
    }
    return {ok:false, kind:"unknown", reason:"RIFF/WAVE形式ではありません（RF64/W64などの可能性）"};
  }catch(err){
    return {ok:false, kind:"unknown", reason:`ヘッダ解析に失敗: ${_errMsg(err)}`};
  }
}
// ----- fmt validation (BWF-J: Linear PCM only) -----
function detectPcmFromFmtPayload(fmtPayload){
  try{
    if(!fmtPayload || fmtPayload.byteLength < 16) return {ok:false, tag:null, reason:"fmtチャンクが見つからない/不正です"};
    const dv = new DataView(fmtPayload.buffer, fmtPayload.byteOffset, fmtPayload.byteLength);
    const tag = dv.getUint16(0, true) >>> 0;
    // WAVE_FORMAT_PCM = 0x0001
    if(tag === 0x0001) return {ok:true, tag, kind:"PCM", reason:""};
    // WAVE_FORMAT_EXTENSIBLE = 0xFFFE (accept only PCM subformat)
    if(tag === 0xFFFE){
      if(fmtPayload.byteLength >= 40){
        const guidOff = 24; // SubFormat GUID (WAVEFORMATEXTENSIBLE)
        const g = new Uint8Array(fmtPayload.buffer, fmtPayload.byteOffset + guidOff, 16);
        const PCM_GUID   = [0x01,0x00,0x00,0x00, 0x00,0x00,0x10,0x00, 0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71];
        const FLOAT_GUID = [0x03,0x00,0x00,0x00, 0x00,0x00,0x10,0x00, 0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71];
        const eq = (arr)=> arr.length===16 && arr.every((v,i)=> (g[i]===v));
        if(eq(PCM_GUID)) return {ok:true, tag, kind:"PCM_EXT", reason:""};
        if(eq(FLOAT_GUID)) return {ok:false, tag, kind:"FLOAT_EXT", reason:"IEEE Float（拡張fmt）は現在未対応です"};
        return {ok:false, tag, kind:"EXT", reason:"PCM以外の拡張fmt形式は現在未対応です"};
      }
      return {ok:false, tag, kind:"EXT", reason:"拡張fmt（WAVE_FORMAT_EXTENSIBLE）の解析情報が不足しています"};
    }
    // IEEE float
    if(tag === 0x0003) return {ok:false, tag, kind:"FLOAT", reason:"IEEE Float形式は現在未対応です"};
    return {ok:false, tag, kind:"NONPCM", reason:`PCM以外の形式（format=${tag}）は現在未対応です`};
  }catch(err){
    return {ok:false, tag:null, kind:"unknown", reason:`fmt解析に失敗: ${_errMsg(err)}`};
  }
}

// ----- Diagnostics log -----
function collectDiagnosticText(extraLines=[]){
  const lines = [];
  lines.push(`WavCue ${APP_VERSION}`);
  lines.push(`time: ${new Date().toISOString()}`);
  if(state.fileName) lines.push(`file: ${state.fileName}`);
  if(state.fileSr) lines.push(`src sampleRate(fmt): ${state.fileSr}`);
  if(state.sr) lines.push(`decoded sampleRate(WebAudio): ${state.sr}`);
  try{
    const cueN = Array.isArray(state.cues) ? state.cues.length : 0;
    const lblN = Array.isArray(state.cues) ? state.cues.filter(c=>String(c.label||"").trim()).length : 0;
    lines.push(`cues: ${cueN} (labeled: ${lblN})`);
  }catch(_){}
  try{
    const atts = Array.isArray(state.attachments) ? state.attachments : [];
    lines.push(`attachments: ${atts.length}`);
    if(atts.length){
      lines.push("attachmentSlots:");
      for(let i=0;i<atts.length;i++){
        const a = atts[i] || {};
        const kind = a.kind || _fileKindFromName(a.name) || _fileKindFromMime(a.mime) || "FILE";
        const bytes = (a.bytes && a.bytes.length) ? a.bytes.length : 0;
        const nm = a.name || "attached";
        lines.push(`  #${i+1}: ${nm} (${kind}, ${bytes.toLocaleString()} bytes)`);
      }
    }
  }catch(_){}
  try{
    const chunks = state.srcChunks;
    if(Array.isArray(chunks)){
      const ids = chunks.map(ch=> ch.id + (ch.id==="LIST" ? `:${ch.listType||"????"}` : "")).join(", ");
      lines.push(`chunks: ${ids}`);
      // unknown count
      const known = new Set(["bext","fmt ","data","iXML","cmcd","cue ","plst","LIST:adtl"]);
      const unknown = chunks.filter(ch=>{
        const k = (ch.id==="LIST") ? `LIST:${ch.listType||""}` : ch.id;
        return !known.has(k);
      });
      lines.push(`unknownChunks: ${unknown.length}`);
    }
  }catch(_){}
  try{
    if(typeof state.loadedCueSig==="string") lines.push(`loadedCueSig: ${state.loadedCueSig}`);
  }catch(_){}
  for(const l of (extraLines||[])) lines.push(String(l));
  return lines.join("\n");
}
async function copyTextToClipboard(text){
  try{
    await navigator.clipboard.writeText(text);
    safeToast("診断ログをコピーしました", "ok", 2200);
    return true;
  }catch(err){
    // fallback: textarea
    try{
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position="fixed";
      ta.style.left="-9999px";
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      safeToast(ok ? "診断ログをコピーしました" : "コピーに失敗しました", ok?"ok":"warn", 2600);
      return ok;
    }catch(_){
      safeToast("コピーに失敗しました", "warn", 2600);
      return false;
    }
  }
}


/* ===============================
   AUDIO_PARSE: RIFF/WAVE reader
================================ */

function parseRiffChunks(ab){
  try{
    const dv=new DataView(ab);
    const u32=(o)=>dv.getUint32(o,true);
    const str4=(o)=>String.fromCharCode(dv.getUint8(o),dv.getUint8(o+1),dv.getUint8(o+2),dv.getUint8(o+3));
    if(dv.byteLength<12) return null;
    if(str4(0)!=="RIFF" || str4(8)!=="WAVE") return null;
    const out=[];
    let off=12;
    while(off+8<=dv.byteLength){
      const id=str4(off);
      const size=u32(off+4);
      const dataOff=off+8;
      const next=dataOff + size + (size%2);
      const item={id,size,off,dataOff,next};
      if(id==="LIST" && dataOff+4<=dv.byteLength) item.listType=str4(dataOff);
      out.push(item);
      off=next;
    }
    return out;
  }catch(_){ return null; }
}
function rebuildWaveFromOriginalCanonical(origAb, chunks, replacements){
  const src = new Uint8Array(origAb);

  // 12byte RIFF header placeholder
  const riff = new ArrayBuffer(12);
  const dv = new DataView(riff);
  _writeStr(dv, 0, "RIFF");
  dv.setUint32(4, 0, true);
  _writeStr(dv, 8, "WAVE");

  const out = [new Uint8Array(riff)];
  const push = (ab)=>{
    if(!ab) return;
    const u8 = (ab instanceof Uint8Array) ? ab : new Uint8Array(ab);
    out.push(u8);
    if(u8.length % 2) out.push(new Uint8Array([0]));
  };
  const keyOf = (ch)=>{
    const id = ch.id;
    if(id==="LIST"){
      const t = _readStr(src, ch.dataOff, 4);
      return `LIST:${t}`;
    }
    return id;
  };

  // collect extras (unknown chunks) to keep, excluding canonical targets
  const canonicalKeys = new Set([
    "bext","fmt ","data","iXML","cmcd","cue ","plst","LIST:adtl"
  ]);

  const extras = [];
  for(const ch of chunks){
    const k = keyOf(ch);
    if(!canonicalKeys.has(k)){
      // keep other LIST types too (e.g. INFO) as extras
      const raw = src.slice(ch.off, ch.off + 8 + ch.size + (ch.size%2));
      extras.push(raw);
    }
  }

  // canonical order
  if(replacements.bextBuf) push(replacements.bextBuf);
  if(replacements.fmtBuf) push(replacements.fmtBuf);
  if(replacements.ixmlBuf) push(replacements.ixmlBuf);
  if(replacements.dataBuf) push(replacements.dataBuf);
  if(replacements.cmcdBuf) push(replacements.cmcdBuf);
  if(replacements.cueBuf) push(replacements.cueBuf);
  if(replacements.plstBuf) push(replacements.plstBuf);
  if(replacements.listBuf) push(replacements.listBuf);

  // extras appended last (preserve unknown chunks)
  for(const ex of extras) push(ex);

  const total = out.reduce((a,b)=>a+b.length,0);
  dv.setUint32(4, total-8, true);
  out[0] = new Uint8Array(riff);
  return new Blob(out, {type:"audio/wav"});
}

function rebuildWaveFromOriginal(ab, chunks, replacements){
  const out=[];
  const push=(b)=>out.push(b);

  // RIFF header placeholder
  const riff=new Uint8Array(12);
  riff.set([82,73,70,70, 0,0,0,0, 87,65,86,69]);
  push(riff.buffer);

  const preExtras = [];
  const postExtras = [];
  const ixmlChunks = [];
  let sawData = false;

  const pickRep = (key)=>(
    (key==="fmt ")?(replacements && replacements.fmtBuf):
    (key==="data")?(replacements && replacements.dataBuf):
    (key==="cue ")?(replacements && replacements.cueBuf):
    (key==="plst")?(replacements && replacements.plstBuf):
    (key==="LIST:adtl")?(replacements && replacements.listBuf):
    (key==="bext")?(replacements && replacements.bextBuf):
    (key==="cmcd")?(replacements && replacements.cmcdBuf):
    null
  );

  const dataSlot = { buf:null };
  const metaSlots = { bext:null, fmt:null, cmcd:null, cue:null, plst:null, list:null };

  for(const ch of (chunks||[])){
    const key = (ch.id==="LIST" && ch.listType==="adtl") ? "LIST:adtl" : ch.id;
    if(key==="data"){
      if(!dataSlot.buf){
        dataSlot.buf = pickRep(key) || ab.slice(ch.off, ch.next);
      }
      sawData = true;
      continue;
    }

    if(key==="iXML"){
      ixmlChunks.push(ab.slice(ch.off, ch.next));
      continue;
    }

    const slotKey =
      (key==="bext") ? "bext" :
      (key==="fmt ") ? "fmt" :
      (key==="cmcd") ? "cmcd" :
      (key==="cue ") ? "cue" :
      (key==="plst") ? "plst" :
      (key==="LIST:adtl") ? "list" :
      null;
    if(slotKey){
      if(!metaSlots[slotKey]){
        metaSlots[slotKey] = pickRep(key) || ab.slice(ch.off, ch.next);
      }
      continue;
    }

    const raw = ab.slice(ch.off, ch.next);
    if(sawData) postExtras.push(raw);
    else preExtras.push(raw);
  }

  if(replacements){
    if(!metaSlots.bext && replacements.bextBuf) metaSlots.bext = replacements.bextBuf;
    if(!metaSlots.fmt && replacements.fmtBuf) metaSlots.fmt = replacements.fmtBuf;
    if(!dataSlot.buf && replacements.dataBuf) dataSlot.buf = replacements.dataBuf;
    if(!metaSlots.cmcd && replacements.cmcdBuf) metaSlots.cmcd = replacements.cmcdBuf;
    if(!metaSlots.cue && replacements.cueBuf) metaSlots.cue = replacements.cueBuf;
    if(!metaSlots.plst && replacements.plstBuf) metaSlots.plst = replacements.plstBuf;
    if(!metaSlots.list && replacements.listBuf) metaSlots.list = replacements.listBuf;
  }

  if(metaSlots.bext) push(metaSlots.bext);
  if(metaSlots.fmt) push(metaSlots.fmt);
  for(const x of ixmlChunks) push(x);
  for(const ex of preExtras) push(ex);
  if(dataSlot.buf) push(dataSlot.buf);
  if(metaSlots.cmcd) push(metaSlots.cmcd);
  if(metaSlots.cue) push(metaSlots.cue);
  if(metaSlots.plst) push(metaSlots.plst);
  if(metaSlots.list) push(metaSlots.list);
  for(const ex of postExtras) push(ex);

  let total=0;
  for(const b of out) total += b.byteLength;
  const riffSize = total - 8;
  new DataView(out[0]).setUint32(4, riffSize, true);

  return new Blob(out, {type:"audio/wav"});
}

function fmtTime(sec){
  if(!isFinite(sec)) sec = 0;
  const s = Math.max(0, sec);
  const m = Math.floor(s/60);
  const r = s - m*60;
  return `${String(m).padStart(2,"0")}:${r.toFixed(3).padStart(6,"0")}`;
}

function parseTimeInput(text){
  const s = (text ?? "").toString().trim();
  if(!s) return null;

  // 12.34 (seconds)
  if(!s.includes(":")){
    const v = Number(s);
    if(Number.isFinite(v)) return v;
  }

  // mm:ss(.fff) / hh:mm:ss(.fff)
  const parts = s.split(":").map(p=>p.trim());
  if(parts.length < 2 || parts.length > 3) return null;

  const last = Number(parts[parts.length-1]);
  const mid  = Number(parts[parts.length-2]);
  const first = parts.length === 3 ? Number(parts[0]) : 0;

  if(!Number.isFinite(last) || !Number.isFinite(mid) || !Number.isFinite(first)) return null;

  const sec = (first*3600) + (mid*60) + last;
  if(!Number.isFinite(sec)) return null;
  return sec;
}

function _getCueById(id){
  return state.cues.find(c=>c.id===id) || null;
}

function moveCueToTime(cueId, targetSec, jumpAfter, commitReason="cue:move"){
  const cue = _getCueById(cueId);
  if(!cue || !state.buffer) return;
  if(isDemoEditLocked()){ warnDemoLocked(); return; }

  const dur = state.buffer.duration || 0;
  let t = clamp(targetSec, 0, dur);

  const isPair = (cue.label==="BC$STANDBY" || cue.label==="BC$END");
  if(state.linkPair && isPair){
    const otherLabel = (cue.label==="BC$STANDBY") ? "BC$END" : "BC$STANDBY";
    const other = state.cues.find(c=>c.label===otherLabel) || null;
    if(other){
      // 両方が範囲内に収まるようにdeltaをクランプ
      let delta = t - cue.sec;
      const minDelta = Math.max(-cue.sec, -other.sec);
      const maxDelta = Math.min(dur - cue.sec, dur - other.sec);
      delta = clamp(delta, minDelta, maxDelta);

      cue.sec = clamp(cue.sec + delta, 0, dur);
      other.sec = clamp(other.sec + delta, 0, dur);
    }else{
      cue.sec = t;
    }
  }else{
    cue.sec = t;
  }

  // UI更新
  renderCues();
  _forceWaveRedraw();

  if(jumpAfter){
    setPlayhead(cue.sec);
    ensureVisibleSec(cue.sec);
    _forceWaveRedraw();
  }

  log(`CUE: ${cue.label} を ${fmtTime(cue.sec)} に移動${(state.linkPair && isPair) ? "（連動）" : ""}`);
  try{
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    console.log("[CUE] move", { id: cue.id, label: cue.label, sec: cue.sec, fileId: activeId });
    if (typeof window.diagLog === "function") window.diagLog("[CUE]", "move", window.diagState({ id: cue.id, label: cue.label, sec: cue.sec, fileId: activeId }));
  }catch(_){}
  if(typeof window.commitAll === "function"){
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    window.commitAll(commitReason, {fileId: activeId});
  }
}

function _commitTimeEdit(cueId, inputEl){
  const t = parseTimeInput(inputEl.value);
  if(t===null){
    const cue = _getCueById(cueId);
    if(cue) inputEl.value = fmtTime(cue.sec);
    return;
  }
  moveCueToTime(cueId, t, true, "cue:list:edit");
}




function currentPlayheadSec(){
  if(state.isPlaying && state.audioEl) return state.audioEl.currentTime || 0;
  return state.playheadSec || 0;
}
function setStatus(text, kind="idle"){
  $("statusPill").textContent = text;
  $("statusPill").style.borderColor =
    kind==="ok" ? "rgba(126,231,162,.45)" :
    kind==="err" ? "rgba(251,113,133,.45)" :
    kind==="warn" ? "rgba(251,191,36,.45)" : "rgba(148,163,184,.22)";
}

/* Drag & Drop (from scratch) */
function setupDragAndDrop(){
  const overlay = $("dropOverlay");
  const show = ()=>{ overlay?.classList.add("show"); };
  const hide = ()=>{ overlay?.classList.remove("show"); };
  const isWav = (f)=> f && (
    f.type==="audio/wav" || f.type==="audio/wave" ||
    f.name.toLowerCase().endsWith(".wav") || f.name.toLowerCase().endsWith(".wave")
  );

  // Prevent default browser navigation on file drop (open in new tab)
  // capture:true ensures we run before the browser default
  const guard = (e)=>{ e.preventDefault(); };
  window.addEventListener("dragover", guard, {capture:true, passive:false});
  window.addEventListener("drop", guard, {capture:true, passive:false});

  window.addEventListener("dragenter", (e)=>{
    if(e.dataTransfer?.types?.includes("Files")) show();
  }, {passive:true});
  window.addEventListener("dragover", (e)=>{
    if(e.dataTransfer?.types?.includes("Files")) show();
  }, {passive:true});
  window.addEventListener("dragleave", (e)=>{
    if(e.target === document.documentElement || e.target === document.body) hide();
  }, {passive:true});

  const onDrop = async (e)=>{
    try{
      e.preventDefault();
      hide();
      const dt = e.dataTransfer;
      const files = [];
      if(dt?.files && dt.files.length){
        for(const f of dt.files) if(isWav(f)) files.push(f);
      }else if(dt?.items && dt.items.length){
        for(const item of dt.items){
          if(item.kind==="file"){
            const f = item.getAsFile();
            if(f && isWav(f)) files.push(f);
          }
        }
      }
      if(!files.length){ return; }
      if(files.length > 1){
        const gate = guardBulkImport({ count: files.length, source: "dnd" });
        if(!gate.ok){
          if(window.safeToast) window.safeToast(LICENSE_TEXT.bulkImportPro, "warn");
          return;
        }
      }
      console.log(`[Pro] drop wavs=${files.length}`);
      const add = window.__wavcueProAddFiles;
      if(typeof add === "function"){
        await add(files);
        console.log(`[Pro] drop add completed count=${files.length}`);
      }else{
        await loadFile(files[0]);
      }
    }catch(err){
      console.error("[DND] drop failed", err);
      if (typeof window.diagErr === "function") window.diagErr("[DND]", "drop failed", err);
    }
  };

  window.addEventListener("drop", onDrop, {passive:false});
  overlay?.addEventListener("click", ()=> hide());
}


/* WAV cue reader (RIFF/WAVE)
   - Reads existing cue points (cue ) and labels (LIST/adtl/labl)
   - Returns array of {id,label,sec}
*/
function parseWavCues(arrayBuffer, srForSec){
  try{
    const dv = new DataView(arrayBuffer);
    const u32 = (o)=> dv.getUint32(o, true);
    const str4 = (o)=> String.fromCharCode(dv.getUint8(o),dv.getUint8(o+1),dv.getUint8(o+2),dv.getUint8(o+3));
    if(dv.byteLength < 12) return [];
    if(str4(0)!=="RIFF") return [];
    if(str4(8)!=="WAVE") return [];

    let off = 12;

    // NOTE: Mapだと同一IDが上書きされるため、配列で保持（重複を失わない）
    const cuePoints = [];         // [{ id, sampleOffset, _i }]
    const labels = new Map();     // id -> text（重複IDは同一ラベルでOK）

    let seq = 0;

    while(off + 8 <= dv.byteLength){
      const id = str4(off);
      const size = u32(off+4);
      const dataOff = off + 8;
      const next = dataOff + size + (size % 2);

      if(id === "cue "){
        if(dataOff + 4 <= dv.byteLength){
          const n = u32(dataOff);
          let p = dataOff + 4;
          for(let i=0;i<n;i++){
            if(p + 24 > dv.byteLength) break;
            const cueId = u32(p) >>> 0;
            const sampleOffset = u32(p+20) >>> 0;
            cuePoints.push({ id: cueId, sampleOffset, _i: seq++ });
            p += 24;
          }
        }
      }else if(id === "LIST"){
        if(dataOff + 4 <= dv.byteLength){
          const listType = str4(dataOff);
          if(listType === "adtl"){
            let p = dataOff + 4;
            const limit = Math.min(dataOff + size, dv.byteLength);
            while(p + 8 <= limit){
              const sid = str4(p);
              const ssize = u32(p+4);
              const sdata = p + 8;
              const snext = sdata + ssize + (ssize % 2);
              if(snext > limit) break;

              if(sid === "labl"){
                if(sdata + 4 <= dv.byteLength){
                  const cueId = u32(sdata) >>> 0;
                  const maxLen = Math.max(0, Math.min(ssize - 4, dv.byteLength - (sdata+4)));
                  const bytes = new Uint8Array(arrayBuffer, sdata + 4, maxLen);
                  let end = bytes.length;
                  for(let i=0;i<bytes.length;i++){ if(bytes[i]===0){ end=i; break; } }
                  const txt = _sjisDecode(bytes.slice(0,end));
                  if(txt) labels.set(cueId, txt);
                }
              }
              p = snext;
            }
          }
        }
      }

      off = next;
    }

    if(cuePoints.length === 0) return [];
    const sr = srForSec || 48000;

    const out = cuePoints.map(cp=>({
      id: cp.id,
      label: labels.get(cp.id) || "CUE",
      sec: (cp.sampleOffset / sr),
      _i: cp._i
    }));

    out.sort((a,b)=> (a.sec-b.sec) || (a._i-b._i));
    for(const c of out) delete c._i;
    return out;

  }catch(err){
    // parsing failures are non-fatal
    try{ log(`INFO: 既存CUE解析に失敗（無視）: ${err?.message || err}`); }catch(_){}
    return [];
  }
}

// === ID SAFE: normalize cue IDs (keep original when possible; remap only 0/duplicates) ===
function normalizeCueIds(cues){
  const list = Array.isArray(cues) ? cues : [];
  const used = new Set();
  const out = [];
  let next = 1;

  const alloc = ()=>{
    while(next===0 || used.has(next)) next++;
    const id = next >>> 0;
    used.add(id);
    next++;
    return id;
  };

  for(const c of list){
    let id = (c && isFinite(c.id)) ? (c.id>>>0) : 0;
    if(id!==0 && !used.has(id)){
      used.add(id);
      out.push({ ...c, id });
    }else{
      const newId = alloc();
      out.push({ ...c, id: newId });
    }
  }
  return out;
}



/* ===== Cue meta for in-place move (hybrid export) ===== */
function cueSig(cues){
  return (Array.isArray(cues)?cues:[])
    .map(c=>`${(c.id>>>0)}|${String(c.label||"")}`)
    .sort()
    .join(";;");
}

// Returns list of meta for every 'cue ' chunk found in the source WAV.
// Each meta has entries: Map<cueId,{posOff,sampleOff}> where offsets are absolute file offsets.
function extractCuePatchMeta(ab){
  try{
    const dv = new DataView(ab);
    const u32 = (o)=> dv.getUint32(o, true);
    const str4 = (o)=> String.fromCharCode(dv.getUint8(o),dv.getUint8(o+1),dv.getUint8(o+2),dv.getUint8(o+3));
    if(dv.byteLength < 12) return null;
    if(str4(0)!=="RIFF") return null;

    let off = 12;
    const metas = [];
    while(off + 8 <= dv.byteLength){
      const id = str4(off);
      const size = u32(off+4);
      const dataOff = off + 8;
      const next = dataOff + size + (size % 2);
      if(id === "cue " && dataOff + 4 <= dv.byteLength){
        const n = u32(dataOff);
        let p = dataOff + 4;
        const entries = new Map();
        for(let i=0;i<n;i++){
          if(p + 24 > dv.byteLength) break;
          const cueId = u32(p);
          // Structure: dwName, dwPosition, fccChunk, dwChunkStart, dwBlockStart, dwSampleOffset
          entries.set(cueId, { posOff: p+4, sampleOff: p+20 });
          p += 24;
        }
        metas.push({ chunkOff: off, dataOff, size, count: n, entries });
      }
      off = next;
    }
    return metas.length ? metas : null;
  }catch(_){ return null; }
}

// In-place patch: update existing 'cue ' chunk(s) sample offsets for cue IDs.
// Only updates numeric fields; does not change chunk size/order.
function applyCueInPlacePatch(origAb, cueMetaList, cues, sampleRate){
  try{
    if(!origAb || !cueMetaList || !Array.isArray(cueMetaList) || !cueMetaList.length) return origAb;
    if(!Array.isArray(cues) || !cues.length) return origAb;

    const outU8 = new Uint8Array(origAb.slice(0)); // copy
    const dv = new DataView(outU8.buffer);
    const sr = (sampleRate && isFinite(sampleRate)) ? sampleRate
      : ((state && state.fileSr && isFinite(state.fileSr)) ? state.fileSr : (state && state.sr ? state.sr : 48000));
    let maxSamp = 0x7fffffff;
    try{
      if(state && state.fileTotalSamples && isFinite(state.fileTotalSamples)) maxSamp = state.fileTotalSamples;
      else if(state && state.srcDataPayload && state.fileBlockAlign && isFinite(state.fileBlockAlign) && state.fileBlockAlign>0) maxSamp = Math.floor(state.srcDataPayload.byteLength / state.fileBlockAlign);
      else if(state && state.buffer && Number.isFinite(state.buffer.length)) maxSamp = state.buffer.length;
    }catch(_){ maxSamp = 0x7fffffff; }

    for(const c of cues){
      const id = (c.id>>>0);
      const samp = clamp(Math.round((c.sec||0) * sr), 0, maxSamp) >>> 0;
      for(const meta of cueMetaList){
        const e = meta.entries.get(id);
        if(!e) continue;
        // Write both dwPosition and dwSampleOffset for broad compatibility
        dv.setUint32(e.posOff, samp, true);
        dv.setUint32(e.sampleOff, samp, true);
      }
    }
    return outU8.buffer;
  }catch(_){ return origAb; }
}


/* File load */
async function ensureAudioEl(){
  if(state.audioEl) return state.audioEl;
  const a = new Audio();
  a.preload = "auto";
  a.addEventListener("ended", ()=>{
    state.isPlaying = false;
    stopRaf();
    // 停止時は「再生開始位置」へ戻す
    setPlayhead(state.playStartSec || 0);
    ensureVisibleSec(currentPlayheadSec());
    updateButtons();
    drawAll();
  });
  state.audioEl = a;
  return a;
}
async function ensureAudioCtx(){
  if(state.audioCtx) return state.audioCtx;
  state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  try{ await state.audioCtx.resume(); }catch(_){}
  return state.audioCtx;
}
function buildPeaks(buffer, targetBins){
  const chL = buffer.getChannelData(0);
  const chR = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : chL;
  const n = chL.length;
  const bins = Math.max(800, Math.min(targetBins, 12000));
  const step = Math.max(1, Math.floor(n / bins));
  const minArr = new Float32Array(bins);
  const maxArr = new Float32Array(bins);
  for(let i=0;i<bins;i++){
    let mn = 1e9, mx = -1e9;
    const a = i*step;
    const b = Math.min(n, a+step);
    for(let j=a;j<b;j++){
      const v = (chL[j] + chR[j]) * 0.5;
      if(v<mn) mn=v;
      if(v>mx) mx=v;
    }
    minArr[i]=mn; maxArr[i]=mx;
  }
  return {min:minArr, max:maxArr, bins};
}


async function buildPeaksAsync(buffer, targetBins, signal, onProgress){
  const chL = buffer.getChannelData(0);
  const chR = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : chL;
  const n = chL.length;
  const bins = Math.max(800, Math.min(targetBins, 12000));
  const step = Math.max(1, Math.floor(n / bins));
  const minArr = new Float32Array(bins);
  const maxArr = new Float32Array(bins);

  // chunked processing to avoid UI stall
  const CHUNK_BINS = 240;
  for(let i=0;i<bins;i++){
    if(signal && signal.aborted) throw _makeAbortError();
    let mn = 1e9, mx = -1e9;
    const a = i*step;
    const b = Math.min(n, a+step);
    for(let j=a;j<b;j++){
      const v = (chL[j] + chR[j]) * 0.5;
      if(v<mn) mn=v;
      if(v>mx) mx=v;
    }
    minArr[i]=mn; maxArr[i]=mx;

    if((i % CHUNK_BINS)===0){
      if(typeof onProgress==="function") onProgress(i / bins);
      // yield to UI
      await new Promise(r=>requestAnimationFrame(()=>r()));
    }
  }
  if(typeof onProgress==="function") onProgress(1);
  return {min:minArr, max:maxArr, bins};
}

async function loadFile(file){
  state.fileName = file && file.name ? file.name : state.fileName;
  if(state.ui) state.ui.isLoadingWav = true;
  try{
    setStatus("読み込み中…","warn");
    state.file = file;

    // reset standard-check processing state (new file)
    state.procApplied = false;
    state.procDataPayload = null;
    state.procInfo = null;
    state.scLast = null;
    // choose initial preset from saved order (app start uses the first of order)
    try{ _qcEnsureLoaded(); }catch(_){ }
    if(!state.qcPresetId){
      const first = (Array.isArray(state.qcPresetOrder) && state.qcPresetOrder[0]) ? state.qcPresetOrder[0] : (CFG.QC_DEFAULT_PRESET_ID || null);
      state.qcPresetId = first;
    }
    $("fileName").textContent = file.name;

    // playback src
    const audio = await ensureAudioEl();
    if(state.previewUrl){ try{ URL.revokeObjectURL(state.previewUrl); }catch(_){ } state.previewUrl=null; }
    if(state.audioUrl) URL.revokeObjectURL(state.audioUrl);
    state.audioUrl = URL.createObjectURL(file);
    audio.src = state.audioUrl;
    audio.currentTime = 0;

    // decode for waveform/analyzer
    const ctx = await ensureAudioCtx();
    let __loadOK = false;
    const __loadCtrl = new AbortController();
    _prog.show("読み込み中…","ファイルを読み取り中", __loadCtrl);
    const __sig = __loadCtrl.signal;
    let ab;
    try{
      ab = await _readFileArrayBufferWithProgress(file, (r)=>{
        if(r==null) _prog.set(null, "読み込み中…", "ファイルを読み取り中");
        else _prog.set(0.05 + r*0.55, "読み込み中…", `ファイルを読み取り中（${Math.round(r*100)}%）`);
      });
    }catch(err){
      _prog.hide();
      throw err;
    }
    _prog.set(0.60, "読み込み中…", "解析");
    // early container validation
    const cinfo = detectWavContainer(ab);
    if(!cinfo.ok){
      throw new Error(`非対応/破損の可能性: ${cinfo.reason}`);
    }
    _prog.set(0.64, "読み込み中…", "解析→CUE");
  /* PDF_ATTACH_LOAD_HOOK */
  try{
    const list = pdfFindAllInWav(ab);
    if(list && list.length){
      pdfSet(list);
      log(`INFO: 添付ファイルを認識しました: ${list.length}件`);
    }else{
      pdfSet([]);
    }
  }catch(_){ pdfSet([]); }

    state.srcAb = ab;
    _ensureNotCancelled(__sig);
  // keep original fmt/data payloads for canonical export (audio bytes preserved)
  try{
    state.srcFmtPayload = _riffExtractChunkPayload(ab, "fmt ");
    state.srcDataPayload = _riffExtractChunkPayload(ab, "data");
  }catch(_){ state.srcFmtPayload=null; state.srcDataPayload=null; }

  // BWF-J: Linear PCM only（圧縮/Float等は非対応）
  try{
    const pcm = detectPcmFromFmtPayload(state.srcFmtPayload);
    state._pcmInfo = pcm;
    if(!pcm.ok){
      setStatus("非対応形式","err");
      logError(`非PCM形式のため現在未対応です（${pcm.reason}）`, new Error(pcm.reason), "WARN");
      log(`WARN: 非PCM/未対応: ${pcm.reason}`);
      return;
    }
  }catch(err){
    setStatus("非対応形式","err");
    logError("fmt形式の判定に失敗しました", err, "WARN");
    log(`WARN: fmt判定失敗: ${err?.message || err}`);
    return;
  }

  // derive original WAV sampleRate/blockAlign/sampleCount for cue conversion & in-place patch
  try{
    const fi = _ecParseFmtInfo();
    if(fi && fi.sampleRate && isFinite(fi.sampleRate)) state.fileSr = fi.sampleRate;
    // blockAlign at fmt payload offset 12 (WAVEFORMATEX)
    if(state.srcFmtPayload && state.srcFmtPayload.byteLength >= 14){
      const dvFmt = new DataView(state.srcFmtPayload.buffer, state.srcFmtPayload.byteOffset, state.srcFmtPayload.byteLength);
      const ba = dvFmt.getUint16(12, true);
      if(ba && isFinite(ba)) state.fileBlockAlign = ba;
    }
    if(state.srcDataPayload && state.fileBlockAlign && isFinite(state.fileBlockAlign) && state.fileBlockAlign>0){
      state.fileTotalSamples = Math.floor(state.srcDataPayload.byteLength / state.fileBlockAlign);
    }else{
      state.fileTotalSamples = null;
    }
  }catch(_){
    state.fileSr = null; state.fileBlockAlign = null; state.fileTotalSamples = null;
  }


    
    // also preserve optional chunk payloads when present (non-fatal)
    try{ state.srcBextPayload = _riffExtractChunkPayload(ab, "bext"); }catch(_){ state.srcBextPayload = null; }
    try{ state.srcIXmlPayload = _riffExtractChunkPayload(ab, "iXML"); }catch(_){ state.srcIXmlPayload = null; }
    try{ state.srcCmcdPayload = _riffExtractChunkPayload(ab, "cmcd"); }catch(_){ state.srcCmcdPayload = null; }
state.srcChunks = parseRiffChunks(ab);
    // cmcd/iXML 読み取り（あればUIに展開）
    try{
      if(state.srcChunks){
        for(const ch of state.srcChunks){
          if(ch.id==="cmcd"){
            const u8 = new Uint8Array(ab, ch.dataOff, Math.min(ch.size, 2048));
            const buf = new Uint8Array(2048); buf.fill(0); buf.set(u8.slice(0,2048), 0);
            cmcdFillInputsFromBytes(buf);
          }
        
          if(ch.id==="bext"){
            try{
              const u8 = new Uint8Array(ab, ch.dataOff, ch.size);
              const t = bextExtractCodingHistoryText(u8);
              const ta = $("bextArea");
              if(ta && (!ta.value || !ta.value.trim()) && t) ta.value = t;
            }catch(_){}
          }
}
      }
    }catch(_){}

    // best-effort: read existing cmcd/iXML text (non-fatal)
    try{
      const dv = new DataView(ab);
      const str4=(o)=>String.fromCharCode(dv.getUint8(o),dv.getUint8(o+1),dv.getUint8(o+2),dv.getUint8(o+3));
      const u32=(o)=>dv.getUint32(o,true);
      if(dv.byteLength>=12 && str4(0)==="RIFF" && str4(8)==="WAVE"){
        let off=12;
        while(off+8<=dv.byteLength){
          const id=str4(off);
          const size=u32(off+4);
          const dataOff=off+8;
          if(id==="cmcd"){
            const u8=new Uint8Array(ab, dataOff, Math.min(size, dv.byteLength-dataOff));
            const parsed = cmcdParseFromPayload(u8);
            if($("cmcdRawArea")) $("cmcdRawArea").value = parsed.rawText || "";
            try{ cmcdApplyObjToInputs(parsed.obj); }catch(_){}
          }
          off = dataOff + size + (size%2);
        }
      }
    }catch(_){}

    
    // --- Read existing CUEs BEFORE decodeAudioData (avoid detached ArrayBuffer) ---
    try{ _prog.set(0.72, "読み込み中…", "CUE解析"); }catch(_){}
    const cueSr = (state.fileSr && isFinite(state.fileSr)) ? state.fileSr : 48000;
    let existing = [];
    try{
      existing = parseWavCues(ab, cueSr) || [];
    }catch(err){
      existing = [];
      try{ log(`INFO: 既存CUE解析に失敗（無視）: ${err?.message || err}`); }catch(_){}
    }
    if(existing && existing.length){
      existing = normalizeCueIds(existing);
      const estDur = (state.fileTotalSamples && isFinite(state.fileTotalSamples) && cueSr>0) ? (state.fileTotalSamples / cueSr) : null;
      state.cues = existing.map(c=>({id:(c.id>>>0), label:c.label, sec: clamp(c.sec, 0, (estDur!=null ? estDur : c.sec))}));
      const maxId = state.cues.reduce((m,c)=> Math.max(m, (c.id>>>0)), 0);
      state.nextCueId = maxId + 1;
      log(`INFO: 既存CUEを検出: ${state.cues.length}件`);
    }else{
      state.cues = [];
      state.nextCueId = 1;
    }

    // --- decode for waveform/analyzer (use copy to keep srcAb intact) ---
    try{ _prog.set(null, "読み込み中…", "波形準備（デコード）"); }catch(_){}
    const buf = await new Promise((resolve,reject)=> ctx.decodeAudioData(ab.slice(0), resolve, reject));
    state.buffer = buf;
    state.sr = buf.sampleRate;
    // keep an immutable reference for "補正を戻す"
    state.origBuffer = buf;

    state.zoom = 1;
    state.vZoom = 1;
    state.scrollPx = 0;
    state.playheadSec = 0;

    try{ _prog.set(0.86, "読み込み中…", "波形生成"); }catch(_){}
    state.peaks = await buildPeaksAsync(buf, 6000, __sig, (r)=>{
      try{ _prog.set(0.86 + r*0.10, "読み込み中…", "波形生成"); }catch(_){ }
    });
    _ensureNotCancelled(__sig);
    try{ _prog.set(0.97, "読み込み中…", "UI反映"); }catch(_){ }

    // Clamp cue positions with the true decoded duration
    try{
      if(Array.isArray(state.cues) && isFinite(buf.duration)){
        state.cues = state.cues.map(c=>({ ...c, sec: clamp(c.sec, 0, buf.duration) }));
      }
    }catch(_){}

    // Capture cue meta + signature for hybrid in-place move on export
    try{
      state.cuePatchMeta = extractCuePatchMeta(ab) || null;
      state.loadedCueSig = cueSig(state.cues);
    }catch(_){
      state.cuePatchMeta = null;
      state.loadedCueSig = null;
    }

    __loadOK = true;
    setStatus("OK","ok");
    log(`INFO: decoded ${buf.numberOfChannels}ch / ${buf.sampleRate}Hz / ${buf.duration.toFixed(3)}s`);
    try{
      const hasPdf = !!(state.pdfAttach && state.pdfAttach.bytes && state.pdfAttach.bytes.length);
      const cueN = Array.isArray(state.cues) ? state.cues.length : 0;
      const msg = `WAVを読み込みました${hasPdf ? "（添付ファイルあり）" : ""}${cueN ? `（CUE ${cueN}件）` : ""}`;
      toast(msg, "ok", 2400);
    }catch(_){ }
    updateButtons();
    resizeAll();
    renderCues();
    drawAll();
    undoReset();
    // baseline snapshot for diff summary (原本)
    try{ state.originalSnapshot = takeSnapshot(); }catch(_){ state.originalSnapshot = null; }
    try{ scheduleDiffUpdate(true); }catch(_){ }
    if(state.ui) state.ui.isLoadingWav = false;
  }catch(err){
    if(state.ui) state.ui.isLoadingWav = false;
    console.error(err);
    setStatus("ERROR","err");
    logError("読み込みに失敗しました", err);
    log(`ERROR: 読み込み失敗: ${err?.message || err}`);
  }finally{
    // Always close the overlay (and show 100% only when success)
    try{
      if(__loadOK){
        _prog.set(1, "読み込み中…", "完了");
        await _prog.yield();
      }
    }catch(_){}
    try{ _prog.hide(); }catch(_){}
    if(state.ui) state.ui.isLoadingWav = false;
  }
}

/* Playback & RAF */
function startRaf(){
  if(state.rafId) return;
  const step = ()=>{
    state.rafId = requestAnimationFrame(step);
    if(state.isPlaying && state.audioEl){
      state.playheadSec = state.audioEl.currentTime || 0;
      const dur = state.buffer ? state.buffer.duration : state.audioEl.duration;
      if(isFinite(dur)) state.playheadSec = clamp(state.playheadSec, 0, dur);
    }
    drawAll();
  };
  state.rafId = requestAnimationFrame(step);
}
function stopRaf(){
  if(!state.rafId) return;
  cancelAnimationFrame(state.rafId);
  state.rafId = 0;
}
async function play(){
  if(!state.buffer) return;
  const a = await ensureAudioEl();
  try{
    // 再生開始位置を記録し、その位置から再生
    state.playStartSec = currentPlayheadSec();
    a.currentTime = state.playStartSec;
    await a.play();
    state.isPlaying = true;
    startRaf();
    updateButtons();
  }catch(err){
    log(`ERROR: 再生できません: ${err?.message || err}`);
  }
}
function pause(){
  if(!state.buffer) return;
  if(state.audioEl) state.audioEl.pause();
  state.isPlaying = false;
  stopRaf();
  // 停止時は「再生開始位置」へ戻す
  setPlayhead(state.playStartSec || 0);
  ensureVisibleSec(currentPlayheadSec());
  updateButtons();
  drawAll();
}

/* Cues */
const isDemoEditLocked = ()=>{
  try{
    const st = LicenseCore.peekState?.();
    return st?.tier === "demo" && !!st?.demo?.isLocked;
  }catch(_){
    return false;
  }
};
const warnDemoLocked = ()=>{
  if(!window.safeToast) return;
  const st = LicenseCore.peekState?.();
  const reason = st?.demo?.demoBlockedReason || "demo_expired";
  if(reason === "demo_export_limit") window.safeToast(LICENSE_TEXT.demoExportLimitToast, "warn");
  else window.safeToast(LICENSE_TEXT.demoExpiredToast, "warn");
};
function addCue(label){
  if(!state.buffer) return;
  if(isDemoEditLocked()){ warnDemoLocked(); return; }

  // JPPA-1-2018: cue-point max 99
  if(Array.isArray(state.cues) && state.cues.length >= 99){
    window.safeToast && window.safeToast("CUEは最大99件です（規格）","ng");
    log("WARN: CUE上限（99）を超える追加はできません。");
    return;
  }

  undoCheckpoint();
  const beforeCount = Array.isArray(state.cues) ? state.cues.length : 0;
  const sec = currentPlayheadSec();
  const id = state.nextCueId++;
  state.cues.push({id, label, sec});
  log(`CUE+: ${label} @ ${sec.toFixed(3)}s`);
  renderCues();
  drawAll();
  try{
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    console.log("[CUE] add", { id, label, sec, beforeCount, afterCount: state.cues.length, fileId: activeId });
    if (typeof window.diagLog === "function") window.diagLog("[CUE]", "add", window.diagState({ id, label, sec, beforeCount, afterCount: state.cues.length, fileId: activeId }));
  }catch(_){}
  if(typeof window.commitAll === "function"){
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    window.commitAll("cue:add", {fileId: activeId});
  }
}


function addStartStopCues(){
  if(!state.buffer) return;
  if(isDemoEditLocked()){ warnDemoLocked(); return; }
  undoCheckpoint();
  const dur = state.buffer.duration;
  const beforeCount = Array.isArray(state.cues) ? state.cues.length : 0;

  const idStart = fourccToU32("BC01");
  const idStop  = fourccToU32("BC04");

  const reserved = new Set([idStart,idStop]);
  const next = state.cues.filter(c => !reserved.has(c.id) && !["BC$START","BC$STOP"].includes(c.label));

  // JPPA-1-2018: cue-point max 99
  if(next.length + 2 > 99){
    window.safeToast && window.safeToast("CUEは最大99件です（規格）","ng");
    log("WARN: CUE上限（99）を超える追加はできません。");
    return;
  }

  state.cues = next;
  state.cues.push({id:idStart, label:"BC$START", sec:0});
  state.cues.push({id:idStop,  label:"BC$STOP",  sec:dur});

  log(`CUE+: BC$START @ 0.000s`);
  log(`CUE+: BC$STOP @ ${dur.toFixed(3)}s`);
  renderCues();
  drawAll();
  try{
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    console.log("[CUE] addStartStop", { beforeCount, afterCount: state.cues.length, fileId: activeId });
    if (typeof window.diagLog === "function") window.diagLog("[CUE]", "add", window.diagState({ type: "startStop", beforeCount, afterCount: state.cues.length, fileId: activeId }));
  }catch(_){}
  if(typeof window.commitAll === "function"){
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    window.commitAll("cue:add", {fileId: activeId});
  }
}

function addCuePair(){
  if(!state.buffer) return;
  if(isDemoEditLocked()){ warnDemoLocked(); return; }
  undoCheckpoint();
  const beforeCount = Array.isArray(state.cues) ? state.cues.length : 0;
  const sec0 = currentPlayheadSec();
  const sTxt = ($("pairSeconds")?.value || "20").trim();
  const gapRaw = Number(sTxt);
  const gap = isFinite(gapRaw) ? Math.max(0, gapRaw) : 0;
  const sec1 = clamp(sec0 + gap, 0, state.buffer.duration);

  // overwrite existing ST/END if present
  const next = state.cues.filter(c => c.label !== "BC$STANDBY" && c.label !== "BC$END");

  // JPPA-1-2018: cue-point max 99
  if(next.length + 2 > 99){
    window.safeToast && window.safeToast("CUEは最大99件です（規格）","ng");
    log("WARN: CUE上限（99）を超える追加はできません。");
    return;
  }

  state.cues = next;
  const id0 = state.nextCueId++;
  const id1 = state.nextCueId++;
  state.cues.push({id:id0, label:"BC$STANDBY", sec:sec0});
  state.cues.push({id:id1, label:"BC$END", sec:sec1});

  log(`CUE+: BC$STANDBY @ ${sec0.toFixed(3)}s`);
  log(`CUE+: BC$END @ ${sec1.toFixed(3)}s (gap ${gap}s)`);
  renderCues();
  drawAll();
  try{
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    console.log("[CUE] addPair", { beforeCount, afterCount: state.cues.length, fileId: activeId });
    if (typeof window.diagLog === "function") window.diagLog("[CUE]", "add", window.diagState({ type: "pair", beforeCount, afterCount: state.cues.length, fileId: activeId }));
  }catch(_){}
  if(typeof window.commitAll === "function"){
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    window.commitAll("cue:add", {fileId: activeId});
  }
}

function deleteCue(id){
  if(isDemoEditLocked()){ warnDemoLocked(); return; }
  undoCheckpoint();
  const beforeCount = Array.isArray(state.cues) ? state.cues.length : 0;
  const target = state.cues.find(c=>c.id===id) || null;
  state.cues = state.cues.filter(c=>c.id!==id);
  renderCues();
  drawAll();
  try{
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    console.log("[CUE] delete", { id, label: target?.label, beforeCount, afterCount: state.cues.length, fileId: activeId });
    if (typeof window.diagLog === "function") window.diagLog("[CUE]", "delete", window.diagState({ id, label: target?.label, beforeCount, afterCount: state.cues.length, fileId: activeId }));
  }catch(_){}
  if(typeof window.commitAll === "function"){
    const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    window.commitAll("cue:delete", {fileId: activeId});
  }
}
function jumpToCue(id){
  const c = state.cues.find(x=>x.id===id);
  if(!c) return;
  setPlayhead(c.sec);
  ensureVisibleSec(c.sec);
  drawAll();
}
function setPlayhead(sec){
  const dur = state.buffer ? state.buffer.duration : 0;
  const s = clamp(sec, 0, dur||sec);
  state.playheadSec = s;
  if(state.audioEl) state.audioEl.currentTime = s;
}
function ensureVisibleSec(sec){
  const canvas = $("wave");
  const rect = canvas.getBoundingClientRect();
  const w = rect.width;
  const totalW = w * Math.max(1, state.zoom);
  const maxScroll = Math.max(0, totalW - w);
  const px = (sec / (state.buffer?.duration||1)) * totalW;
  state.scrollPx = clamp(px - w*0.5, 0, maxScroll);
}

/* Cue table *//* Cue table */
function renderCues(){
  const body = $("cueBody");
  body.innerHTML = "";
  const cues = state.cues.slice().sort((a,b)=>a.sec-b.sec);
  $("cueCount").textContent = String(cues.length);
  for(const c of cues){
    const tr = document.createElement("tr");
    const tdL = document.createElement("td");
    tdL.className = "mono";
    tdL.textContent = c.label;

    const tdT = document.createElement("td");
    tdT.className = "timeCell";
    const inp = document.createElement("input");
    inp.className = "timeInput mono";
    inp.type = "text";
    inp.value = fmtTime(c.sec);
    inp.inputMode = "decimal";
    inp.spellcheck = false;
    inp.title = "例: 12.34 / 01:23.45";

    // クリック挙動:
    // 1回目クリック（フォーカス取得）: 全選択→上書きモード
    // 2回目クリック（同一入力欄がフォーカス中）: クリック位置へキャレット→挿入モード
    inp._wasFocused = false;
    inp.addEventListener("pointerdown", ()=>{
      inp._wasFocused = (document.activeElement === inp);
    });
    inp.addEventListener("focus", ()=>{
      try{ if(state.buffer) inp._undoSnap = _captureUndoState(); }catch(_){}
      if(!inp._wasFocused){
        // focus直後に全選択（クリック位置へキャレットが置かれる前に上書き）
        requestAnimationFrame(()=>{ try{ inp.select(); }catch(_){} });
      }
    });
    inp.addEventListener("blur", ()=>{ inp._wasFocused = false; });

    inp.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ inp.blur(); } e.stopPropagation(); });
    inp.addEventListener("mousedown", (e)=>{ e.stopPropagation(); });
    inp.addEventListener("click", (e)=>{ e.stopPropagation(); });
    inp.addEventListener("wheel", (e)=>{ e.stopPropagation(); }, {passive:false});
    inp.addEventListener("blur", ()=>{
      const snap = inp._undoSnap; inp._undoSnap = null;
      const t = parseTimeInput(inp.value);
      if(t===null){ inp.value = fmtTime(c.sec); return; }
      const oldSec = (_getCueById(c.id)?.sec ?? c.sec);
      if(snap && Math.abs(oldSec - t) > 1e-6) _undoPushSnapshot(snap);
      moveCueToTime(c.id, t, true, "cue:list:edit");
      const cc = _getCueById(c.id);
      inp.value = fmtTime(cc ? cc.sec : c.sec);
      try{
        const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
        console.log("[CUE] list edit", { id: c.id, from: oldSec, to: cc ? cc.sec : c.sec, fileId: activeId });
        if (typeof window.diagLog === "function") window.diagLog("[CUE]", "edit", window.diagState({ id: c.id, from: oldSec, to: cc ? cc.sec : c.sec, fileId: activeId }));
      }catch(_){}
    });
    tdT.appendChild(inp);

    const tdO = document.createElement("td");
    const moveBtn = document.createElement("button");
    moveBtn.className = "opBtn";
    moveBtn.textContent = "移動";
    moveBtn.onclick = ()=> jumpToCue(c.id);

    const delBtn = document.createElement("button");
    delBtn.className = "opBtn bad";
    delBtn.textContent = "削除";
    delBtn.style.marginLeft = "6px";
    delBtn.onclick = ()=> deleteCue(c.id);

    tdO.appendChild(moveBtn);
    tdO.appendChild(delBtn);

    tr.appendChild(tdL);
    tr.appendChild(tdT);
    tr.appendChild(tdO);
    body.appendChild(tr);
  }
}
window.renderCueList = window.renderCueList || renderCues;

/* Canvas drawing */
const wave = $("wave");
const wctx = wave.getContext("2d");
const cueCanvas = $("cueCanvas");
const cueCtx = cueCanvas ? cueCanvas.getContext("2d") : null;

function resizeCanvas(elOrId){
  const el = (typeof elOrId === "string") ? document.getElementById(elOrId) : elOrId;
  if(!el) return;

  // 縮小時に canvas.width/height(属性) が小さくなると、canvas自身の rect が小さい値で固定され、
  // 拡大後も rect が追従しない/追従が遅いケースがあるため、親コンテナの rect を測る。
  const measureEl = (el.parentElement && el.parentElement.getBoundingClientRect) ? el.parentElement : el;
  const r = measureEl.getBoundingClientRect();

  const dpr = window.devicePixelRatio || 1;
  const w = Math.max(1, Math.ceil(r.width * dpr));
  const h = Math.max(1, Math.ceil(r.height * dpr));

  const changed = (el.width !== w) || (el.height !== h);

  if(el.width !== w) el.width = w;
  if(el.height !== h) el.height = h;

  try{
    const ctx = el.getContext && el.getContext("2d");
    if(ctx && ctx.setTransform){
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }catch(_){}

  // 既存ログに合わせ、必要最小限（変更があった時だけ）
  if(changed){
    try{
      const id = el.id || "(no-id)";
      console.log("[UI][resizeCanvas]", { id, rectW: r.width, rectH: r.height, w, h, dpr });
    }catch(_){}
  }
}
function resizeAll(){
  resizeCanvas($("wave"));
  resizeCanvas($("cueCanvas"));
  resizeCanvas($("meterCanvas"));
  resizeCanvas($("imagerCanvas"));
}

function _uiLogWaveLayout(tag){
  try{
    const wave = document.getElementById("wave");
    const waveBox = document.getElementById("waveBox");
    const waveWrap = document.querySelector(".waveWrap");
    const workTop = document.querySelector(".workTop");
    const analyzersRow = document.getElementById("analyzersRow");

    const rect = (el)=> el?.getBoundingClientRect?.() || {width:0,height:0,top:0,left:0};
    const cs = (el)=> el ? window.getComputedStyle(el) : null;
    const pick = (s)=> s ? ({ h:s.height, minH:s.minHeight, maxH:s.maxHeight, flex:s.flex, flexGrow:s.flexGrow, flexBasis:s.flexBasis, overflow:s.overflow }) : null;

    console.log("[UI][layout]", tag, {
      vw: window.innerWidth, vh: window.innerHeight,
      wave: { rect: rect(wave), attr: { w: wave?.width, h: wave?.height }, style: pick(cs(wave)) },
      waveBox: { rect: rect(waveBox), style: pick(cs(waveBox)) },
      waveWrap: { rect: rect(waveWrap), style: pick(cs(waveWrap)) },
      workTop: { rect: rect(workTop), style: pick(cs(workTop)) },
      analyzersRow: { rect: rect(analyzersRow), style: pick(cs(analyzersRow)) },
    });
  }catch(_){}
}

function clearCanvasFull(cv){
  if(!cv || !cv.getContext) return;
  const ctx = cv.getContext("2d");
  if(!ctx) return;
  const w = Math.max(1, cv.width || 1);
  const h = Math.max(1, cv.height || 1);
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(-2, -2, w + 4, h + 4);
  ctx.restore();
}
function clearCueLayerOnSwitch(fileId, cueCount, reason){
  try{
    const domLayers = [
      "#cueMarkerLayer",
      ".cue-marker-layer",
      "#cueLabelLayer",
      ".cue-label-layer",
      "#cueRangeLayer",
      ".cue-range-layer",
    ];
    domLayers.forEach((sel)=>{
      const cont = document.querySelector(sel);
      if(cont && cont.innerHTML !== undefined) cont.innerHTML = "";
    });
    if(window.cueMarkerLayerEl && window.cueMarkerLayerEl.innerHTML !== undefined){
      window.cueMarkerLayerEl.innerHTML = "";
    }

    const canvasLayers = [
      document.getElementById("cueCanvas"),
      document.getElementById("overlayCanvas"),
      document.getElementById("cueOverlayCanvas"),
      window.cueCanvas,
      window.cueOverlayCanvas,
    ].filter(Boolean);
    canvasLayers.forEach((cv)=>{
      clearCanvasFull(cv);
    });

    const waveCanvas = $("wave");
    clearCanvasFull(waveCanvas);
  }catch(e){
    try{ console.warn("[CUE] clearCueLayerOnSwitch failed (ignored)", e); }catch(_){}
  }
  try{
    console.log("[CUE] clearLayer onSwitch", { fileId, cueCount, reason });
    console.log("[CUE][clear]", "fileId=", fileId, "done");
  }catch(_){}
}

function logCueRenderMarkers(fileId, cueCount){
  if(state.cueRenderLog?.fileId === fileId && state.cueRenderLog?.cueCount === cueCount) return;
  state.cueRenderLog = { fileId, cueCount };
  try{
    console.log("[CUE] renderMarkers", { fileId, cueCount });
  }catch(_){}
}

function renderMarkers(fileId, cues){
  const activeFileId = state.activeFileId || null;
  const cueCount = Array.isArray(cues) ? cues.length : 0;
  if(!fileId || (activeFileId && fileId !== activeFileId)){
    clearCueLayerOnSwitch(fileId, cueCount);
    return;
  }
  try{
    console.log("[CUE][render]", "fileId=", fileId, "activeFileId=", activeFileId, "cueCount=", cueCount);
  }catch(_){}
  logCueRenderMarkers(fileId, cueCount);
  if(!state.buffer || !cueCtx) return;

  const W = wave.getBoundingClientRect().width;
  const H = wave.getBoundingClientRect().height;
  const totalW = W * Math.max(1, state.zoom);
  const cueNames = (Array.isArray(cues) ? cues : []).map(c=> (c?.name || c?.dwName || c?.label || ""));

  try{
    console.log("[CUE][render]", "cueNames=", cueNames);
  }catch(_){}
  clearCanvasFull(cueCanvas);
  for(const c of cues){
    const x = ((c.sec / state.buffer.duration) * totalW) - state.scrollPx;
    if(x<-20 || x>W+20) continue;
    const isST = c.label==="BC$STANDBY";
    const isEN = c.label==="BC$END";
    const cueColor = isST ? "rgba(126,231,162,.95)" : isEN ? "rgba(251,191,36,.95)" : "rgba(229,231,235,.70)";
    cueCtx.strokeStyle = cueColor;
    cueCtx.lineWidth = 2;
    console.log("[CUE][line]", "name=", String(c.label ?? ""), "x=", x, "color=", cueColor);
    cueCtx.beginPath(); cueCtx.moveTo(x, 0); cueCtx.lineTo(x, H); cueCtx.stroke();

    cueCtx.fillStyle = "rgba(0,0,0,.45)";
    // Label box: flip to left side if it would overflow the waveform area
    cueCtx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    const label = String(c.label ?? "");
    const tw = Math.ceil(cueCtx.measureText(label).width);
    const boxW = clamp(tw + 16, 64, 200);
    let boxX = x + 4;
    if(boxX + boxW > W - 6){
      boxX = x - 4 - boxW; // flip to left
    }
    boxX = clamp(boxX, 6, W - 6 - boxW);

    cueCtx.fillRect(boxX, 8, boxW, 18);
    cueCtx.fillStyle = "rgba(229,231,235,.88)";
    cueCtx.fillText(label, boxX + 8, 21);
  }
}

function drawWaveform(){
  const W = wave.getBoundingClientRect().width;
  const H = wave.getBoundingClientRect().height;

  clearCanvasFull(wave);
  wctx.fillStyle = "rgba(0,0,0,.10)";
  wctx.fillRect(0,0,W,H);

  wctx.strokeStyle = "rgba(148,163,184,.10)";
  wctx.lineWidth = 1;
  for(let i=1;i<6;i++){
    const y = (H*i)/6;
    wctx.beginPath(); wctx.moveTo(0,y); wctx.lineTo(W,y); wctx.stroke();
  }

  if(!state.buffer || !state.peaks){
    wctx.fillStyle = "rgba(229,231,235,.55)";
    wctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    wctx.fillText("WAV を読み込んでください（ドラッグ&ドロップ可）", 12, 22);
    clearCanvasFull(cueCanvas);
    return;
  }

  const totalW = W * Math.max(1, state.zoom);
  const maxScroll = Math.max(0, totalW - W);
  state.scrollPx = clamp(state.scrollPx, 0, maxScroll);

  const mid = H/2;
  const amp = (H*0.44) * (state.vZoom||1);

  const bins = state.peaks.bins;
  const visStart = state.scrollPx / totalW;
  const visEnd = (state.scrollPx + W) / totalW;

  const b0 = Math.floor(visStart * bins);
  const b1 = Math.ceil(visEnd * bins);

  wctx.strokeStyle = "rgba(126,231,162,.85)";
  wctx.lineWidth = 1;
  wctx.beginPath();
  for(let i=b0;i<=b1;i++){
    const t = i / bins;
    const x = (t * totalW) - state.scrollPx;
    if(x< -2 || x>W+2) continue;
    const mn = state.peaks.min[i] || 0;
    const mx = state.peaks.max[i] || 0;
    wctx.moveTo(x, mid + mn*amp);
    wctx.lineTo(x, mid + mx*amp);
  }
  wctx.stroke();

  // playhead
  const phSec = currentPlayheadSec();
  const xPh = ((phSec / state.buffer.duration) * totalW) - state.scrollPx;
  wctx.strokeStyle = "rgba(56,189,248,.95)";
  wctx.lineWidth = 2;
  wctx.beginPath(); wctx.moveTo(xPh, 0); wctx.lineTo(xPh, H); wctx.stroke();

  // cues
  const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
  renderMarkers(activeId, state.cues || []);
}

function cueHitTest(xPx){
  if(!state.buffer) return null;
  const W = wave.getBoundingClientRect().width;
  const totalW = W * Math.max(1, state.zoom);
  const secAtX = ((xPx + state.scrollPx) / totalW) * state.buffer.duration;

  let best=null, bestDist=1e9;
  for(const c of state.cues){
    const cx = ((c.sec / state.buffer.duration) * totalW) - state.scrollPx;
    const d = Math.abs(cx - xPx);
    if(d<bestDist){ bestDist=d; best=c; }
  }
  if(best && bestDist<=8) return {cue:best, secAtX};
  return null;
}
function xToSec(xPx){
  const W = wave.getBoundingClientRect().width;
  const totalW = W * Math.max(1, state.zoom);
  return ((xPx + state.scrollPx) / totalW) * (state.buffer?.duration || 0);
}

wave.addEventListener("mousedown",(e)=>{
  if(!state.buffer) return;
  const rect = wave.getBoundingClientRect();
  const x = e.clientX - rect.left;

  const hit = cueHitTest(x);
  if(hit){
    try{ if(state.buffer) state._undoDragSnap = _captureUndoState(); }catch(_){}
    state.draggingCueId = hit.cue.id;
    state.dragOffsetSec = hit.cue.sec - hit.secAtX;

    // Pair-link: if dragging STANDBY or END, move the counterpart to keep interval constant
    state.dragPair = null;
    const label = hit.cue.label;
    if(label==="BC$STANDBY" || label==="BC$END"){
      const st = state.cues.find(c=>c.label==="BC$STANDBY");
      const en = state.cues.find(c=>c.label==="BC$END");
      if(state.linkPair && st && en && st.id!==en.id){
        state.dragPair = {
          stId: st.id,
          enId: en.id,
          gap: (en.sec - st.sec),   // keep signed gap
          dragLabel: label
        };
      }else{
        state.dragPair = null;
      }
    }
    return;
  }

  state.dragPair = null;
  const sec = xToSec(x);
  setPlayhead(sec);
  drawAll();
});
window.addEventListener("mousemove",(e)=>{
  if(!state.buffer) return;
  if(state.draggingCueId===null) return;

  const rect = wave.getBoundingClientRect();
  const x = clamp(e.clientX - rect.left, 0, rect.width);
  const rawSec = xToSec(x) + state.dragOffsetSec;

  const dur = state.buffer.duration;
  const dragged = state.cues.find(k=>k.id===state.draggingCueId);
  if(!dragged) return;

  // Default: move only the dragged cue
  let newDragged = clamp(rawSec, 0, dur);

  // If paired drag is active (ST/END), move counterpart to keep gap constant
  if(state.dragPair){
    const st = state.cues.find(c=>c.id===state.dragPair.stId);
    const en = state.cues.find(c=>c.id===state.dragPair.enId);
    if(st && en){
      const gap = state.dragPair.gap;

      if(dragged.id === st.id){
        // dragging ST: EN follows
        let stSec = newDragged;
        let enSec = stSec + gap;

        // clamp both while preserving gap
        if(enSec > dur){
          enSec = dur;
          stSec = enSec - gap;
        }
        if(stSec < 0){
          stSec = 0;
          enSec = stSec + gap;
        }
        // final clamp (just in case)
        st.sec = clamp(stSec, 0, dur);
        en.sec = clamp(enSec, 0, dur);
      }else if(dragged.id === en.id){
        // dragging EN: ST follows
        let enSec = newDragged;
        let stSec = enSec - gap;

        if(stSec < 0){
          stSec = 0;
          enSec = stSec + gap;
        }
        if(enSec > dur){
          enSec = dur;
          stSec = enSec - gap;
        }
        st.sec = clamp(stSec, 0, dur);
        en.sec = clamp(enSec, 0, dur);
      }else{
        // dragging a non-paired cue while dragPair set (unlikely) -> move only dragged
        dragged.sec = newDragged;
      }

      renderCues();
      drawAll();
      return;
    }
  }

  // Not paired
  dragged.sec = newDragged;
  renderCues();
  drawAll();
});
window.addEventListener("mouseup",()=>{
  if(state.draggingCueId!==null){
    try{
      const snap = state._undoDragSnap;
      if(snap){
        const after = _captureUndoState();
        if(_undoSig(after) !== _undoSig(snap)) _undoPushSnapshot(snap);
      }
    }catch(_){ }
    state._undoDragSnap = null;
    const c = state.cues.find(k=>k.id===state.draggingCueId);
    if(c){
      if(state.dragPair){
        const st = state.cues.find(x=>x.id===state.dragPair.stId);
        const en = state.cues.find(x=>x.id===state.dragPair.enId);
        if(st && en){
          log(`CUE MOVE(LINK): ST=${st.sec.toFixed(3)}s / EN=${en.sec.toFixed(3)}s / gap=${(en.sec-st.sec).toFixed(3)}s`);
        }else{
          log(`CUE MOVE: ${c.label} -> ${c.sec.toFixed(3)}s`);
        }
      }else{
        log(`CUE MOVE: ${c.label} -> ${c.sec.toFixed(3)}s`);
      }
      try{
        const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
        console.log("[CUE] drag end", { id: c.id, label: c.label, sec: c.sec, fileId: activeId });
      }catch(_){}
      if(typeof window.commitAll === "function"){
        const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
        window.commitAll("cue:move", {fileId: activeId});
      }
    }
  }
  state.draggingCueId = null;
  state.dragPair = null;
});

wave.addEventListener("wheel",(e)=>{
  if(!state.buffer) return;
  e.preventDefault();
  const W = wave.getBoundingClientRect().width;
  const totalW = W * Math.max(1, state.zoom);
  const maxScroll = Math.max(0, totalW - W);
  const delta = (Math.abs(e.deltaX)>Math.abs(e.deltaY)) ? e.deltaX : e.deltaY;
  state.scrollPx = clamp(state.scrollPx + delta, 0, maxScroll);
  drawAll();
}, {passive:false});

/* Analyzer */
function dbfs(x){
  const v = Math.max(1e-9, x);
  return 20*Math.log10(v);
}
function analyzeAt(sec){
  const buf = state.buffer;
  if(!buf) return null;
  const sr = buf.sampleRate;
  const chL = buf.getChannelData(0);
  const chR = buf.numberOfChannels>1 ? buf.getChannelData(1) : chL;
  const center = Math.floor(sec * sr);
  const win = Math.floor(0.120 * sr);
  const a = clamp(center - Math.floor(win/2), 0, chL.length-1);
  const b = clamp(a + win, 0, chL.length);
  let sumL=0,sumR=0, pkL=0, pkR=0;
  const n = Math.max(1, b-a);
  const pts = [];
  const step = Math.max(1, Math.floor(n/1400));
  for(let i=a;i<b;i++){
    const L=chL[i], R=chR[i];
    sumL += L*L; sumR += R*R;
    const al=Math.abs(L), ar=Math.abs(R);
    if(al>pkL) pkL=al;
    if(ar>pkR) pkR=ar;
  }
  for(let i=a;i<b;i+=step) pts.push([chL[i], chR[i]]);
  return {rmsL:Math.sqrt(sumL/n), rmsR:Math.sqrt(sumR/n), pkL, pkR, pts};
}
function rangeAvgDbfs(){
  const buf = state.buffer;
  if(!buf) return null;
  const st = state.cues.find(c=>c.label==="BC$STANDBY");
  const en = state.cues.find(c=>c.label==="BC$END");
  if(!st || !en) return null;
  const aS = Math.floor(Math.min(st.sec, en.sec) * buf.sampleRate);
  const bS = Math.floor(Math.max(st.sec, en.sec) * buf.sampleRate);
  if(bS<=aS) return null;
  const chL = buf.getChannelData(0);
  const chR = buf.numberOfChannels>1 ? buf.getChannelData(1) : chL;
  const n = bS-aS;
  const step = Math.max(1, Math.floor(n/250000));
  let sum=0,cnt=0;
  for(let i=aS;i<bS;i+=step){
    const L=chL[i], R=chR[i];
    sum += (L*L + R*R)*0.5;
    cnt++;
  }
  const rms = Math.sqrt(sum/Math.max(1,cnt));
  return dbfs(rms);
}
function drawMeter(a){
  const c = $("meterCanvas");
  const ctx = c.getContext("2d");
  const W = c.getBoundingClientRect().width;
  const H = c.getBoundingClientRect().height;
  const pad = 6;
  const labelW = 18;
  const gapX = 6;
  const footerH = 30;
  const topPad = 14;
  const baseY = H - footerH;
  const gridX = pad + labelW;
  const barX = gridX + gapX;
  const barAreaW = (W - pad) - barX;
  const laneGap = 6;
  const barW = Math.max(10, Math.floor((barAreaW - laneGap) / 2) - 2);
  const xL = barX;
  const xR = barX + barW + laneGap;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="rgba(0,0,0,.10)"; ctx.fillRect(0,0,W,H);

  const dbMin=-40, dbMax=0;
  const toH = (db)=> clamp((db-dbMin)/(dbMax-dbMin),0,1)*(baseY - topPad);

  ctx.strokeStyle="rgba(148,163,184,.18)";
  ctx.lineWidth=1;
  ctx.font="9px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  ctx.fillStyle="rgba(229,231,235,.55)";
  ctx.textBaseline = "middle";
  for(let t=0;t>=-40;t-=3){
    const y = baseY - toH(t);
    ctx.beginPath(); ctx.moveTo(gridX,y); ctx.lineTo(W-pad,y); ctx.stroke();
    if(t%6===0 || t===0 || t===-40) ctx.fillText(String(t),pad,y);
  }

  const rmsLdb=dbfs(a.rmsL), rmsRdb=dbfs(a.rmsR);
  const pkLdb=dbfs(a.pkL), pkRdb=dbfs(a.pkR);

  const fitDbText = (v)=>{
    const full = `${v.toFixed(1)}dB`;
    if(ctx.measureText(full).width <= barW) return full;
    const mid = `${v.toFixed(0)}dB`;
    if(ctx.measureText(mid).width <= barW) return mid;
    return `${v.toFixed(0)}`;
  };

  const hL=toH(rmsLdb), hR=toH(rmsRdb);
  ctx.fillStyle="rgba(126,231,162,.55)";
  ctx.fillRect(xL, baseY-hL, barW, hL);
  ctx.fillRect(xR, baseY-hR, barW, hR);

  const yPkL=baseY-toH(pkLdb), yPkR=baseY-toH(pkRdb);
  ctx.strokeStyle="rgba(56,189,248,.95)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(xL, yPkL); ctx.lineTo(xL+barW, yPkL);
  ctx.moveTo(xR, yPkR); ctx.lineTo(xR+barW, yPkR);
  ctx.stroke();

  ctx.fillStyle="rgba(229,231,235,.85)";
  ctx.font="10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  const yLR = H - 16;
  const yDB = H - 4;
  ctx.textBaseline = "alphabetic";
  ctx.fillText("L", xL, yLR);
  ctx.fillText("R", xR, yLR);

  ctx.fillStyle="rgba(229,231,235,.70)";
  ctx.font="9px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  ctx.fillText(fitDbText(rmsLdb), xL, yDB);
  ctx.fillText(fitDbText(rmsRdb), xR, yDB);
}

function drawImager(a){
  const c = $("imagerCanvas");
  const ctx = c.getContext("2d");
  const W = c.getBoundingClientRect().width;
  const H = c.getBoundingClientRect().height;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="rgba(0,0,0,.10)";
  ctx.fillRect(0,0,W,H);

  // Axes: x = Side (L-R), y = Mid (L+R)
  ctx.strokeStyle="rgba(148,163,184,.18)";
  ctx.lineWidth=1;

  // Center (mono) line
  ctx.beginPath();
  ctx.moveTo(W/2, 8); ctx.lineTo(W/2, H-18);
  ctx.stroke();

  // Baseline
  ctx.beginPath();
  ctx.moveTo(8, H/2); ctx.lineTo(W-8, H/2);
  ctx.stroke();

  // Labels: L / C / R
  ctx.fillStyle="rgba(229,231,235,.70)";
  ctx.font="11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  ctx.textBaseline = "bottom";
  ctx.fillText("L", 10, H-6);
  const cW = ctx.measureText("C").width;
  ctx.fillText("C", (W/2) - cW/2, H-6);
  const rW = ctx.measureText("R").width;
  ctx.fillText("R", W - 10 - rW, H-6);

  // Plot points (vectorscope-style)
  const sx=(W-16)/2;
  const sy=(H-28)/2; // leave room for labels
  ctx.fillStyle="rgba(229,231,235,.55)";
  for(const [L,R] of a.pts){
    const mid = (L + R) * 0.5;
    const side = (L - R) * 0.5;
    const x = W/2 + side*sx;
    const y = (H-18)/2 - mid*sy + 9; // keep centered in plot area
    ctx.fillRect(x,y,1,1);
  }
}

function drawAnalyzers(){
  if(!state.buffer) return;
  const a = analyzeAt(currentPlayheadSec());
  if(!a) return;
  drawMeter(a);
  drawImager(a);
  const avg = rangeAvgDbfs();
  const now = dbfs(Math.sqrt((a.rmsL*a.rmsL + a.rmsR*a.rmsR)*0.5));
  }

function forceDrawAnalyzersOnBoot(){
  try{
    const meter = $("meterCanvas");
    const imager = $("imagerCanvas");
    const needsResize = (canvas)=>{
      if(!canvas) return false;
      const rect = canvas.getBoundingClientRect();
      return rect.width <= 1 || rect.height <= 1;
    };
    const drawBoot = ()=>{
      // メーター：無音状態の目盛りだけでも描く（実データ不要）
      if(typeof drawMeter === "function"){
        drawMeter({ pkL: 1e-6, pkR: 1e-6, rmsL: 1e-6, rmsR: 1e-6 });
      }
      // イメージャ：枠とLR表記だけでも描く
      if(typeof drawImager === "function"){
        drawImager({ pts: [] });
      }
    };
    if(needsResize(meter) || needsResize(imager)){
      try{ if(meter) resizeCanvas(meter); }catch(_){}
      try{ if(imager) resizeCanvas(imager); }catch(_){}
      requestAnimationFrame(drawBoot);
      return;
    }
    drawBoot();
  }catch(e){
    console.warn("[UI] forceDrawAnalyzersOnBoot failed", e);
  }
}

let _bootDrawAnalyzersRunning = false;
function bootDrawAnalyzers(trigger){
  if(_bootDrawAnalyzersRunning) return;
  _bootDrawAnalyzersRunning = true;

  const meter = $("meterCanvas");
  const imager = $("imagerCanvas");
  if(!meter || !imager){
    _bootDrawAnalyzersRunning = false;
    return;
  }

  const maxTries = 6;
  let tries = 0;
  const hasRects = ()=>{
    const mr = meter.getBoundingClientRect();
    const ir = imager.getBoundingClientRect();
    return mr.width > 1 && mr.height > 1 && ir.width > 1 && ir.height > 1;
  };
  const step = ()=>{
    try{
      if(hasRects()){
        try{ resizeCanvas(meter); }catch(_){}
        try{ resizeCanvas(imager); }catch(_){}
        try{ forceDrawAnalyzersOnBoot(); }catch(_){}
        _bootDrawAnalyzersRunning = false;
        return;
      }
    }catch(_){}
    tries += 1;
    if(tries >= maxTries){
      _bootDrawAnalyzersRunning = false;
      return;
    }
    requestAnimationFrame(()=>{ requestAnimationFrame(step); });
  };
  requestAnimationFrame(()=>{ requestAnimationFrame(step); });
}

function _recoverProFileDockLayout(source){
  const dock = $("proFileDock");
  if(!dock) return;
  const rect = dock.getBoundingClientRect();
  if(rect.width > 1) return;
  const parents = [];
  const selectors = [".bottomRow", ".proBottomRow", "#analyzersRow", ".analyzers"];
  selectors.forEach((sel)=>{
    document.querySelectorAll(sel).forEach((el)=>{
      parents.push(el);
    });
  });
  parents.forEach((el)=>{
    try{
      el.style.width = "100%";
      el.style.minWidth = "0";
      el.style.flexBasis = "auto";
    }catch(_){}
  });
  try{ void dock.offsetHeight; }catch(_){}
  const rerun = ()=>{
    try{ resizeAll(); }catch(_){}
    try{ forceDrawAnalyzersOnBoot(); }catch(_){}
    try{ drawAll(); }catch(_){}
  };
  requestAnimationFrame(rerun);
  setTimeout(rerun, 90);
}

/* Draw all */
function _forceWaveRedraw(){
  // 入力フォーム操作中でも即時反映させるため、次フレームで確実に全描画
  try{
    requestAnimationFrame(()=>{
      try{ drawAll(); }catch(e){ try{ console.error(e); }catch(_){} }
    });
  }catch(_){
    try{ drawAll(); }catch(e){ try{ console.error(e); }catch(__){} }
  }
}

function drawAll(){
  drawWaveform();
  drawAnalyzers();
  $("timeHud").textContent = fmtTime(currentPlayheadSec());
  $("zoomHud").textContent = `x${state.zoom.toFixed(2)} / v${state.vZoom.toFixed(2)}`;
}
window.renderWaveform = window.renderWaveform || drawAll;

/* Export (same as-is) */

/* =========================================================
   WAV export (PCM16) + Cue chunks
   - Writes cue markers to WAV so "CUE信号情報"が保存されます
   - Writes:
     fmt  (PCM16)
     bext (optional: from textarea)
     iXML (optional: from textarea; stored as iXML chunk)
     cue  (cue points)
     LIST/adtl with labl (labels)
     data (PCM16 interleaved)
========================================================= */

function _u32(n){ return n>>>0; }
function _pad2(n){ return (n % 2) ? n+1 : n; }

function _writeStr(dv, off, s){
  for(let i=0;i<s.length;i++) dv.setUint8(off+i, s.charCodeAt(i));
  return off + s.length;
}
function _writeU16(dv, off, v){ dv.setUint16(off, v, true); return off+2; }
function _writeU32(dv, off, v){ dv.setUint32(off, v, true); return off+4; }
function _writeI16(dv, off, v){ dv.setInt16(off, v, true); return off+2; }
function _textBytesUtf8(str){ return new TextEncoder().encode(str); }


// ===== CMCD (BWF-J準拠寄せ: テンプレート配置を維持) =====
const CMCD_FIELDS = ["Ver", "素材略号", "素材コード", "共通コード", "局内コード1", "局内コード2", "素材制作日", "素材制作時間", "広告主名", "広告主担当者", "広告主連絡先", "広告会社名", "広告会社担当者", "広告会社連絡先", "制作会社名", "制作会社担当者", "制作会社連絡先", "ポスプロ名", "ポスプロ担当者", "ポスプロ連絡先", "素材タイトル", "素材秒数", "使用放送局名", "使用開始日", "使用開始時間", "素材有効開始日", "素材有効開始時刻", "素材有効最終日", "素材有効最終時刻", "制作会社コメント1", "制作会社コメント2", "ポスプロコメント1", "ポスプロコメント2", "広告会社コメント1", "広告会社コメント2", "放送局コメント1", "放送局コメント2"];
// layout: [{start,len}] * CMCD_FIELDS.length
function _sjisDecode(u8){
  // Prefer UTF-8 when it is *valid UTF-8*, otherwise fallback to Shift-JIS (CP932).
  // This avoids mojibake when sources use UTF-8, while staying compatible with BWF-J's ASCII/Shift-JIS guidance.
  try{
    try{
      return new TextDecoder("utf-8", {fatal:true}).decode(u8);
    }catch(_eFatal){
      // Some environments may not support {fatal:true}; fallback to replacement-char heuristic.
      const s = new TextDecoder("utf-8").decode(u8);
      if(s.indexOf("\uFFFD") !== -1) throw _eFatal;
      return s;
    }
  }catch(_eUtf8){
    try{ return new TextDecoder("shift-jis").decode(u8).replace(/\uFFFD/g,"?"); }catch(_eSjis1){
      try{ return new TextDecoder("shift_jis").decode(u8).replace(/\uFFFD/g,"?"); }catch(_eSjis2){
        return new TextDecoder("utf-8").decode(u8).replace(/\uFFFD/g,"?");
      }
    }
  }
}

// ===== CP932 TABLE START =====
// TextEncoder は shift-jis をサポートしないため、cp932(Shift-JIS互換) をテーブルでエンコードする。
// - 変換不能文字は '?' (0x3F) に置換。
// - デコードは TextDecoder('shift-jis') を使用（Chromeで利用可）。
const __CP932_CPS_B64  = "AAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAogCjAKcAqACsALAAsQC0ALYA1wD3AJEDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOjA6QDpQOmA6cDqAOpA7EDsgOzA7QDtQO2A7cDuAO5A7oDuwO8A70DvgO/A8ADwQPDA8QDxQPGA8cDyAPJAwEEEAQRBBIEEwQUBBUEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQmBCcEKAQpBCoEKwQsBC0ELgQvBDAEMQQyBDMENAQ1BDYENwQ4BDkEOgQ7BDwEPQQ+BD8EQARBBEIEQwREBEUERgRHBEgESQRKBEsETARNBE4ETwRRBBAgFSAWIBggGSAcIB0gICAhICUgJiAwIDIgMyA7IAMhFiEhISshYCFhIWIhYyFkIWUhZiFnIWghaSFwIXEhciFzIXQhdSF2IXcheCF5IZAhkSGSIZMh0iHUIQAiAiIDIgciCCILIhEiEiIaIh0iHiIfIiAiJSInIigiKSIqIisiLCIuIjQiNSI9IlIiYCJhImYiZyJqImsigiKDIoYihyKlIr8iEiNgJGEkYiRjJGQkZSRmJGckaCRpJGokayRsJG0kbiRvJHAkcSRyJHMkACUBJQIlAyUMJQ8lECUTJRQlFyUYJRslHCUdJSAlIyUkJSUlKCUrJSwlLyUwJTMlNCU3JTglOyU8JT8lQiVLJaAloSWyJbMlvCW9JcYlxyXLJc4lzyXvJQUmBiZAJkImaiZtJm8mADABMAIwAzAFMAYwBzAIMAkwCjALMAwwDTAOMA8wEDARMBIwEzAUMBUwHDAdMB8wQTBCMEMwRDBFMEYwRzBIMEkwSjBLMEwwTTBOME8wUDBRMFIwUzBUMFUwVjBXMFgwWTBaMFswXDBdMF4wXzBgMGEwYjBjMGQwZTBmMGcwaDBpMGowazBsMG0wbjBvMHAwcTByMHMwdDB1MHYwdzB4MHkwejB7MHwwfTB+MH8wgDCBMIIwgzCEMIUwhjCHMIgwiTCKMIswjDCNMI4wjzCQMJEwkjCTMJswnDCdMJ4woTCiMKMwpDClMKYwpzCoMKkwqjCrMKwwrTCuMK8wsDCxMLIwszC0MLUwtjC3MLgwuTC6MLswvDC9ML4wvzDAMMEwwjDDMMQwxTDGMMcwyDDJMMowyzDMMM0wzjDPMNAw0TDSMNMw1DDVMNYw1zDYMNkw2jDbMNww3TDeMN8w4DDhMOIw4zDkMOUw5jDnMOgw6TDqMOsw7DDtMO4w7zDwMPEw8jDzMPQw9TD2MPsw/DD9MP4wMTIyMjkypDKlMqYypzKoMgMzDTMUMxgzIjMjMyYzJzMrMzYzOzNJM0ozTTNRM1czezN8M30zfjOOM48znDOdM54zoTPEM80zAE4BTgNOB04ITglOCk4LTg1ODk4QThFOFE4VThZOF04YThlOHk4hTiZOKE4qTi1OMU4yTjZOOE45TjtOPE4/TkJOQ05FTktOTU5OTk9OVU5WTldOWE5ZTl1OXk5fTmJOcU5zTn5OgE6CToVOhk6ITolOik6LToxOjk6RTpJOlE6VTphOmU6bTpxOnk6fTqBOoU6iTqROpU6mTqhOq06sTq1Ork6wTrNOtk66TsBOwU7CTsROxk7HTspOy07NTs5Oz07UTtVO1k7XTthO2U7dTt5O307hTuNO5E7lTu1O7k7wTvJO9k73TvtO/E4ATwFPA08JTwpPDU8OTw9PEE8RTxpPHE8dTy9PME80TzZPOE85TzpPPE89T0NPRk9HT01PTk9PT1BPUU9TT1VPVk9XT1lPWk9bT1xPXU9eT2lPb09wT3NPdU92T3tPfE9/T4NPhk+IT4pPi0+NT49PkU+ST5RPlk+YT5pPm0+dT6BPoU+rT61Prk+vT7VPtk+/T8JPw0/ET8lPyk/NT85P0E/RT9RP10/YT9pP20/dT99P4U/jT+RP5U/uT+9P80/1T/ZP+E/6T/5P/08FUAZQCVALUA1QD1ARUBJQFFAWUBlQGlAeUB9QIVAiUCNQJFAlUCZQKFApUCpQK1AsUC1QNlA5UEBQQlBDUEZQR1BIUElQT1BQUFVQVlBaUFxQZVBsUHBQclB0UHVQdlB4UH1QgFCFUI1QkVCUUJhQmVCaUKxQrVCyULNQtFC1ULdQvlDCUMVQyVDKUM1Qz1DRUNVQ1lDYUNpQ3lDjUOVQ51DtUO5Q9FD1UPlQ+1AAUQFRAlEEUQlRElEUURVRFlEYURpRH1EhUSpRMlE3UTpRO1E8UT9RQFFBUUNRRFFFUUZRR1FIUUlRSlFLUUxRTVFOUVBRUlFUUVpRXFFiUWRRZVFoUWlRalFrUWxRbVFuUXFRdVF2UXdReFF8UYBRglGFUYZRiVGKUYxRjVGPUZBRkVGSUZNRlVGWUZdRmVGdUaBRolGkUaVRplGoUalRqlGrUaxRsFGxUbJRs1G0UbVRtlG3Ub1RvlHEUcVRxlHJUctRzFHNUdZR21HcUd1R4FHhUeZR51HpUepR7FHtUfBR8VH1UfZR+FH5UfpR/VH+UQBSA1IEUgZSB1IIUgpSC1IOUhFSFFIVUhdSHVIkUiVSJ1IpUipSLlIwUjNSNlI3UjhSOVI6UjtSQ1JEUkdSSlJLUkxSTVJPUlRSVlJbUl5SY1JkUmVSaVJqUm9ScFJxUnJSc1J0UnVSfVJ/UoNSh1KIUolSjVKRUpJSlFKbUpxSn1KgUqNSplKpUqpSq1KsUq1Sr1KxUrRStVK5UrxSvlLAUsFSw1LFUsdSyVLNUtJS1VLXUthS2VLbUt1S3lLfUuBS4lLjUuRS5lLnUvJS81L1UvhS+VL6Uv5S/1IAUwFTAlMFUwZTB1MIUw1TD1MQUxVTFlMXUxlTGlMdUyBTIVMjUyRTKlMvUzFTM1M4UzlTOlM7Uz9TQFNBU0NTRVNGU0dTSFNJU0pTTVNRU1JTU1NUU1dTWFNaU1xTXlNgU2ZTaVNuU29TcFNxU3JTc1N0U3VTd1N4U3tTf1OCU4RTk1OWU5hTmlOfU6BTpVOmU6hTqVOtU65TsFOyU7NTtlO7U8JTw1PIU8lTylPLU8xTzVPOU9RT1lPXU9lT21PdU99T4VPiU+NT5FPlU+hT6VPqU+tT7FPtU+5T71PwU/FT8lPzU/ZT91P4U/pTAVQDVARUCFQJVApUC1QMVA1UDlQPVBBUEVQbVB1UH1QgVCZUKVQrVCxULVQuVDZUOFQ5VDtUPFQ9VD5UQFRCVEZUSFRJVEpUTlRRVF9UaFRqVHBUcVRzVHVUdlR3VHtUfFR9VIBUhFSGVIpUi1SMVI5Uj1SQVJJUnFSiVKRUpVSoVKlUq1SsVK9UslSzVLhUvFS9VL5UwFTBVMJUxFTHVMhUyVTYVOFU4lTlVOZU6FTpVO1U7lTyVPpU/VT/VARVBlUHVQ9VEFUUVRZVLlUvVTFVM1U4VTlVPlVAVURVRVVGVUxVT1VTVVZVV1VcVV1VY1V7VXxVflWAVYNVhFWGVYdViVWKVYtVmFWZVZpVnFWdVZ5Vn1WnVahVqVWqVatVrFWuVbBVtlXEVcVVx1XUVdpV3FXfVeNV5FX3VflV/VX+VQZWCVYUVhZWF1YYVhtWKVYvVjFWMlY0VjZWOFZCVkxWTlZQVltWZFZoVmpWa1ZsVnRWeFZ6VoBWhlaHVopWj1aUVqBWolalVq5WtFa2VrxWwFbBVsJWw1bIVs5W0VbTVtdW2FbaVttW3lbgVuNW7lbwVvJW81b5VvpW/Vb/VgBXA1cEVwhXCVcLVw1XD1cSVxNXFlcYVxxXH1cmVydXKFctVzBXN1c4VztXQFdCV0dXSldOV09XUFdRV1lXYVdkV2VXZldpV2pXf1eCV4hXiVeLV5NXoFeiV6NXpFeqV6xXsFezV8BXw1fGV8dXyFfLV85X0lfTV9RX1lfcV99X4FfjV/RX91f5V/pX/FcAWAJYBVgGWApYC1gVWBlYHVghWCRYKlgvWDBYMVg0WDVYOlg9WEBYQVhKWEtYUVhSWFRYV1hYWFlYWlheWGJYaVhrWHBYclh1WHlYfliDWIVYk1iXWJxYnlifWKhYq1iuWLJYs1i4WLlYuli7WL5YwVjFWMdYyljMWNFY01jVWNdY2FjZWNxY3ljfWORY5VjrWOxY7ljvWPBY8VjyWPdY+Vj6WPtY/Fj9WAJZCVkKWQtZD1kQWRVZFlkYWRlZGlkbWRxZIlklWSdZKVkqWStZLFktWS5ZMVkyWTdZOFk+WURZR1lIWUlZTllPWVBZUVlTWVRZVVlXWVhZWllbWV1ZYFliWWNZZVlnWWhZaVlqWWxZbllzWXRZeFl9WYFZglmDWYRZilmNWZNZllmZWZtZnVmjWaRZpVmoWaxZslm5WbpZu1m+WcZZyVnLWdBZ0VnTWdRZ2VnaWdxZ5VnmWehZ6lnrWfZZ+1n/WQFaA1oJWhFaGFoaWhxaH1ogWiVaKVovWjVaNlo8WkBaQVpGWklaWlpiWmZaalpsWn9aklqaWptavFq9Wr5awVrCWslay1rMWtBa1lrXWuFa41rmWula+lr7WglbC1sMWxZbIlsqWyxbMFsyWzZbPltAW0NbRVtQW1FbVFtVW1ZbV1tYW1pbW1tcW11bX1tjW2RbZVtmW2lba1twW3Fbc1t1W3hbeluAW4NbhVuHW4hbiVuLW4xbjVuPW5Vbl1uYW5lbmlubW5xbnVufW6Jbo1ukW6VbpluuW7Bbs1u0W7Vbtlu4W7lbv1vAW8Jbw1vEW8VbxlvHW8lbzFvQW9Jb01vUW9hb21vdW95b31vhW+Jb5FvlW+Zb51voW+lb61vsW+5b8FvzW/Vb9lv4W/pb/lv/WwFcAlwEXAVcBlwHXAhcCVwKXAtcDVwOXA9cEVwTXBZcGlweXCBcIlwkXChcLVwxXDhcOVw6XDtcPFw9XD5cP1xAXEFcRVxGXEhcSlxLXE1cTlxPXFBcUVxTXFVcXlxgXGFcZFxlXGxcblxvXHFcdlx5XIxckFyRXJRcoVymXKhcqVyrXKxcsVyzXLZct1y4XLpcu1y8XL5cxVzHXNlc4FzhXOhc6VzqXO1c71zwXPVc9lz6XPtc/VwHXQtdDl0RXRRdFV0WXRddGF0ZXRpdG10fXSJdJ10pXUJdS11MXU5dUF1SXVNdXF1pXWxdbV1vXXNddl2CXYRdh12LXYxdkF2dXaJdrF2uXbdduF25XbpdvF29XcldzF3NXdBd0l3TXdZd213dXd5d4V3jXeVd5l3nXehd613uXfFd8l3zXfRd9V33Xftd/V3+XQJeA14GXgteDF4RXhZeGV4aXhteHV4lXiteLV4vXjBeM142XjdeOF49XkBeQ15EXkVeR15MXk5eVF5VXldeX15hXmJeY15kXnJec150XnVedl54Xnleel57XnxefV5+Xn9egV6DXoReh16KXo9elV6WXpdeml6cXqBepl6nXqterV61XrZet164XsFewl7DXsheyV7KXs9e0F7TXtZe2l7bXt1e317gXuFe4l7jXuhe6V7sXvBe8V7zXvRe9l73Xvhe+l77Xvxe/l7/XgFfA18EXwlfCl8LXwxfDV8PXxBfEV8TXxRfFV8WXxdfGF8bXx9fIV8lXyZfJ18pXy1fL18xXzRfNV83XzhfPF8+X0FfRV9IX0pfTF9OX1FfU19WX1dfWV9cX11fYV9iX2ZfZ19pX2pfa19sX21fcF9xX3Nfd195X3xff1+AX4Ffgl+DX4RfhV+HX4hfil+LX4xfkF+RX5Jfk1+XX5hfmV+eX6BfoV+oX6lfql+tX65fs1+0X7dfuV+8X71fw1/FX8xfzV/WX9df2F/ZX9xf3V/eX+Bf5F/rX/Bf8V/1X/hf+1/9X/9fDmAPYBBgEmAVYBZgGWAbYBxgHWAgYCFgJWAmYCdgKGApYCpgK2AvYDFgOmBBYEJgQ2BGYEpgS2BNYFBgUmBVYFlgWmBdYF9gYGBiYGNgZGBlYGhgaWBqYGtgbGBtYG9gcGB1YHdggWCDYIRghWCJYIpgi2CMYI1gkmCUYJZgl2CaYJtgn2CgYKNgpmCnYKlgqmCyYLNgtGC1YLZguGC8YL1gxWDGYMdg0WDTYNVg2GDaYNxg3mDfYOBg4WDjYOdg6GDwYPFg8mDzYPRg9mD3YPlg+mD7YABhAWEDYQZhCGEJYQ1hDmEPYRFhFWEaYRthH2EgYSFhJ2EoYSxhMGE0YTdhPGE9YT5hP2FCYURhR2FIYUphS2FMYU1hTmFTYVVhWGFZYVphXWFfYWJhY2FlYWdhaGFrYW5hb2FwYXFhc2F0YXVhdmF3YX5hgmGHYYphjmGQYZFhlGGWYZhhmWGaYaRhp2GpYathrGGuYbJhtmG6Yb5hw2HGYcdhyGHJYcphy2HMYc1h0GHjYeZh8mH0YfZh92H4Yfph/GH9Yf5h/2EAYghiCWIKYgxiDWIOYhBiEWISYhNiFGIWYhpiG2IdYh5iH2IhYiZiKmIuYi9iMGIyYjNiNGI4YjtiP2JAYkFiR2JIYkliS2JNYk5iU2JVYlhiW2JeYmBiY2JoYm5icWJ2YnlifGJ+Yn9igGKCYoNihGKJYopikWKSYpNilGKVYpZil2KYYptinGKeYqZiq2KsYrFitWK5YrtivGK9YsJixWLGYsdiyGLJYspizGLNYs9i0GLRYtJi02LUYtdi2GLZYtti3GLdYuBi4WLsYu1i7mLvYvFi82L1YvZi92L+Yv9iAWMCYwdjCGMJYwxjEWMZYx9jJ2MoYytjL2M6Yz1jPmM/Y0ljTGNNY09jUGNVY1djXGNnY2hjaWNrY25jcmN2Y3djemN7Y4Bjg2OIY4ljjGOOY49jkmOWY5hjm2OfY6BjoWOiY6NjpWOnY6hjqWOqY6tjrGOyY7RjtWO7Y75jwGPDY8RjxmPJY89j0GPSY9Zj2mPbY+Fj42PpY+5j9GP1Y/Zj+mMGZA1kD2QTZBZkF2QcZCZkKGQsZC1kNGQ2ZDpkPmRCZE5kWGRgZGdkaWRvZHZkeGR6ZINkiGSSZJNklWSaZJ1knmSkZKVkqWSrZK1krmSwZLJkuWS7ZLxkwWTCZMVkx2TNZM5k0mTUZNhk2mTgZOFk4mTjZOZk52TsZO9k8WTyZPRk9mT6ZP1k/mQAZQVlGGUcZR1lI2UkZSplK2UsZS9lNGU1ZTZlN2U4ZTllO2U+ZT9lRWVIZU1lTmVPZVFlVWVWZVdlWGVZZV1lXmViZWNlZmVsZXBlcmV0ZXVld2V4ZYJlg2WHZYhliWWMZY5lkGWRZZdlmWWbZZxln2WhZaRlpWWnZatlrGWtZa9lsGW3ZbllvGW9ZcFlw2XEZcVlxmXLZcxlz2XSZddl2WXbZeBl4WXiZeVl5mXnZehl6WXsZe1l8WX6ZftlAGYCZgNmBmYHZglmCmYMZg5mD2YTZhRmFWYcZh5mH2YgZiRmJWYnZihmLWYuZi9mMWY0ZjVmNmY7ZjxmP2ZBZkJmQ2ZEZklmS2ZPZlJmV2ZZZl1mXmZfZmJmZGZlZmZmZ2ZoZmlmbmZvZnBmc2Z0ZnZmemaBZoNmhGaHZohmiWaOZpFmlmaXZphmmWadZqBmomamZqtmrmayZrRmuGa5Zrxmvma/ZsFmxGbHZslm1mbZZtpm3GbdZuBm5mbpZvBm8mbzZvRm9Wb3Zvhm+Wb6Zvtm/Gb9Zv5m/2YAZwNnCGcJZwtnDWcOZw9nFGcVZxZnF2cbZx1nHmcfZyZnJ2coZypnK2csZy1nLmcxZzRnNmc3ZzhnOmc9Zz9nQWdGZ0lnTmdPZ1BnUWdTZ1ZnWWdcZ15nX2dgZ2FnYmdjZ2RnZWdmZ2pnbWdvZ3BncWdyZ3NndWd3Z3xnfmd/Z4Vnh2eJZ4tnjGeQZ5Vnl2eaZ5xnnWegZ6FnomemZ6lnr2ezZ7Rntme3Z7hnuWe7Z8BnwWfEZ8ZnymfOZ89n0GfRZ9Nn1GfYZ9pn3WfeZ+Jn5GfnZ+ln7GfuZ+9n8WfzZ/Rn9Wf7Z/5n/2cBaAJoA2gEaBNoFmgXaB5oIWgiaCloKmgraDJoNGg4aDloPGg9aEBoQWhCaENoRGhGaEhoTWhOaFBoUWhSaFNoVGhZaFxoXWhfaGNoZ2h0aHZod2h+aH9ogWiDaIVojWiPaJNolGiXaJtonWifaKBoomimaKdoqGitaK9osGixaLNotWi2aLloumi8aMRoxmjIaMloymjLaM1oz2jSaNRo1WjXaNho2mjfaOBo4WjjaOdo7mjvaPJo+Wj6aABpAWkEaQVpCGkLaQxpDWkOaQ9pEmkZaRppG2kcaSFpImkjaSVpJmkoaSppMGk0aTZpOWk9aT9pSmlTaVRpVWlZaVppXGldaV5pYGlhaWJpaGlqaWtpbWluaW9pc2l0aXVpd2l4aXlpfGl9aX5pgWmCaYppjmmRaZRplWmYaZtpnGmgaadprmmxabJptGm7ab5pv2nBacNpx2nKactpzGnNac5p0GnTadhp2Wndad5p4mnnaehp62ntafJp+Wn7af1p/2kCagVqCmoLagxqEmoTahRqF2oZahtqHmofaiFqImojailqKmorai5qMGo1ajZqOGo5ajpqPWpEakZqR2pIaktqWGpZal9qYWpiamZqa2pyanNqeGp+an9qgGqEao1qjmqQapdqnGqgaqJqo2qqaqxqrmqzarhqu2rBasJqw2rRatNq2mrbat5q32riauRq6Grqavpq+2oEawVrCmsSaxZrHWsfayBrIWsjaydrMms3azhrOWs6az1rPmtDa0drSWtMa05rUGtTa1RrWWtba19rYWtia2NrZGtma2lramtva3NrdGt4a3lre2t/a4Brg2uEa4ZriWuKa4trjWuVa5ZrmGuea6Rrqmura69rsWuya7NrtGu1a7drumu7a7xrv2vAa8VrxmvLa81rzmvSa9Nr1GvWa9hr22vfa+tr7Gvva/NrCGwPbBFsE2wUbBdsG2wjbCRsNGw3bDhsPmw/bEBsQWxCbE5sUGxVbFdsWmxcbF1sXmxfbGBsYmxobGpsb2xwbHJsc2x6bH1sfmyBbIJsg2yGbIhsjGyNbJBskmyTbJZsmWyabJtsoWyibKtsrmyxbLNsuGy5bLpsu2y8bL1svmy/bMFsxGzFbMlsymzMbNNs1WzXbNls2mzbbN1s4WzibONs5WzobOps72zwbPFs82wEbQttDG0SbRdtGW0bbR5tH20lbSltKm0rbTJtM201bTZtOG07bT1tPm1BbURtRW1ZbVptXG1jbWRtZm1pbWptbG1ubW9tdG13bXhteW2FbYdtiG2MbY5tk22VbZZtmW2bbZxtrG2vbbJttW24bbxtwG3FbcZtx23Lbcxtz23RbdJt1W3Ybdlt3m3hbeRt5m3obept623sbe5t8W3ybfNt9W33bfht+W36bftt/G0FbgduCG4JbgpuC24TbhVuGW4abhtuHW4fbiBuIW4jbiRuJW4mbiduKW4rbixuLW4ubi9uOG45bjpuPG4+bkNuSm5Nbk5uVm5YbltuXG5fbmdua25ubm9ucm52bn5uf26AboJujG6PbpBulm6YbpxunW6fbqJupW6qbq9usm62brduum69br9uwm7EbsVuyW7Lbsxu0W7TbtRu1W7dbt5u7G7vbvJu9G73bvhu/m7/bgFvAm8GbwlvD28RbxNvFG8VbyBvIm8jbytvLG8xbzJvOG8+bz9vQW9Fb1RvWG9bb1xvX29kb2ZvbW9ub29vcG90b3hvem98b4BvgW+Cb4Rvhm+Ib45vkW+Xb6Fvo2+kb6pvsW+zb7VvuW/Ab8Fvwm/Db8Zv1G/Vb9hv22/fb+Bv4W/kb+tv7G/ub+9v8W/zb/Vv9m/6b/5vAXAFcAdwCXALcA9wEXAVcBhwGnAbcB1wHnAfcCZwJ3AocCxwMHAycD5wTHBRcFhwY3BrcG9wcHB4cHxwfXCFcIlwinCOcJJwmXCrcKxwrXCucK9ws3C4cLlwunC7cMhwy3DPcNlw3XDfcPFw+XD9cARxCXEPcRRxGXEacRxxIXEmcTZxPHFGcUdxSXFMcU5xVXFWcVlxXHFicWRxZXFmcWdxaXFscW5xfXGEcYhxinGPcZRxlXGZcZ9xqHGscbFxuXG+ccFxw3HIcclxznHQcdJx1HHVcddx33HgceVx5nHncexx7XHucfVx+XH7cfxx/nH/cQZyDXIQchtyKHIqcixyLXIwcjJyNXI2cjpyO3I8cj1yPnI/ckByRnJHckhyS3JMclJyWHJZcltyXXJfcmFyYnJncmlycnJ0cnlyfXJ+coBygXKCcodyknKWcqByonKncqxyr3KxcrJytnK5cr5ywnLDcsRyxnLOctBy0nLXctly23LgcuFy4nLpcuxy7XL3cvhy+XL8cv1yCnMWcxdzG3Mccx1zH3MkcyVzKXMqcytzLnMvczRzNnM3cz5zP3NEc0VzTnNPc1dzY3Noc2pzcHNyc3Vzd3N4c3pze3OEc4dziXOLc5ZzqXOyc7Nzu3O9c8BzwnPIc8lzynPNc85z0nPWc95z4HPjc+Vz6nPtc+5z8XP1c/hz/nMDdAV0BnQHdAl0InQldCZ0KXQqdC50MnQzdDR0NXQ2dDp0P3RBdFV0WXRadFt0XHRedF90YHRidGN0ZHRpdGp0b3RwdHN0dnR+dIN0iXSLdJ50n3SidKd0sHS9dMp0z3TUdNx04HTidON05nTndOl07nTwdPF08nT2dPd0+HQBdQN1BHUFdQx1DXUOdRF1E3UVdRh1GnUcdR51H3UjdSV1JnUodSt1LHUvdTB1MXUydTN1N3U4dTp1O3U8dUR1RnVJdUp1S3VMdU11T3VRdVR1WXVadVt1XHVddWB1YnVkdWV1ZnVndWl1anVrdW11b3VwdXN1dHV2dXd1eHV/dYJ1hnWHdYl1inWLdY51j3WRdZR1mnWddaN1pXWrdbF1snWzdbV1uHW5dbx1vXW+dcJ1w3XFdcd1ynXNddJ11HXVddh12XXbdd514nXjdel18HXydfN19HX6dfx1/nX/dQF2CXYLdg12H3YgdiF2InYkdid2MHY0djt2QnZGdkd2SHZMdlJ2VnZYdlx2YXZidmd2aHZpdmp2bHZwdnJ2dnZ4dnp2e3Z8dn12fnaAdoJ2g3aEdoZ2h3aIdot2jnaQdpN2lnaZdpp2m3acdp52pnaudrB2tHa3drh2uXa6dr92wnbDdsZ2yHbKds120nbWdtd223bcdt5233bhduN25Hbldud26nbudvJ29Hb4dvt2/nYBdwR3B3cIdwl3C3cMdxt3HncfdyB3JHcldyZ3KXc3dzh3Onc8d0B3RndHd1p3W3dhd2N3ZXdmd2h3a3d5d353f3eLd453kXeed6B3pXesd613sHezd7Z3uXe7d7x3vXe/d8d3zXfXd9p323fcd+J343fld+d36Xftd+5373fzd/x3AngMeBJ4FHgVeCB4IXgleCZ4J3gyeDR4Ong/eEV4TnhdeGR4a3hseG94cnh0eHp4fHiBeIZ4h3iMeI14jniReJN4lXiXeJp4o3ineKl4qniveLV4uni8eL54wXjFeMZ4ynjLeNB40XjUeNp453joeOx473j0eP14AXkHeQ55EXkSeRl5JnkqeSt5LHkweTp5PHk+eUB5QXlHeUh5SXlQeVN5VXlWeVd5WnldeV55X3lgeWJ5ZXloeW15d3l6eX95gHmBeYR5hXmKeY15jnmPeZR5m3mdeaZ5p3mqea55sHmzebl5unm9eb55v3nAecF5yXnLedF50nnVedh533nheeN55Hnmeed56XnsefB5+3kAegh6C3oNeg56FHoXehh6GXoaehx6H3ogei56MXoyejd6O3o8ej16Pno/ekB6QnpDekZ6SXpNek56T3pQeld6YXpiemN6aXprenB6dHp2enl6enp9en96gXqDeoR6iHqSepN6lXqWepd6mHqfeql6qnqueq96sHq2erp6v3rDesR6xXrHesh6ynrLes16z3rRetJ603rVetl62nrcet1633rgeuF64nrjeuV65nrneup663rteu968Hr2evh6+Xr6ev96AnsEewZ7CHsKewt7D3sRexh7GXsbex57IHsleyZ7KHssezN7NXs2ezl7RXtGe0h7SXtLe0x7TXtPe1B7UXtSe1R7Vntde2V7Z3tse257cHtxe3R7dXt6e4Z7h3uLe417j3uSe5R7lXuXe5h7mXuae5x7nXuee597oXuqe617sXu0e7h7wHvBe8R7xnvHe8l7y3vMe8973Xvge+R75Xvme+l77Xvze/Z793sAfAd8DXwRfBJ8E3wUfBd8H3whfCN8J3wqfCt8N3w4fD18Pnw/fEB8Q3xMfE18T3xQfFR8VnxYfF98YHxkfGV8bHxzfHV8fnyBfIJ8g3yJfIt8jXyQfJJ8lXyXfJh8m3yffKF8onykfKV8p3yofKt8rXyufLF8snyzfLl8vXy+fMB8wnzFfMp8znzSfNZ82HzcfN5833zgfOJ853zvfPJ89Hz2fPh8+nz7fP58AH0CfQR9BX0GfQp9C30NfRB9FH0VfRd9GH0ZfRp9G30cfSB9IX0ifSt9LH0ufS99MH0yfTN9NX05fTp9P31CfUN9RH1FfUZ9SH1LfUx9Tn1PfVB9Vn1bfVx9Xn1hfWJ9Y31mfWh9bn1xfXJ9c311fXZ9eX19fYl9j32TfZl9mn2bfZx9n32gfaJ9o32rfax9rX2ufa99sH2xfbJ9tH21fbd9uH26fbt9vX2+fb99x33Kfct9z33RfdJ91X3Wfdh92n3cfd193n3gfeF95H3ofel97H3vffJ99H37fQF+BH4Ffgl+Cn4LfhJ+G34efh9+IX4ifiN+Jn4rfi5+MX4yfjV+N345fjp+O349fj5+QX5DfkZ+Sn5Lfk1+Un5UflV+Vn5Zflp+XX5efmZ+Z35pfmp+bX5wfnl+e358fn1+f36CfoN+iH6Jfop+jH6Ofo9+kH6SfpN+lH6Wfpt+nH42fzh/On9Ff0d/TH9Nf05/UH9Rf1R/VX9Yf19/YH9nf2h/aX9qf2t/bn9wf3J/dX93f3h/eX+Cf4N/hX+Gf4d/iH+Kf4x/jn+Uf5p/nX+ef6F/o3+kf6h/qX+uf69/sn+2f7h/uX+9f8F/xX/Gf8p/zH/Sf9R/1X/gf+F/5n/pf+t/8H/zf/l/+3/8fwCAAYADgASABYAGgAuADIAQgBKAFYAXgBiAGYAcgCGAKIAzgDaAO4A9gD+ARoBKgFKAVoBYgFqAXoBfgGGAYoBogG+AcIBygHOAdIB2gHeAeYB9gH6Af4CEgIWAhoCHgImAi4CMgJOAloCYgJqAm4CdgKGAooClgKmAqoCsgK2Ar4CxgLKAtIC6gMOAxIDGgMyAzoDWgNmA2oDbgN2A3oDhgOSA5YDvgPGA9ID4gPyA/YACgQWBBoEHgQiBCYEKgRqBG4EjgSmBL4ExgTOBOYE+gUaBS4FOgVCBUYFTgVSBVYFfgWWBZoFrgW6BcIFxgXSBeIF5gXqBf4GAgYKBg4GIgYqBj4GTgZWBmoGcgZ2BoIGjgaSBqIGpgbCBs4G1gbiBuoG9gb6Bv4HAgcKBxoHIgcmBzYHRgdOB2IHZgdqB34HggeOB5YHngeiB6oHtgfOB9IH6gfuB/IH+gQGCAoIFggeCCIIJggqCDIINgg6CEIISghaCF4IYghuCHIIegh+CKYIqgiuCLIIugjOCNYI2gjeCOII5gkCCR4JYglmCWoJdgl+CYoJkgmaCaIJqgmuCboJvgnGCcoJ2gneCeIJ+gouCjYKSgpmCnYKfgqWCpoKrgqyCrYKvgrGCs4K4grmCu4K9gsWC0YLSgtOC1ILXgtmC24Lcgt6C34LhguOC5YLmgueC64LxgvOC9IL5gvqC+4IBgwKDA4MEgwWDBoMJgw6DFoMXgxiDHIMjgyiDK4MvgzGDMoM0gzWDNoM4gzmDQINFg0mDSoNPg1CDUoNYg2KDc4N1g3eDe4N8g3+DhYOHg4mDioOOg5ODloOag56Dn4Ogg6KDqIOqg6uDsYO1g72DwYPFg8eDyoPMg86D04PWg9iD3IPfg+CD6YPrg++D8IPxg/KD9IP2g/eD+4P9gwOEBIQHhAuEDIQNhA6EE4QghCKEKYQqhCyEMYQ1hDiEPIQ9hEaESIRJhE6EV4RbhGGEYoRjhGaEaYRrhGyEbYRuhG+EcYR1hHeEeYR6hIKEhISLhJCElISZhJyEn4ShhK2EsoS0hLiEuYS7hLyEv4TBhMSExoTJhMqEy4TNhNCE0YTWhNmE2oTchOyE7oT0hPyE/4QAhQaFEYUThRSFFYUXhRiFGoUfhSGFJoUshS2FNYU9hUCFQYVDhUiFSYVKhUuFToVThVWFV4VYhVmFWoVjhWiFaYVqhWuFbYV3hX6FgIWEhYeFiIWKhZCFkYWUhZeFmYWbhZyFpIWmhaiFqYWqhauFrIWuha+FsIW5hbqFwYXJhc2Fz4XQhdWF3IXdheSF5YXpheqF94X5hfqF+4X+hQKGBoYHhgqGC4YThhaGF4YahiKGLYYvhjCGP4ZNhk6GUIZUhlWGWoZchl6GX4ZnhmuGcYZ5hnuGioaLhoyGk4aVhqOGpIaphqqGq4avhrCGtobEhsaGx4bJhsuGzYbOhtSG2Ybbht6G34bkhumG7Ibthu6G74b4hvmG+4b+hgCHAocDhwaHCIcJhwqHDYcRhxKHGIcahxyHJYcphzSHN4c7hz+HSYdLh0yHTodTh1WHV4dZh1+HYIdjh2aHaIdqh26HdId2h3iHf4eCh42Hn4eih6uHr4ezh7qHu4e9h8CHxIfGh8eHy4fQh9KH4Ifvh/KH9of3h/mH+4f+hwWIB4gNiA6ID4gRiBWIFoghiCKII4gniDGINog5iDuIQIhCiESIRohMiE2IUohTiFeIWYhbiF2IXohhiGKIY4hoiGuIcIhyiHWId4h9iH6If4iBiIKIiIiLiI2IkoiWiJeImYieiKKIpIiriK6IsIixiLSItYi3iL+IwYjCiMOIxIjFiM+I1IjViNiI2YjciN2I34jhiOiI8ojziPSI9Yj4iPmI/Ij9iP6IAokEiQeJCokMiRCJEokTiRyJHYkeiSWJKokriTaJOIk7iUGJQ4lEiUyJTYlWiV6JX4lgiWSJZolqiW2Jb4lyiXSJd4l+iX+JgYmDiYaJh4mIiYqJi4mPiZOJlomXiZiJmomhiaaJp4mpiaqJrImvibKJs4m6ib2Jv4nAidKJ2oncid2J44nmieeJ9In4iQCKAooDigiKCooMig6KEIoSihOKFooXihiKG4odih+KI4oliiqKLYoxijOKNIo2ijeKOoo7ijyKQYpGikiKUIpRilKKVIpViluKXopgimKKY4pmimmKa4psim2KbopwinGKcopzinmKfIqCioSKhYqHiomKjIqNipGKk4qVipiKmoqeiqCKoYqjiqSKpYqmiqeKqIqsiq2KsIqyirmKvIq+ir+KworEiseKy4rMis2Kz4rSitaK2orbityK3orfiuCK4YriiuSK5orniuuK7YruivGK84r2iveK+Ir6iv6KAIsBiwKLBIsHiwyLDosQixSLFosXixmLGosbix2LIIshiyaLKIsriyyLM4s5iz6LQYtJi0yLTotPi1OLVotYi1qLW4tci1+LZotri2yLb4twi3GLcot0i3eLfYt/i4CLg4uKi4yLjouQi5KLk4uWi5mLmos3jDqMP4xBjEaMSIxKjEyMToxQjFWMWoxhjGKMaoxrjGyMeIx5jHqMfIyCjIWMiYyKjIyMjYyOjJSMmIydjJ6MoIyhjKKMp4yojKmMqoyrjKyMrYyujK+MsIyyjLOMtIy2jLeMuIy7jLyMvYy/jMCMwYzCjMOMxIzHjMiMyozNjM6M0YzTjNqM24zcjN6M4IzijOOM5IzmjOqM7YzwjPSM+oz7jPyM/YwEjQWNB40IjQqNC40NjQ+NEI0SjRONFI0WjWSNZo1njWuNbY1wjXGNc410jXaNd42BjYWNio2ZjaONqI2zjbqNvo3CjcuNzI3PjdaN2o3bjd2N343hjeON6I3qjeuN743zjfWN/I3/jQiOCY4Kjg+OEI4djh6OH44qjjCONI41jkKORI5HjkiOSY5KjkyOUI5VjlmOX45gjmOOZI5yjnSOdo58joGOhI6FjoeOio6Ljo2OkY6TjpSOmY6hjqqOq46sjq+OsI6xjr6OxY7GjsiOyo7LjsyOzY7PjtKO247fjuKO447rjviO+478jv2O/o4DjwWPCY8KjwyPEo8TjxSPFY8ZjxuPHI8djx+PJo8pjyqPL48zjziPOY87jz6PP49Cj0SPRY9Gj0mPTI9Nj06PV49cj1+PYY9ij2OPZI+bj5yPno+fj6OPp4+oj62Pro+vj7CPsY+yj7ePuo+7j7yPv4/Cj8SPxY/Oj9GP1I/aj+KP5Y/mj+mP6o/rj+2P74/wj/SP94/4j/mP+o/9jwCQAZADkAWQBpALkA2QDpAPkBCQEZATkBSQFZAWkBeQGZAakB2QHpAfkCCQIZAikCOQJ5AukDGQMpA1kDaQOJA5kDyQPpBBkEKQRZBHkEmQSpBLkE2QTpBPkFCQUZBSkFOQVJBVkFaQWJBZkFyQXpBgkGGQY5BlkGeQaJBpkG2QbpBvkHKQdZB2kHeQeJB6kHyQfZB/kICQgZCCkIOQhJCHkImQipCPkJGQo5CmkKiQqpCvkLGQtZC4kMGQypDOkNuQ3pDhkOKQ5JDokO2Q9ZD3kP2QApESkRWRGZEnkS2RMJEykUmRSpFLkUyRTZFOkVKRVJFWkViRYpFjkWWRaZFqkWyRcpFzkXWRd5F4kYKRh5GJkYuRjZGQkZKRl5GckaKRpJGqkauRr5G0kbWRuJG6kcCRwZHGkceRyJHJkcuRzJHNkc6Rz5HQkdGR1pHXkdiR2pHbkdyR3ZHekd+R4ZHjkeSR5ZHmkeeR7ZHukfWR9pH8kf+RBpIKkg2SDpIQkhGSFJIVkh6SKZIskjSSN5I5kjqSPJI/kkCSRJJFkkiSSZJLkk6SUJJRkleSWZJakluSXpJikmSSZpJnknGSd5J4kn6SgJKDkoWSiJKRkpOSlZKWkpiSmpKbkpySp5KtkreSuZLPktCS0pLTktWS15LZkuCS5JLnkumS6pLtkvKS85L4kvmS+pL7kvyS/5ICkwaTD5MQkxiTGZMakx2THpMgkyGTIpMjkyWTJpMokyuTLJMuky+TMpM1kzqTO5NEk0iTS5NNk1STVpNXk1uTXJNgk2yTbpNwk3WTfJN+k4yTlJOWk5eTmpOkk6eTrJOtk66TsJO5k8OTxpPIk9CT0ZPWk9eT2JPdk96T4ZPkk+WT6JP4kwOUB5QQlBOUFJQYlBmUGpQhlCuUMZQ1lDaUOJQ6lEGURJRFlEiUUZRSlFOUWpRblF6UYJRilGqUcJR1lHeUfJR9lH6Uf5SBlHeVgJWClYOVh5WJlYqVi5WPlZGVkpWTlZSVlpWYlZmVoJWilaOVpJWllaeVqJWtlbKVuZW7lbyVvpXDlceVypXMlc2V1JXVldaV2JXcleGV4pXllRyWIZYoliqWLpYvljKWO5Y/lkCWQpZElkuWTJZNlk+WUJZbllyWXZZell+WYpZjlmSWZZZmlmqWbJZwlnKWc5Z1lnaWd5Z4lnqWfZaFloaWiJaKlouWjZaOlo+WlJaVlpeWmJaZlpuWnJadlqCWo5anlqiWqpavlrCWsZaylrSWtpa3lriWuZa7lryWwJbBlsSWxZbGlseWyZbLlsyWzZbOltGW1ZbWltmW25bcluKW45boluqW65bwlvKW9pb3lvmW+5YAlwSXBpcHlwiXCpcNlw6XD5cRlxOXFpcZlxyXHpcklyeXKpcwlzKXM5c4lzmXO5c9lz6XQpdDl0SXRpdIl0mXTZdPl1GXUpdVl1aXWZdcl16XYJdhl2KXZJdml2iXaZdrl22XcZd0l3mXepd8l4GXhJeFl4aXi5eNl4+XkJeYl5yXoJejl6aXqJerl62Xs5e0l8OXxpfIl8uX05fcl+2X7pfyl/OX9Zf2l/uX/5cBmAKYA5gFmAaYCJgMmA+YEJgRmBKYE5gXmBiYGpghmCSYLJgtmDSYN5g4mDuYPJg9mEaYS5hMmE2YTphPmFSYVZhXmFiYW5hemGWYZ5hrmG+YcJhxmHOYdJiomKqYr5ixmLaYw5jEmMaY25jcmN+Y4pjpmOuY7ZjumO+Y8pj0mPyY/Zj+mAOZBZkJmQqZDJkQmRKZE5kUmRiZHZkemSCZIZkkmSeZKJksmS6ZPZk+mUKZRZlJmUuZTJlQmVGZUplVmVeZlpmXmZiZmZmemaWZqJmsma2ZrpmzmbSZvJnBmcSZxZnGmciZ0JnRmdKZ1ZnYmduZ3ZnfmeKZ7ZnumfGZ8pn4mfuZ/5kBmgWaDpoPmhKaE5oZmiiaK5owmjeaPppAmkKaQ5pFmk2aTppVmleaWppbml+aYppkmmWaaZpqmmuaqJqtmrCauJq8msCaxJrPmtGa05rUmtia2Zrcmt6a35rimuOa5prqmuua7Zrumu+a8Zr0mvea+5oGmxibGpsfmyKbI5slmyebKJspmyqbLpsvmzGbMps7mzybQZtCm0ObRJtFm02bTptPm1GbVJtYm1qbb5tym3SbdZuDm46bj5uRm5Kbk5uWm5ebn5ugm6ibqpurm62brpuxm7SbuZu7m8CbxpvJm8qbz5vRm9Kb1JvWm9ub4Zvim+Ob5Jvom/Cb8Zvym/WbAJwEnAacCJwJnAqcDJwNnBCcEpwTnBScFZwbnCGcJJwlnC2cLpwvnDCcMpw5nDqcO5w+nEacR5xInFKcV5xanGCcZ5x2nHic5ZznnOmc65zsnPCc85z0nPacA50GnQedCJ0JnQ6dEp0VnRudH50jnSadKJ0qnSudLJ07nT6dP51BnUSdRp1InVCdUZ1ZnVydXZ1enWCdYZ1knWudbJ1vnXCdcp16nYediZ2PnZqdpJ2pnaudr52ynbSduJ26nbudwZ3CncSdxp3PndOd2Z3mne2d753ynfid+Z36nf2dGZ4anhueHp51nnieeZ59nn+egZ6InouejJ6RnpKek56VnpeenZ6fnqWepp6pnqqerZ64nrmeup67nryevp6/nsSezJ7Nns6ez57QntGe0p7Untie2Z7bntye3Z7enuCe5Z7onu+e9J72nvee+Z77nvye/Z4HnwifDp8TnxWfIJ8hnyyfO58+n0qfS59On0+fUp9Un1+fYJ9hn2KfY59mn2efap9sn3Kfdp93n42flZ+cn52foJ8A4AHgAuAD4ATgBeAG4AfgCOAJ4ArgC+AM4A3gDuAP4BDgEeAS4BPgFOAV4BbgF+AY4BngGuAb4BzgHeAe4B/gIOAh4CLgI+Ak4CXgJuAn4CjgKeAq4CvgLOAt4C7gL+Aw4DHgMuAz4DTgNeA24DfgOOA54DrgO+A84D3gPuA/4EDgQeBC4EPgROBF4EbgR+BI4EngSuBL4EzgTeBO4E/gUOBR4FLgU+BU4FXgVuBX4FjgWeBa4FvgXOBd4F7gX+Bg4GHgYuBj4GTgZeBm4GfgaOBp4Grga+Bs4G3gbuBv4HDgceBy4HPgdOB14Hbgd+B44HngeuB74HzgfeB+4H/ggOCB4ILgg+CE4IXghuCH4IjgieCK4IvgjOCN4I7gj+CQ4JHgkuCT4JTgleCW4JfgmOCZ4Jrgm+Cc4J3gnuCf4KDgoeCi4KPgpOCl4Kbgp+Co4KngquCr4KzgreCu4K/gsOCx4LLgs+C04LXgtuC34LjgueC64LvgvOC94L7gv+DA4MHgwuDD4MTgxeDG4MfgyODJ4Mrgy+DM4M3gzuDP4NDg0eDS4NPg1ODV4Nbg1+DY4Nng2uDb4Nzg3eDe4N/g4ODh4OLg4+Dk4OXg5uDn4Ojg6eDq4Ovg7ODt4O7g7+Dw4PHg8uDz4PTg9eD24Pfg+OD54Prg++D84P3g/uD/4ADhAeEC4QPhBOEF4QbhB+EI4QnhCuEL4QzhDeEO4Q/hEOER4RLhE+EU4RXhFuEX4RjhGeEa4RvhHOEd4R7hH+Eg4SHhIuEj4SThJeEm4SfhKOEp4SrhK+Es4S3hLuEv4TDhMeEy4TPhNOE14TbhN+E44TnhOuE74TzhPeE+4T/hQOFB4ULhQ+FE4UXhRuFH4UjhSeFK4UvhTOFN4U7hT+FQ4VHhUuFT4VThVeFW4VfhWOFZ4VrhW+Fc4V3hXuFf4WDhYeFi4WPhZOFl4WbhZ+Fo4WnhauFr4WzhbeFu4W/hcOFx4XLhc+F04XXhduF34XjheeF64XvhfOF94X7hf+GA4YHhguGD4YThheGG4YfhiOGJ4Yrhi+GM4Y3hjuGP4ZDhkeGS4ZPhlOGV4Zbhl+GY4ZnhmuGb4ZzhneGe4Z/hoOGh4aLho+Gk4aXhpuGn4ajhqeGq4avhrOGt4a7hr+Gw4bHhsuGz4bThteG24bfhuOG54brhu+G84b3hvuG/4cDhweHC4cPhxOHF4cbhx+HI4cnhyuHL4czhzeHO4c/h0OHR4dLh0+HU4dXh1uHX4djh2eHa4dvh3OHd4d7h3+Hg4eHh4uHj4eTh5eHm4efh6OHp4erh6+Hs4e3h7uHv4fDh8eHy4fPh9OH14fbh9+H44fnh+uH74fzh/eH+4f/hAOIB4gLiA+IE4gXiBuIH4gjiCeIK4gviDOIN4g7iD+IQ4hHiEuIT4hTiFeIW4hfiGOIZ4hriG+Ic4h3iHuIf4iDiIeIi4iPiJOIl4ibiJ+Io4iniKuIr4iziLeIu4i/iMOIx4jLiM+I04jXiNuI34jjiOeI64jviPOI94j7iP+JA4kHiQuJD4kTiReJG4kfiSOJJ4kriS+JM4k3iTuJP4lDiUeJS4lPiVOJV4lbiV+JY4lniWuJb4lziXeJe4l/iYOJh4mLiY+Jk4mXiZuJn4mjiaeJq4mvibOJt4m7ib+Jw4nHicuJz4nTideJ24nfieOJ54nrie+J84n3ifuJ/4oDigeKC4oPihOKF4obih+KI4oniiuKL4ozijeKO4o/ikOKR4pLik+KU4pXiluKX4pjimeKa4pvinOKd4p7in+Kg4qHiouKj4qTipeKm4qfiqOKp4qriq+Ks4q3iruKv4rDiseKy4rPitOK14rbit+K44rniuuK74rziveK+4r/iwOLB4sLiw+LE4sXixuLH4sjiyeLK4svizOLN4s7iz+LQ4tHi0uLT4tTi1eLW4tfi2OLZ4tri2+Lc4t3i3uLf4uDi4eLi4uPi5OLl4ubi5+Lo4uni6uLr4uzi7eLu4u/i8OLx4vLi8+L04vXi9uL34vji+eL64vvi/OL94v7i/+IA4wHjAuMD4wTjBeMG4wfjCOMJ4wrjC+MM4w3jDuMP4xDjEeMS4xPjFOMV4xbjF+MY4xnjGuMb4xzjHeMe4x/jIOMh4yLjI+Mk4yXjJuMn4yjjKeMq4yvjLOMt4y7jL+Mw4zHjMuMz4zTjNeM24zfjOOM54zrjO+M84z3jPuM/40DjQeNC40PjRONF40bjR+NI40njSuNL40zjTeNO40/jUONR41LjU+NU41XjVuNX41jjWeNa41vjXONd417jX+Ng42HjYuNj42TjZeNm42fjaONp42rja+Ns423jbuNv43DjceNy43PjdON143bjd+N443njeuN743zjfeN+43/jgOOB44Ljg+OE44XjhuOH44jjieOK44vjjOON447jj+OQ45HjkuOT45TjleOW45fjmOOZ45rjm+Oc453jnuOf46DjoeOi46PjpOOl46bjp+Oo46njquOr46zjreOu46/jsOOx47Ljs+O047XjtuO347jjueO647vjvOO9477jv+PA48HjwuPD48TjxePG48fjyOPJ48rjy+PM483jzuPP49Dj0ePS49Pj1OPV49bj1+PY49nj2uPb49zj3ePe49/j4OPh4+Lj4+Pk4+Xj5uPn4+jj6ePq4+vj7OPt4+7j7+Pw4/Hj8uPz4/Tj9eP24/fj+OP54/rj++P84/3j/uP/4wDkAeQC5APkBOQF5AbkB+QI5AnkCuQL5AzkDeQO5A/kEOQR5BLkE+QU5BXkFuQX5BjkGeQa5BvkHOQd5B7kH+Qg5CHkIuQj5CTkJeQm5CfkKOQp5CrkK+Qs5C3kLuQv5DDkMeQy5DPkNOQ15DbkN+Q45DnkOuQ75DzkPeQ+5D/kQORB5ELkQ+RE5EXkRuRH5EjkSeRK5EvkTORN5E7kT+RQ5FHkUuRT5FTkVeRW5FfkWORZ5FrkW+Rc5F3kXuRf5GDkYeRi5GPkZORl5GbkZ+Ro5GnkauRr5GzkbeRu5G/kcORx5HLkc+R05HXkduR35HjkeeR65HvkfOR95H7kf+SA5IHkguSD5ITkheSG5IfkiOSJ5Irki+SM5I3kjuSP5JDkkeSS5JPklOSV5Jbkl+SY5JnkmuSb5JzkneSe5J/koOSh5KLko+Sk5KXkpuSn5KjkqeSq5KvkrOSt5K7kr+Sw5LHksuSz5LTkteS25LfkuOS55Lrku+S85L3kvuS/5MDkweTC5MPkxOTF5Mbkx+TI5MnkyuTL5MzkzeTO5M/k0OTR5NLk0+TU5NXk1uTX5Njk2eTa5Nvk3OTd5N7k3+Tg5OHk4uTj5OTk5eTm5Ofk6OTp5Ork6+Ts5O3k7uTv5PDk8eTy5PPk9OT15Pbk9+T45Pnk+uT75Pzk/eT+5P/kAOUB5QLlA+UE5QXlBuUH5QjlCeUK5QvlDOUN5Q7lD+UQ5RHlEuUT5RTlFeUW5RflGOUZ5RrlG+Uc5R3lHuUf5SDlIeUi5SPlJOUl5SblJ+Uo5SnlKuUr5SzlLeUu5S/lMOUx5TLlM+U05TXlNuU35TjlOeU65TvlPOU95T7lP+VA5UHlQuVD5UTlReVG5UflSOVJ5UrlS+VM5U3lTuVP5VDlUeVS5VPlVOVV5VblV+VY5VnlWuVb5VzlXeVe5V/lYOVh5WLlY+Vk5WXlZuVn5WjlaeVq5WvlbOVt5W7lb+Vw5XHlcuVz5XTldeV25XfleOV55Xrle+V85X3lfuV/5YDlgeWC5YPlhOWF5Yblh+WI5YnliuWL5YzljeWO5Y/lkOWR5ZLlk+WU5ZXlluWX5ZjlmeWa5ZvlnOWd5Z7ln+Wg5aHlouWj5aTlpeWm5aflqOWp5arlq+Ws5a3lruWv5bDlseWy5bPltOW15bblt+W45bnluuW75bzlveW+5b/lwOXB5cLlw+XE5cXlxuXH5cjlyeXK5cvlzOXN5c7lz+XQ5dHl0uXT5dTl1eXW5dfl2OXZ5drl2+Xc5d3l3uXf5eDl4eXi5ePl5OXl5ebl5+Xo5enl6uXr5ezl7eXu5e/l8OXx5fLl8+X05fXl9uX35fjl+eX65fvl/OX95f7l/+UA5gHmAuYD5gTmBeYG5gfmCOYJ5grmC+YM5g3mDuYP5hDmEeYS5hPmFOYV5hbmF+YY5hnmGuYb5hzmHeYe5h/mIOYh5iLmI+Yk5iXmJuYn5ijmKeYq5ivmLOYt5i7mL+Yw5jHmMuYz5jTmNeY25jfmOOY55jrmO+Y85j3mPuY/5kDmQeZC5kPmROZF5kbmR+ZI5knmSuZL5kzmTeZO5k/mUOZR5lLmU+ZU5lXmVuZX5ljmWeZa5lvmXOZd5l7mX+Zg5mHmYuZj5mTmZeZm5mfmaOZp5mrma+Zs5m3mbuZv5nDmceZy5nPmdOZ15nbmd+Z45nnmeuZ75nzmfeZ+5n/mgOaB5oLmg+aE5oXmhuaH5ojmieaK5ovmjOaN5o7mj+aQ5pHmkuaT5pTmleaW5pfmmOaZ5prmm+ac5p3mnuaf5qDmoeai5qPmpOal5qbmp+ao5qnmquar5qzmreau5q/msOax5rLms+a05rXmtua35rjmuea65rvmvOa95r7mv+bA5sHmwubD5sTmxebG5sfmyObJ5srmy+bM5s3mzubP5tDm0ebS5tPm1ObV5tbm1+bY5tnm2ubb5tzm3ebe5t/m4Obh5uLm4+bk5uXm5ubn5ujm6ebq5uvm7Obt5u7m7+bw5vHm8ubz5vTm9eb25vfm+Ob55vrm++b85v3m/ub/5gDnAecC5wPnBOcF5wbnB+cI5wnnCucL5wznDecO5w/nEOcR5xLnE+cU5xXnFucX5xjnGeca5xvnHOcd5x7nH+cg5yHnIucj5yTnJecm5yfnKOcp5yrnK+cs5y3nLucv5zDnMecy5zPnNOc15zbnN+c45znnOuc75zznPec+5z/nQOdB50LnQ+dE50XnRudH50jnSedK50vnTOdN507nT+dQ51HnUudT51TnVedW51fn8Pjx+PL48/gp+dz5DvoP+hD6EfoS+hP6FPoV+hb6F/oY+hn6Gvob+hz6Hfoe+h/6IPoh+iL6I/ok+iX6Jvon+ij6Kfoq+iv6LPot+gH/Av8D/wT/Bf8G/wf/CP8J/wr/C/8M/w3/Dv8P/xD/Ef8S/xP/FP8V/xb/F/8Y/xn/Gv8b/xz/Hf8e/x//IP8h/yL/I/8k/yX/Jv8n/yj/Kf8q/yv/LP8t/y7/L/8w/zH/Mv8z/zT/Nf82/zf/OP85/zr/O/88/z3/Pv8//0D/Qf9C/0P/RP9F/0b/R/9I/0n/Sv9L/0z/Tf9O/0//UP9R/1L/U/9U/1X/Vv9X/1j/Wf9a/1v/XP9d/17/Yf9i/2P/ZP9l/2b/Z/9o/2n/av9r/2z/bf9u/2//cP9x/3L/c/90/3X/dv93/3j/ef96/3v/fP99/37/f/+A/4H/gv+D/4T/hf+G/4f/iP+J/4r/i/+M/43/jv+P/5D/kf+S/5P/lP+V/5b/l/+Y/5n/mv+b/5z/nf+e/5//4P/h/+L/4//k/+X/";
const __CP932_VALS_B64 = "AAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAkYGSgZiBToHKgYuBfYFMgfeBfoGAgZ+DoIOhg6KDo4Okg6WDpoOng6iDqYOqg6uDrIOtg66Dr4Owg7GDsoOzg7SDtYO2g7+DwIPBg8KDw4PEg8WDxoPHg8iDyYPKg8uDzIPNg86Dz4PQg9GD0oPTg9SD1YPWg0aEQIRBhEKEQ4REhEWER4RIhEmESoRLhEyETYROhE+EUIRRhFKEU4RUhFWEVoRXhFiEWYRahFuEXIRdhF6EX4RghHCEcYRyhHOEdIR1hHeEeIR5hHqEe4R8hH2EfoSAhIGEgoSDhISEhYSGhIeEiISJhIqEi4SMhI2EjoSPhJCEkYR2hF2BXIFhgWWBZoFngWiB9YH2gWSBY4HxgYyBjYGmgY6BgoeEh/CBVIdVh1aHV4dYh1mHWodbh1yHXYfv7vDu8e7y7vPu9O717vbu9+747qmBqoGogauBy4HMgc2B3YHOgd6BuIG5gZSHfIHjgeWBh4GYh9qBYYHIgcmBv4G+geeB6IGTh4iB5oHkgeCBgoHfgYWBhoHhgeKBvIG9gbqBu4HbgZmH3IFAh0GHQodDh0SHRYdGh0eHSIdJh0qHS4dMh02HTodPh1CHUYdSh1OHn4SqhKCEq4ShhKyEooSthKSEr4SjhK6EpYS6hLWEsISnhLyEt4SyhKaEtoS7hLGEqIS4hL2Es4SphLmEvoS0hKGBoIGjgaKBpYGkgZ+BnoGbgZ2BnIH8gZqBmYGKgYmB9IHzgfKBQIFBgUKBVoFYgVmBWoFxgXKBc4F0gXWBdoF3gXiBeYF6gaeBrIFrgWyBYIGAh4GHn4KggqGCooKjgqSCpYKmgqeCqIKpgqqCq4Ksgq2CroKvgrCCsYKygrOCtIK1graCt4K4grmCuoK7gryCvYK+gr+CwILBgsKCw4LEgsWCxoLHgsiCyYLKgsuCzILNgs6Cz4LQgtGC0oLTgtSC1YLWgteC2ILZgtqC24Lcgt2C3oLfguCC4YLiguOC5ILlguaC54LogumC6oLrguyC7YLugu+C8ILxgkqBS4FUgVWBQINBg0KDQ4NEg0WDRoNHg0iDSYNKg0uDTINNg06DT4NQg1GDUoNTg1SDVYNWg1eDWINZg1qDW4Ncg12DXoNfg2CDYYNig2ODZINlg2aDZ4Nog2mDaoNrg2yDbYNug2+DcINxg3KDc4N0g3WDdoN3g3iDeYN6g3uDfIN9g36DgIOBg4KDg4OEg4WDhoOHg4iDiYOKg4uDjIONg46Dj4OQg5GDkoOTg5SDlYOWg0WBW4FSgVOBioeLh4yHhYeGh4eHiIeJh2WHaYdgh2OHYYdrh2qHZIdsh2aHbodfh22HYodnh2iHfoePh46HjYdyh3OHb4dwh3GHdYd0h4OH6oiakrWOnJbkj0+O44+6iXOVXpegmE6JjoqhmKKQwJl1i7iV5Y+8l8CVTO2imIaSo5j4i6SY24pPkuWOpZimmKeYVJR2i1aU4ZPBjFKWaOWomOaPqZizieOL7oznlqSbkJf7k6OKVIuqmKuYuZdcl4iRrZiWjvGTsJhdid2M3IzkiGqYaZixjZ+IsZiymLOYU5a0mPCM5YiSlpyLnYuei+CSupe1mLaYt5hskFmPbZC8mLqYu5h3i6GN7om5mLiYp5VljmSOvJG9mHSV5ZBXgb6YwJhN7eOR35fIiL+YvInCi4eSj4zBmEOUTu1P7emKUO3CmMmI3ozqipqVsJR4i++J5Zhgk4yUxJi6lOCXTJBR7WaOl46+ic+SQZLImMqI4ZJaj7KNQ5fMkb2JUu3HmF2Xw5jFmOyNxphDm86Y0ZjPmMCJuZXJmM2Y8YxnjqSK0pjKmFTt4ZeYjsuY0JhT7Vbt05jMmFXtn4vLiKCLv4lEm5mWjpXyjE6QtZfWlVeMo5HiiUXtco9X7deY3JjamNWYrZHYmNuY2ZjbldaYTZCTlt2Y3phDj+uYb5RVleaY7pW0ieqYWu3kmO2YcZHCjHuUxeDsmHyT4Zj0jPOM35hb7diO55hZ7e2VbJLjmJGM4JjomOKYz5fpmGCY5IuQjFjtXu3umFzt75jzmMyIzpXymPGY9Zj0mOKSkoz2mF3tw46kkeOS9Iv3mFWL+Jj6mFSWhoxf7VCO9ZT5mMONYpf8mEKZ+5jCjZ2PWIxDmc2LQJlBma2TnJGhi2yWRJlh7buXRZlImUaZbZFHmUmZYO1LmUqZxpVWi02ZTpmtiUyZ8o5RmVCZT5nUmFKZno9TmUSX15ZVmVSZV5lWmViZWZnyiLOMWoxbj5uSoovmkPWMYu2OjVuZxpZlk5mOWplcmX2TlYpdmWPt/JNTkV+ZYJmqlPaMWphhmaSLupW0ke+LVJOTjGKZY5ngk36JZpn7jWWZxI1nmezjaJlglmmZaplrmeePyo5k7aWKbplsmbuWbZl5lW+ZcJlxmX6TdZlzmXSZcpnhjXaZ6Jbil3eZZe2mkHiZeY95mZySvZeAk8OZepmj6sOLe5l9loiP+pF9meKTZu1+mYCZTYqBmaWLypOaiW+Pn5SCmYGTbpCDmaqV2JCgiqeKhJmGmVmMhZln7fGXiY+7lMqVh5mYl4iZiZmek4qZp5D8jZSMi5lojo+N5JKNmaWR7Y2OmY+ZT5GMmZGZVZaEjZCZlYzcjY2UlJmSmZuV6I+bmYSKlZmTmW6Rl5mWmWOKgIycmauXmJmdmZqZmZnNl2jt94zBifKXae2Vj3eThY2gmaGZW+7jl0qYo5n4jKKZTopq7aSZdZa6kkWX15WlmdPorpOmmaiKsZZr7Z+Pp5nllauZqJComc6LqZmpik2MrJmtma6Zr5nZjvmM3JZs7eaW9ZPvlbCZbe2xmbOZtZm0mbaZu4lrlvqNt5l4kaCPp4u4mW7t2ZS5mbqZu5m8mUOV5ovjiL2TvZlcj+eQv5m+maGP34zBmbyUwpnalLKR7JGmi+yTUJKOlG2WxJnokFSMxZnGmUuJ84jrim/tppFwi5GXyZm1iciZqIvKme+WcO3LmdCX+oy0jMyZzpnNmX6QWIl9ic+Z0Jlx7bWM0ZmOi1GO0pmUlrONeYtGl2+RvZT7jmaP5o7zjpaPvpRy7dWZYolwkfuMw4zli9mZQJL8kamLoo/amdiZwonkkbaOao5FiZCKho1pjtuZ3Jloi2WKh41ni92SRImvk7yWQI2Zl2aT/IxOjOWZ4YtpltuU5Jncit+Z4JnimeOZeouBkKuV4ZndmeGM3plDmPCV5pLgjJCN5pnbk+qZ/I70ju2Z65mhluiZ8Znsme+ZxIy9lvCZ8pn0mXXt7o1hmOmZ55nzme6ZdO32mUKa+Jn8mXbtQJr5mV2a541QiveZRJr0iEOao4hplUGa+pn1mfuZxo1FmvWITppGmkeao4+JlkyaS5pOk02aSpp37VOJtI1PkEiagpNJmqCIU5pCl6WPWZpYmk+awZFQmu2RVZqkj1Ka4pZbjFaaV5pUmlqaUZpgmmWaYZpcmmaaUJF47WiaQY1emp2SYppbmquK7IqFimOaX5qWjGmaZ5pykWmLqotkmvKLY4ltmmuapZpwmmqabppsmmuOb5pymneadZp0mlGSw4lxmnOapo9SiXaa3ImCmvqPfZp7mnyafppciViReJp5mpqKgZrtioSagJqDmqyV05O2lIaahZpkioeaipqJmoiaWJSLmoyajpqNmpCak5qRmo+akpqUmpWalpqXmpiaZJn6jmyO8Yn2iGOSmZqijc2IfZCamsWMkY2cmpua3pWdmp+anpqgmqGal4yAiaKapJqjmqaaeZOnmrOI3Y1cjG6SqJqpmquarJrijc+LVpaqmq2av41CjXntsZqjjXrtUpKumtiSspqCkLCas5pejLSatZpDjV+Kt5q4mnvtuZq2mq+aupq7mn3tfO2ElumPvZq+mryawJpXlOaIdZXBmvuPt458lO6K6Y14lrCTmIzNkb+awprCkcOaxJrGmueSrIqf6oGJ8ZXqj2eT5I3MmruV25fyiciaWZHLmoOTaJOEk7eUy5LHjcealolVk8maxZpvkM2abY+ri86a5pWdkcSSge3Qmm6W0ZrWmoLtrZXVms+a0prUmqSNx5XXmmSS84nrj9ma2JqIjdqa3Jrbmt6a05rgmt+a3ZptjnCQc5HhmrqQ64iElNmS45rimuSa5Zrmmueaz5XomoPtxInpmluXT4rHmWePvZHqmumWspbsmuWRVpO+kXaV7ZrumpuJuI7vms6I8JrxmoKJ74rek/KV9Zp0kfSaX4yE7XqW85qFk/ea9pqF7Ybt+Zr4moftnIn6mqeP/JpEkvuasZWXj3qTQJtEjUGbQJTclM+WRJRKm1eLZJetlqqbQptFm4jtw5FXlmmTRpuFlontyI2oj0ebb45ujreIxoypkM+IS5tMm0mbV4mtikibw5ZQlaaI94hwjtCIoYhRm0+bupZSm1CbTptQkE2b2JXijFabV5upj1ObS5hrlFWbpY1Ym3eVWZtUm7mWfZRam1GVW5tfm1ybxYlem7mOXZuZjGubZJthm4SSYJtim2ObZZtmm/CKaJtnm2mb7I9sm9qSZIlqm22bbptxm2+bcJtxjnKbRY1zm4rtmo62kXSbdZt5jkaN0JZHi8eMdpt3inebt5F4m6GbeZt6m3ubfZt+m4Cb7pFGieeOwIh2ka6Ks45HjYaTQI+vioiS6JK2iFiL85XAjnGL6ZC6jkeXgZt7i8mNUYqDiaqPxomCm2WXaI+L7eKOg5vxitCTp5aEm4WbeJWHm6aK9YuGm43tsIpRkIubQI7HiYqbiJuMm4mbSpTLnlKQjZuO7b6XjpuQm56Sj5uhkJuOzpH1jpWV6pDLjpGbq4+Sm5Ob0Yi4kXGQlJuxk6yPrY+Vm+uQro+P7Zabl5velpibxItBj5mbmpvajkuQ8pNzkPaUQZTHi5ubj4ucm/yLzZOuiXKOnZugm5+b+4uem1eTrpFqk8aOd5Gal6Kbo5vUk1KOpZumm6eb8oqom6mbqomQ7VqR4oqrm6aW0JF4iq2br5vdipHtrJuum7GbsJuym7Obu5Osi+OJtJu5m7eb9ZX0lZLth5O2m3OPtZuSkLqb6I3Am8Gbu5tSirybxZvEm8Obv5u+m8Kbk+32lZbtyZvGm8ibkpfHm5TtvZuTkMqbl+21jcubzJvPm86bzZuIk7ib1ZvRm9Cb0pvTm9abmO2Z7eSX15vUm9ib3orZm5rt25vam9yb3ZvskEKPhI+DkUiNto1JjZCL3pu3jciM35uklmKU4JtKjaqKRpLQi3OOepW/lOGb84rkm5+S45vim+Wb6ZKDkHSOyJDRkUGLoJLmm+eb7Y9Yluqb6Zvom52V8Zt5luub7ZuLluyb7pumlO+bvJXwm7GKvZVOlPKb85tLjbKK9Ju2jGOXSJf0ivaboZJMja+P3ZSwj5iP6pL3lViTTY17lfebeJPAjcmM65LBiI6PTo1ml/ib+ZtwlPqb9ZdMmPyb+5tmikCcQ5xEnEKcX5Wxj0acRZxBnEecSJxJnEycSpxLnE2chInskk6cmoz0iVWUT5z5k9mVUJxNmFGcvpVUnJ+Yr5iujvOTVZx8i6KS+IhWnKSVT41vku2Sm+3tlreMyoxXnFicXpzjjpzto5Kti1mcSpVlklqcS+1bnK6LXJxdnF+clpNgnGGcYpxTnFKcY5xgjEaVne3KjVaVpJJqlWScso9liWWcZpzwlt6UaZydiaqQaJxnnGGM0pFtnGucapyll+OMmY9snGuTXY++k3Ccb5xunHGc5IxynJyVeo9znPeUv5Olkp7tT5N0nEqLU5BLlfWKRZR1nHWOWZZalp6Jepyf7YmSd5z1iauceZxPlHicdpyajXycg5yJnIGce5OGnHyVgJyFnOWXdo7TkX2cfYuInKuQhYmCnPaJh5yvi4ScipyMnJaclJyRnJCc9peSnLCLUI2aj5mci5yg7Y+cfpz4iZOclZxwkqaNtomNnJicl5yxi6eRhopijI6cmpydnJ+coe27jqLtpZzukpuco5z3iaGcopyenKCc5YxJl7OKeImknFmUq4jflHucqpyunOOWp5yJk6yc7o+tnNWTZpipnKTtr5ybjcmQo+3SiKicppx5kZycU47Ekbucpu16kbacs5y0nOSOt5y6nLWcRI+4nLKc+pb5lrycvZzTiKftsZzwi6SItIql7bmcwZzAnMWcqe3GnKjtxJzHnL+cw5zInMmcvpycjsKc1JFRjbCcVJDWnOeVzJzNnM6c1ZzUnJ2WtYrSnGSMU4rPnLaX0ZzUiNOcypzQnNecY4zLnHyXSpfanN6cnpH3l9+c3JzZnKrt2JzdnK6VspNljOCc25zhnJuMr4npnLaK55zonKeN5pzknOOc6pzinOyc+YnunO2cppLxnO+c5ZycjPCc9JzznPWc8pz2nPec+Jzolfqc+Zxej6yQ5In6iavt+5y9iMqQ/JzB5kCdgYxBne2QQp1DnVmLRJ1FnUad1ZHLjN+WW5aKj0ed7pC75+CU6I7LjUidxZGlle+RS51JnUydSp1Nna+VtYh9leGUTp1RnbOPWotPnVadtI9QnWOUfZdSnVOdV52Kk1SdUo3ckGWdspTwkazt4pSrnfiV75KVllqdn4mKkmOdU5JdnWSdX51mnWKdYZ2PlFud+4lZnZGL8ZFVnVidU43ZkLWPYJ1xlJKLZ4qHikCQaJ1tnWmdnYxunUGOiY1Fj1ydnY5rnXeObJ3CiGedp5KTi7KLap2liMGNVZDwktKUcJ19kaiRSo5xnXOdb53flbuSe5H5lcyOgJ1+nZiQnox4nbeP5pNQlHadfJH2jnudto91nXqdcpR0nUCMfIp8namXzI1Uknmd2pBUjYSQholbkXedZItmjM2SfZ1+kYGdg521kYmdhJ2GnWCV8ZKHnUuXZ5e3iqyIhZ2CnfaKh4mt7YidaJeMnbmRk52NnYqdkZ1ynY6dkp3AlIuTi52PnWeM743bkJedRZOu7ZSdgJaVnZadzJagkIKMnZ1UjpqdmZ1RlK/ts5NQk5udnJ2PlWSUQo7vkG+WaIqjnZ6daZelnaGdop2AkbDtoJ1enaSdn52pnaqdRpOsnUOOp51bi62dpp2xnbCdr52ynbSd74+znbedtZ22nZCduZ24nZidup2unXiOu528nb6dvZ2/nfyJVY36la2QzIzBncSdse1xlX6Lw53CnXOUxZ2zi8edxp24ilWO1pNojJSQyJ2ukEeTfpXJncqdy522lXybxJBrldaN45TBlGyTv5fNnc6Ozp20iNKLy5CAlc+dYY5mknqOVpDQnfuVl4l7jtOd0Z3UnbeX0p35kNWdsJHWnfiK2J3Xndmd2p35ivqTVZKMi3yOgZF7j66I252gid+dsu1Wjd6dqY24j7Xt3Z25j76WqI3ViMyQs+3knbftr5BmibjtdI+GlvCNuo+27aWQR+3jneGd4p207YuSRZ7onZ6OV43mneedV5DlnU6Ouu277eqd6Z3une+d65257UGK7J3tndOUgZVpjPCdve2wkLuPcZLFi/Gd9Z3JifKd9J3znYuPZ5LDiPadvu33nb/tqJLvl2KO6ZXA7VyWQZ75nfyd+53B7fidQJ7ck/qdQp6Mj0OeapeYlESeRp5HnkieyItniViNSZ5KnpGPgpHC7Urt1pldkVyR1pHFjfCYjoxMl/yVnpXD7Uue8Y29kkyeTphdlqmSTZ76ik6eT57YlqKWlpZ7lkSOUZ7pjnCWU55WnlWe94qAi1KeVJ5XnpmQm5fHiN6NupHbjvGPWp5tk1ieqZFZnvCP25ZbnlyeiJfF7WGeWY10lF6ejJPcneCdbotmlGCevI/ClGae+JRdnmOeYp7NkI2W0ZeHlsqJfY5nmGWelZBknl+ezYxrnmmey4lnnm2ec57G7cjtxpG/lXWeQZV0npCUXpa5ivWQX4/Rkk2XcJ5vnnGebp52nmyeap5ynmiejJL2lsSO8o24jY+WYIrJ7cySyJNoifCQspBJjHieWo2cinqelIqBnn2e8ZBqiqqNaYrNjXuehYxqjI2Tyu15nsSIfJ5+nsuLS4zH7bqKaouCnveNkZZWjoOeT5WPnrGJhJ6VnoWewJeMnn6UlJ6HnrKIiZ5bjYueip6GnpGevY/rmuaMnJeInvKSQoqrjYCekJ6Bio6ekp6Ok/yKsJ5I7ceWl577ip6ey+1flp+eoZ6lnpmeSZKPk6menJ6mnqCeWJCqnrGQqJ67im+Ylp6kntaImJ64lp2eQZDFkpOeo56akK2ekYqfjK+emp6unqeem56rnqyevZ7Mk6KeuZ67ntaSa5eWlbaeyJG8nl6Rs57Anr+e7ZO+nuiTze3CnrWexou4nnyPgJS6nsmLsp60nrGeT5h5ireewZ5UiuWNfInSnlCY1Z7P7VmQ1J7TntCexJ7hnsOe1p7Onsmexp7Hns+eoOrMnlyNxpKEkcqexZ7InmyXipbNntee0O3fntie5Z7jnt6e3Z7OkoWR257ZnuCe5p7zlOye557qnuSelJJXldqe4p6+j82W9p7pnqCMoYl+itGe0e2/j+6e9Z73jpKKTZLrntPt8J70nrSLa4vynkCLyZPxnvOe0u3tntTt757V7YCKaJL6nvie54z3nkCfd575nvue/J5Ln0efjZ5Gn0WfQp/onkSfQ59Jn0WYTJ/5i0ifSp/W7dftpZRNn1GfTp+Tl0+f3J5Sn1OfVIlVn4eMn47Ti6KJfpdXn1afWZ9ci9SLvIpcn1ufXZ/MiVaSXp+9imCfX59hn2KfY59+jrOQn42QleCVY5iVjs6N8Jdkn2WfgI5mn2efaZ9on3eWfY/qjmOOap9sn0KQa59tn26fb59wn3Gfc59yn3Sfo4lpknWfRY5rinafYZPKmkKLd594n+qViJbFk3mf5JTY7fmU0ZZ6n3yfe59+n32fgZ+Bjq+Wgp+Dn0OLhJ+Gn4WfhZBYlWmJw5TZ7fOSYI+Bi8SUrI6In76KmIna7fCTh59djXKSiZ+Rn4qf3O2/kYKLkp+IjESLkJ+On4ufgJfb7b6S15OMn5Sfk59CjKuJuY2Nn4+fdpbykZeWnJ+dn82JppX7lp+foY7Aj5ifnp+IibWLlZ+an/KQkZTllJefQJaZn6Kf3e2gn5ufQZZnlIOLRJONkqOfoZ/XkZafaone7W2Xrp+tn/SQqp+Ml7STpJ/DkmuJXo2nn0aPrJ+rn6afqZ+IiqifaJSsl/KP85C0n7KfbJWvn7GfWYlfjVGYXIqCleDtgZdDilqQs5+4n9/twY9Pl7WfsJ+2n+Ht3JeTk8CT4u1VinSJvJ+/n8GXhJfGn8CfvZ/Sl8Of4+1pj8Wfyp+Rk8ifwp9Xksmfvp/En8uf+ojBn8yfW5Dl7X6Po5WsjeTtuZ/Hn1mT5u20kImKz43Cj7ufYY9rjLqf0J+Nj7iM35/Zn5SLbpPUn92frYhRientt4nWn6qRzZ/Pn2CN4J/n7duf6u3Tn9qfqZbYn9yfzozDj1iS6O3Sn06X1Z/On5KT0Z/Xn3CYvI6eluGfrJTtn7mMgI/jn62XYY3wn+yI7p/in+if6p9ul+WfTZPnn+vt75/pn8WW5J+gjvyfiormn+uf7J/qkdiR9J/6n/ifSJNC4PWf9p/en5mLWZW9jpeNUpjyn0HgiYmGkZmUv4r4l5+W0JL5n/ufUZFA4Pef8Z/BiomMTuBJ4PaQg4qBj1LgS+Cqkkjg15Jr4EXgROBN4EfgRuBM4J+QQ+Ds7U/gUODAilXgVOBW4FngYpNT4O3tV+CDjPeRUeBalFjgXeBb4F7gYeBa4IqNR5S3n5SXXOBg4PORX+BK4O7tiehk4GjgZuDv7fDtYuBj4GfgZeBtlW3gauBp4Gzg0pNu4JWS65Hx7aOQb+Bx4HDg859y4OWTc+DOiZSTRIqEi9yO0I3y7UaYhpCKiXXgdODz7XjgWZJ74HbgeuB54F+T14hG7fOXfeBHiYDgfuB84HfgQpaC4PXtgeD07YuJhOCwlYPgs5bFj1KRxI/37fjt+ZeK4PeQhuCL4IyJ9u2J4IGUheCI4MaPz5SM4M+O+JCP4IfgRoyN4G+XkOCk6m6PkeCS4E2UlOCV4PrtUpSVk5fgmeDTl5bgmOCNiZPgepqa4IeRV46c4JvgQ5DXmZ3gn+CO4J7g++2g4JqUoeCi4KPgpODckqbgpeCn4Kjg3Y6DleqWqeCq4HWRoo6r4KzgreDQlcWUruB2lKuSr+DliY2LxJa0lrKJU5hxlqiVtZCw4MGToYyx4NKNs+Cy4LTgteC24F2Lt+C44KKMxpT87brg84+54EDutou74L3gvOC+4M+Mv+Dni1+RnY3B4MLgwODrjsaTt4vE4EuSw+BUmIKUx+DJ4Mbg0pbI4MrgwpdB7s7gzeCWkkyUo4zM4MvgUJdRl8/gjomWjYKO0ODR4NPgYo/V4NTg1uBsitjgQ+7X4Nrg2eC6jKaXyoukieiL34rml9zg3uBE7t/gz4nb4EXuWI6/kt3gSO5G7uLg7I5H7uDgXYzHlOHg/OBK7ufgu4yFi+TgnZdJ7q6X9JHm4EvuTe5M7k7u6ODUl9WL+pRplOng6+Du4Org7eDojGyJ7+CQkOzg2pdP7vLgourw4PPg5eDx4LqN9OD14J6XUO724PfgUe7j4Pjgwoqjjvng+uD74FqJQOFalUHhoopC4UPhROFG4UfhReFylUnhSOFS7kvhSuFM4U3hT+FO4ZmNUeFQ4cOKcpBbk1LhtpBZjpmJU+Fwl+GVVOGM7WOTUpdijVyQapKymayS5olV4VbhW+FZ4VjhwJ1Filfh2IiolMiUr5dc4Vrhe5KkkKmUTJVe4aqXbIxf4V3h1JRg4WHhU+7ZiPSPZuFj4euTYuFFi2nhZOFl4WjhZ+FElWGRYJFei2rha+Fs4W7hbeF1iXbh5pRw4XLhdOFdkHXhc+G+jm/hceFhlcePeOF34XnhpI6tjZeTeuHJknzhn5d74YmRguGE4YXhc5KD4YDhfeF+4YHhiOGG4YfhieGL4YzhjeGO4YrhkOGP4ZHhw5eU4ZLhk+HgivyWyJWW4ZXhl+GY4ZzhmeGa4ZvhneGe4Z/hoOGh4a2Ub5Oi4ZKUU5Wj4VTupOFJk0aKY42l4abhp+FIjqnhqOGq4avhV+5V7lbuWO7nlKzhreGJ6q7hr+Gw4U2OseF1lH6WbYl2ibLhtOGz4ZCTt5BYn7Xhv5a24cSK1ZS34bjhueHaltOWvJKKkbvhgo/Ij77hveG84fuUxYqnjMThweFekLCWwOHC4cPhv+HF4cbhrZLhioWSWu7H4cjhy+GHkMKTzOFylsnhyuHP4c7hzeHR4dDh0uHU4dPhy5V1j8SX1eG1k9bh1+Hb4dnh2uHY4dzh3eHe4d/htZbg4e6W4eFtkoqU6YtakuLhuIvOkOPhu43k4eXhpIzTjefhXO51k9SNbYtDlmqUdpN7jenhXe7Jj17usJdkjaWMoZTr4V/u7eHpjOzh9JLv4VaK6uHolE+J6o1xmO7h8OHJldeQ8uHz4fHhbYr54fjhpY764fXh++H24daU9OH34UHiQOKBlvzh6YhD4kLiyo9E4mKRRuJF4kfi5uHo4UniSOJg7qaO55fQjkriVoxfi0aLg45Tl1DiT+JjkUziTuJqj1+QTeJL4kmUy49bldWNmJNR4lLiaOLWi1yYVJFT4tCJ9ZKflWTuZu5U4pqLVeJX4ljiSJRZ4lriW+LXi9GJw5NHj4SOXOJIj8iJYpVd4umUZJFg4mHiiZRgkF7igZJf4syP2ohIi2Li9pJj4sWQq5ZClWTiZeJ0ksWXZ+Jm4u2OaeLuiGziauLSiW2Ma+JljZKN5JVt4nOWb+LPkG6JuImqiG7icOJx4vWPcuJuinTiioyGi3Xi84t24vqQy5PekPONd+KCkouReeJ74njieuJBjHziRYyHi3GXfuKA4k2Jg+KWioLigeKF4n3ihuKnl4fiiOJn7vKaiuKJ4ovijOKzl43i7ejNj47ij+J2j7aTkOJo7keSau6R4luSkuKji16ZfJKxjsaKk+Kg4pbiiIuV4qLilOLOj5jimeJKk5rifYp5kISVnOLmkZfim+Kd4vmNpOJNlaSUmZPYi6PioeKzlJ7ifZKbk5qT9I224qbiqOKr4qziqeKq4qfipeKf4s2V04mz4rDiteK04pOUpZZajq7it+Ky4rHireJr7q/ix4pckvuQoJS84qKU35C54s2UveLRlXqSuOK64rvivuLCjsSTw+LC4r/iVZjI4sziyeLF4sbiy+LA4tOZx+LB4sri0OLIis3izuLP4tLi0eL0lNPi+pfrldji1eLU4tCQ1+LZ4tbi3eLa4tvixOLc4t7i3+LEleDi4JbMi0iM4eKylYiQrpbi4rGXlJRlkVOUbI++iOfi5eLj4p+Kz4/o4ubi5OLs4uvi6uLp4u3i7uK4kO/i8eLw4tCMV5Hz4pyT8uL04rOVjJFmjfXixpf34vji+eL64oWO++JujIqLSYtA4/GWZ4384kPj5JZblFKVg49C49GOaI2GjomLtJVB42aRYZb1jYeO25JG492X141H42GQSePQj66NSONJj7yMZ5FE40rjbe5F42+MTeNR44uMTONV427uaY2Nl7qIUuOLi0/jUOOdk07jS+NHiuKQpoxX41TjVuNT43CMsZFY446RZeNw7mHjW+Nf4/iO24ha42LjZuNqjdSW1JJc42/uZONZ412SXuO7iMiWXePZi+qUjZHOl4+PjuNx7mfj/JBj42jjauP3km3jaePSlcmKyZbciGzj+5dr44+J6pNu43Xjb+N243Ljm5TIjnTjceN343DjY49ElmuPc+OA43vjfuN844HjeuNg49GQyZR943jjQJFxjEqPcu5EkFWRhOOG44fjg+OF43njguOK44njmpZKjIjjjOOL44/jkeNbjo3jkuOT40DtlOOa41qTluOV45fjmOOZ45vjnOPKip3jnuOf43PuoOOh46Ljo+Ok46bjpeOn46jjqeOs46rjq+PfjXKMdZKxlJCPbJTrlK3j65yu47DjhZev47LjseNyl7Pj/JS047fjtuO143TuuONRjEGRYIu847njuuO9477ju+NIiaWJwOPB48LjgpdLj8Tjw+OJkMXjxuPH4+OKy4rI48njfJaDl3OXVphsjczj0o7L483jp47Pkc7ja43Vls/j0OPR49Lj0+OojuuW1eNektTj1+PW49jjuZDZ49rjt5Xb44+R3OPd4/yX4OPf497jrpLh40WQ4uPj41eY5OPl4+fj5uOjlPeTXZinlOnj0Y9Jlerj6OPMitKMiI7slKiMYpbt4+vjbY1ujeeI5o14lN2I8uNfkneU2ZH04/Dj8+Pu4/HjRZbTjPuI7+P24/fjt5O5i0XkXJSJjrqLxpBlmKyW9ePSkHKL+OP64/nj++NFkl2Ur5JC5EHk/ON0kIWVRORD5G+NcphU5EjkSeTujkfkmI1G5ErksJKglUKR2pFO5E/kS+RM5E3kcI1V5FHkhpWMlkeVUORT5FLkY5ZW5FfkVpFY5FrkXuRb5FnkXpRc5F3ksIlk5F/kYORh5J+RY+Ri5GXkZuRn5GKQ54lo5NWXqY5Mj4qOdpJp5GrkUIlr5GzkbeRu5G/ku4uonXDk45Bx5MmOcuSumHPk3JXaikORd4+RlU2PdORxjXXkypSE5Hfkx5GVlL2MduREkXjk+JJ65HnkfOR75H3kgOR+5M2KgeSC5IPkr43Hl4XkRpCQiYbkh+SI5PCIieSK5IeVxY6M5EiKsIiL5I7kbZRjkNSJRpZ8jNqLjeToiaGKkYmS5OiX25FjlZ7k1Ymc5JrkkeSP5JDk4Y7qi5eSz5NwiZTkk+SZ5JXkmOR27s6Wl+TWiZ2Km+Sd5HOMoeSq5KvkqYiy5O+IqeSo5KPkouSg5J/kg5L5kaXkpOSn5JCRdIxgiabkco2RkXfuuOS55NeJrIm25HjurOS05LvkteSz5JbkseSt5M6Kr+S65LDkvOSu5JyUiZe35M3kxeSbkHnuZYvbi8Dk2YnSj8Pk2I1wk8jk7JW/5NiJ1IxIlcnkveR67sbk0OTB5MLkuJPH5MTkR5bK5N6IvuTM5Mvki5TS5N3knorg5M7k0+SOl9zke+50l6iXmJKLipKV4uSfk6+I2+TX5JKR0eTZ5N7kS5SoiNbk3+SYldrk1eTTj06Pqo7WlmaV5eTu5Njkl4p87vaP4+To5JOR5OTr5H6S7OR1l+HkV4rn5Orkqpbt5Obk6eRE7UiWQJjx5Pjk8OTBjs/kzJWglvfk9uTy5PPkVYn15O/k05L05PyIoJHBlfnkQOXXlPzk1I/HjkLlvIt97kPlmZX75H7u1OT65G6YoJOTlYDuSuVQ5VHlROWWlE7lRuVI5VLlR+VL5ZKJ45NM5U/lReVFkUnlRo5kkE+M8pb3lpKPgu5W5VTlbZhT5ZWXVeVX5VjlW+VZ5aGTWuXLlE3lk49c5WHllJFg5UHlYuVokV3lX+Ve5VCfQZ9k5WPllpe64WXlZuVn5dWMc4tp5XyZlYu4l/GLauVr5Y6SbOX4k7iI4Ylx5XLlbeVcjm7lYZRv5XDleuV05Xflc+V15Xbl1o545WCSdYxhinvlXoqB5XzlgOW4lH3lfuVnldiUguX7kYzliOXpiYblSZaH5YTlheWK5Y3li+WJ5YPld5KU5aiWkuWT5Y7lkOWR5Y/l5JBYmJjlmeWf5UmQm+We5ZblleWg5dqJnOWh5Z3lmuWxkpfliJSl5VqXpOWj5azlpuWu5YaXseWo5anlreWw5a/lp+Wq5bvltOWy5bPluOW55UmKYYu35aLlhe625brlteW85b7lveXA5b/leeXE5cHlwuXD5cXljIzH5cblT49zjaWfyOVwj1iKyeVxidWPyuV0jcvl34hclczlipDT5dDlj5LR5c7l3IvN5dTlVYzckdrl1uWzkdXl2OXP5dnl2+XtlNfl3OXe5dGM0uW/iN3l2Y30l9/l4OWVkaCX4eVUl+Ll4+XileTlvo2hl+nl6uXWj+jlhu6Hl+Xl5+W7kJ6Q5uXr5aGV7eXs5YyKSpbu5UHt+uXw5fHl8uXz5ffl+OX25fTl7+X15fnlteimifzl3Yv75UHmQOZD5kLmROZQj0XmRuZH5ryQdpdI5qKVZZRJ5krmqYxLi0vmi45glEzmb4pN5k/ml5dO5mWQUOZR5lLmz4pT5lTmVeZW5nCKV+ZY5lnm8IlHkFrmW+Zc5r6M+ZJd5naMdZBg5qKTX+aH7lCMXub1kUyLYeZi5tePjYxj5kuW3ZCWi/OWaZFk5ojuZpCQktiPZeZo5mnmvI3AkWfm2Y9dlWbmjI5yiW3md4yOjo2ObJhs5mvmRpFsi2KYWYraj4nuauZv5nDmbubWjF+Xj45GlHPmvpBhklWXdubqjL2QcuZ35uuMdOZ15orucebgkMeTTpLbie6UYouL7rKSeuZ45muSv5DQinnmepDIl1+Ye+aH5rOShuaM7oPmi+aE5oDm+pJ+5nzmQJeQjoHmfeaO7oXmlI+/jPiRZJZ5ieCIo5OJ5ojm5JON5oLmjOaO5qqMiuZ1jdOOj+Z3l5LmleaT5lSVkObei5Tmluaa5pfmmeaY5o/um+avjp3mnOaIlZ/meIye5qDmoeZji7/j94+i5uyMo+aQ7qTmXY7MnaXmpuZRj6fmqOap5qrmq+ZKkqzmruat5qSTr+ZMlrDmseay5rPm2JPbj7Tmi42smLXmtuZelbfmv+a45rrmuea75mWWvOa95r7mwOZMiuWSiZXgjXaNbpXdicyUw+bRitOQwubH5pmS4ZbF5sbmTYvI5oOU3ZHvlFyTxOZmluqJyuZHmMCSZJiRjsnmr5Ha5keR9pNvlc3mXo6SjtyPhZSrjMzmy+aKlb+OcZOR7pLuz+bQ5neNzubR5tLm1OahkdPm5IrW5tXm1+aT7tnm2+bc5tSQzY7d5nGK3uaWkd/m4OaLlZTuTovh5rSSeoni5u+OlpCrkeXm5Obj5uvm6ebm5ujm5+bq5peL7ubVkO/m14zs5u3mSJi1kkiR8Obz5vHm8uZ4l6WT9ub05vXm9+ZI5/rm++b55vjm+5JA50TnQef85kLnQ+dK50Xn1pBH50nnRudM51KPS+dN507nUedQ50/nU+dS5/SWVedU51bnV+dZ51jnZ5Ba5+uLW+dd517nX+dc52Dn1I5h50+LUoyW7qyMYufuk12TY+dm57KOZedk53mMZ+dyimnn2o1o53Hna+dt5+OVauds53DnbudQi2/ncud5lNaXU49z50GXded053jnYJd3542Kdud753rneedRk3znfed+54yNRIyA54HngudokIPnq46E54Xnn5memYbnkOOH50OSSpBflIjn05XSkp6NSJJJiZiWdpB9jN+L1JWJ54vniufeifSTjOeXlFKTjedxj4/nwJae55HnkufHkt6Rl5Gmk5DndIuZ55bno+enk4CSk+f8knKTlOeY54CQh5TKksCQl+eskaKRleeniEGYmuffkVSPaZCc55vn7Yid506VpefZk4uQeJL2i6TnVpdeidWV34mf56Dnoeei57mTQpLhiKbnp+eh6ruRqOeTiWuRrYx5l5nuqedLk5iR1Y6q563nhY+r50qRSZHiiMmXr+fwlLHnsOeu54Ti0oqO57Pnsue051eX35NNlrXn146257fnuOdAk+iIeI1ZmLznmu5TjLnnuueUlXOKWJe9i3OTvee+55zuv+ed7kGTwefA59GTwudVj96OepSRkvCOjJDD58TnfJDF58bnx+ePl1aPyefI53mNk41fjsznho/L58rn55HtjMGQrpRYj83n3Y/Q587nz+fS59Hn+I/T59Tn1efOlNGN347W59fnopdkj+yWypfY5+CL2eef7kKTnu7c55iKapCg7trn2+fekqPupO50lvqLoe6i7t7n3+fd5+Hnpe6n7t2TYoqm7uXn4ufk5+Dnbujj5+mX2Iyu7qjuqu7t56nuU5Po5+vn6efu56vu7+et7ufnrO7055SJ5uerlOrn3o+v7nqNse6y7meW4otlj7qTQ+1MkfLn7Ofx58GWtpLz5/DnsO5Lkffn9uf157buTpa67rjutO617rnum4+z7vjn3ZVziWWVkpKYi0nt+ue97nyNwO7C7kuO+eeNkI6QQOhC6MHuv+75j7zuQehD6Lvu0YtkleCOQpj85/aNXphF6EToRuj750Lt55N0k9WSS+jE7mKSR+hI6EyMSujD7q6MSejfj5mKT+i9jZmRyJLF7lqKTehO6MGSTOhQ6Fboxu5Z6FjoTJNR6FLoVehX6Mfuvota6FToU+jI7l7oX+hg6F3oXOjgj6iTW+hk6GLoye5j6GHo9pFl6GboaOjK7svu04pn6PiWc+hp6Gzoauhr6G3ob+hw6HHodOhy6HXod+h26LeS5ZZ46E2ReejClXroSopbidWKzO7UinvofOh96H7ogOjWinSKfY20lILogeiD6HuJhuiF6IToh+iK6MWIiOiM6IvojuiN6I/orJOQ6JHok+iS6IyVlOiV6OONluiX6GiWapGiiMmRmOiNlZvomeh+jZrowIzDlZ3on+ie6KDoQIl3kJyP14qh6IaUo+hBiaLowpLLl6mTnOikl6+Mepf3i7KXR4zgkUDkpOhLio+QdYqm6KfopeiEjNuN4Y/P7kKJ15ep6KznqOjQ7qzoquir6K3orujql6/osOjHkLmUnZDlilmX64lXj9mMs+iy6JOOtOix6EeOuOir5dSZl5C26KOX75NKieGQtI61lV+J65eLl7noZJP5jrrou+hrkLzo7Je36L7owOi/6L3owejC6JqR4InD6LaWxOjF6EmY0e5Qnsbo0u7H6MjozOjT7snoyujL6M3o1O7V7tbuwpDX7vWWw5DO6PGUz+hy6sqW0OjR6NLodorU6HiQ1ehDjNbo2ujY6Nnok4rX6Nvo3OjGiN3o3ujij9/oZovi6OHo4OiR5tqV4+jk6OXo5ujn6Ojo2Irp6OroQpTs6LmJ7+ju6EOJv4vFlbiSoI2AjYePe5Dx6PDoYZfmitCU2pOckMyXeoz06PPoapaqk2+J9ejy6HCVipf26Pfo+ejokXqKe4r46OeKsIzY7uiKXpPel9nu2oz66Pvo/OhA6ULpQemXlUPpROlF6UbpSOlH6Unp8pTK40iQUYtK6Uvpqplan9GU+Yi5iJSOT5b8j0zp3ZZN6XuXYYlgjk7p7IlP6VDpUulT6VXpUelU6dzu2YpW6VfpWOlZ6VrpXOlb6V7pYeld6V/pYOli6cCL8Y5j6WTpgY3e7mXpXYpulGbpZ+l5kumTaOmdlMqRd4nsi+2Lk5Jt6e6L7Yls6Wrpa+lp6Xfpbulv6XDpcelz6XLpeI906XbpUot16ZuRsYx46cuReemrk3rpgOl96Xzpful76YLp3+6B6YTpwYuD6YXphumI6YfpiemL6YrpnI2M6Y3pW4qO6Y/pkZCQ6ZHpkumT6YKN4O7h7pTplemW6ZfpmOmvlJrpRZWb6Znpnemc6Z7pn+mg6aHpoumj6aTppemm6afpqOmp6arpq+ms6VSfren24lOLQIqwja/prumjlrHpsumw6bPpgpa06ZuLRJjj7rXp4u636byI5O646amVtum56brpu+m86b3pjpZMjviNTpHl7r7pwenm7r/pwunvjMDpw+nE6cXpyelJjuKRyunH6cbpyOl+jM7pzenM6bGI5+7Y6dTp1enR6dfp0+mCimuY1unS6dDpz+na6d3p3Onb6WiV2enxiN7p4OmPisvpVoni6eHp3+lMkpCW2Jfj6eTp5enm6efpuZLo6bWU7enp6erpUJbCls6T7unv6byT7Onr6aiJ9+n26ZWJ9Onz6fHpm4rw6bCOp4mDjfrp+en46fXp++n86UTqQ+pF6kyJQOpB6pSNt5ZC6unuUZZK6ujuRupL6kjqR+p7jEzqTepO6knq8ulP6t+SU+pU6lLqUepX6lDqVepW6lnqWOpb6lzqXepomFrq6ZHrjV7q6+5f6mDqYepi6rKMY+pk6q2OZepm6mfqaOpr6mnqW5hq6u2XbOrZl23qnpRu6nDqcepv6o2Ny5aDlvWbgJ+blqmJc+pvi3Tqdep26uzulY136tLg2ZbhkXjqeup56nvqfOp96n7qgOqB6oLqg+qE6oXqhuqH6ojqQ5PbjIrqbJGL6ozqQJWN6o7qVuLY5uvoj+qQ6pLqk+qU6u6XkeqV6pbqmOqX6prqm+qZ6rSXnOqd6nPinupA8EHwQvBD8ETwRfBG8EfwSPBJ8ErwS/BM8E3wTvBP8FDwUfBS8FPwVPBV8FbwV/BY8FnwWvBb8FzwXfBe8F/wYPBh8GLwY/Bk8GXwZvBn8GjwafBq8GvwbPBt8G7wb/Bw8HHwcvBz8HTwdfB28HfwePB58Hrwe/B88H3wfvCA8IHwgvCD8ITwhfCG8IfwiPCJ8Irwi/CM8I3wjvCP8JDwkfCS8JPwlPCV8Jbwl/CY8JnwmvCb8JzwnfCe8J/woPCh8KLwo/Ck8KXwpvCn8KjwqfCq8KvwrPCt8K7wr/Cw8LHwsvCz8LTwtfC28LfwuPC58Lrwu/C88L3wvvC/8MDwwfDC8MPwxPDF8Mbwx/DI8MnwyvDL8MzwzfDO8M/w0PDR8NLw0/DU8NXw1vDX8Njw2fDa8Nvw3PDd8N7w3/Dg8OHw4vDj8OTw5fDm8Ofw6PDp8Orw6/Ds8O3w7vDv8PDw8fDy8PPw9PD18Pbw9/D48Pnw+vD78PzwQPFB8ULxQ/FE8UXxRvFH8UjxSfFK8UvxTPFN8U7xT/FQ8VHxUvFT8VTxVfFW8VfxWPFZ8VrxW/Fc8V3xXvFf8WDxYfFi8WPxZPFl8WbxZ/Fo8WnxavFr8WzxbfFu8W/xcPFx8XLxc/F08XXxdvF38XjxefF68XvxfPF98X7xgPGB8YLxg/GE8YXxhvGH8YjxifGK8YvxjPGN8Y7xj/GQ8ZHxkvGT8ZTxlfGW8ZfxmPGZ8Zrxm/Gc8Z3xnvGf8aDxofGi8aPxpPGl8abxp/Go8anxqvGr8azxrfGu8a/xsPGx8bLxs/G08bXxtvG38bjxufG68bvxvPG98b7xv/HA8cHxwvHD8cTxxfHG8cfxyPHJ8crxy/HM8c3xzvHP8dDx0fHS8dPx1PHV8dbx1/HY8dnx2vHb8dzx3fHe8d/x4PHh8eLx4/Hk8eXx5vHn8ejx6fHq8evx7PHt8e7x7/Hw8fHx8vHz8fTx9fH28ffx+PH58frx+/H88UDyQfJC8kPyRPJF8kbyR/JI8knySvJL8kzyTfJO8k/yUPJR8lLyU/JU8lXyVvJX8ljyWfJa8lvyXPJd8l7yX/Jg8mHyYvJj8mTyZfJm8mfyaPJp8mrya/Js8m3ybvJv8nDycfJy8nPydPJ18nbyd/J48nnyevJ78nzyffJ+8oDygfKC8oPyhPKF8obyh/KI8onyivKL8ozyjfKO8o/ykPKR8pLyk/KU8pXylvKX8pjymfKa8pvynPKd8p7yn/Kg8qHyovKj8qTypfKm8qfyqPKp8qryq/Ks8q3yrvKv8rDysfKy8rPytPK18rbyt/K48rnyuvK78rzyvfK+8r/ywPLB8sLyw/LE8sXyxvLH8sjyyfLK8svyzPLN8s7yz/LQ8tHy0vLT8tTy1fLW8tfy2PLZ8try2/Lc8t3y3vLf8uDy4fLi8uPy5PLl8uby5/Lo8uny6vLr8uzy7fLu8u/y8PLx8vLy8/L08vXy9vL38vjy+fL68vvy/PJA80HzQvND80TzRfNG80fzSPNJ80rzS/NM803zTvNP81DzUfNS81PzVPNV81bzV/NY81nzWvNb81zzXfNe81/zYPNh82LzY/Nk82XzZvNn82jzafNq82vzbPNt827zb/Nw83HzcvNz83TzdfN283fzePN583rze/N8833zfvOA84HzgvOD84TzhfOG84fziPOJ84rzi/OM843zjvOP85DzkfOS85PzlPOV85bzl/OY85nzmvOb85zznfOe85/zoPOh86Lzo/Ok86XzpvOn86jzqfOq86vzrPOt867zr/Ow87HzsvOz87TztfO287fzuPO587rzu/O8873zvvO/88DzwfPC88PzxPPF88bzx/PI88nzyvPL88zzzfPO88/z0PPR89Lz0/PU89Xz1vPX89jz2fPa89vz3PPd897z3/Pg8+Hz4vPj8+Tz5fPm8+fz6PPp8+rz6/Ps8+3z7vPv8/Dz8fPy8/Pz9PP18/bz9/P48/nz+vP78/zzQPRB9EL0Q/RE9EX0RvRH9Ej0SfRK9Ev0TPRN9E70T/RQ9FH0UvRT9FT0VfRW9Ff0WPRZ9Fr0W/Rc9F30XvRf9GD0YfRi9GP0ZPRl9Gb0Z/Ro9Gn0avRr9Gz0bfRu9G/0cPRx9HL0c/R09HX0dvR39Hj0efR69Hv0fPR99H70gPSB9IL0g/SE9IX0hvSH9Ij0ifSK9Iv0jPSN9I70j/SQ9JH0kvST9JT0lfSW9Jf0mPSZ9Jr0m/Sc9J30nvSf9KD0ofSi9KP0pPSl9Kb0p/So9Kn0qvSr9Kz0rfSu9K/0sPSx9LL0s/S09LX0tvS39Lj0ufS69Lv0vPS99L70v/TA9MH0wvTD9MT0xfTG9Mf0yPTJ9Mr0y/TM9M30zvTP9ND00fTS9NP01PTV9Nb01/TY9Nn02vTb9Nz03fTe9N/04PTh9OL04/Tk9OX05vTn9Oj06fTq9Ov07PTt9O707/Tw9PH08vTz9PT09fT29Pf0+PT59Pr0+/T89ED1QfVC9UP1RPVF9Ub1R/VI9Un1SvVL9Uz1TfVO9U/1UPVR9VL1U/VU9VX1VvVX9Vj1WfVa9Vv1XPVd9V71X/Vg9WH1YvVj9WT1ZfVm9Wf1aPVp9Wr1a/Vs9W31bvVv9XD1cfVy9XP1dPV19Xb1d/V49Xn1evV79Xz1ffV+9YD1gfWC9YP1hPWF9Yb1h/WI9Yn1ivWL9Yz1jfWO9Y/1kPWR9ZL1k/WU9ZX1lvWX9Zj1mfWa9Zv1nPWd9Z71n/Wg9aH1ovWj9aT1pfWm9af1qPWp9ar1q/Ws9a31rvWv9bD1sfWy9bP1tPW19bb1t/W49bn1uvW79bz1vfW+9b/1wPXB9cL1w/XE9cX1xvXH9cj1yfXK9cv1zPXN9c71z/XQ9dH10vXT9dT11fXW9df12PXZ9dr12/Xc9d313vXf9eD14fXi9eP15PXl9eb15/Xo9en16vXr9ez17fXu9e/18PXx9fL18/X09fX19vX39fj1+fX69fv1/PVA9kH2QvZD9kT2RfZG9kf2SPZJ9kr2S/ZM9k32TvZP9lD2UfZS9lP2VPZV9lb2V/ZY9ln2WvZb9lz2XfZe9l/2YPZh9mL2Y/Zk9mX2ZvZn9mj2afZq9mv2bPZt9m72b/Zw9nH2cvZz9nT2dfZ29nf2ePZ59nr2e/Z89n32fvaA9oH2gvaD9oT2hfaG9of2iPaJ9or2i/aM9o32jvaP9pD2kfaS9pP2lPaV9pb2l/aY9pn2mvab9pz2nfae9p/2oPah9qL2o/ak9qX2pvan9qj2qfaq9qv2rPat9q72r/aw9rH2svaz9rT2tfa29rf2uPa59rr2u/a89r32vva/9sD2wfbC9sP2xPbF9sb2x/bI9sn2yvbL9sz2zfbO9s/20PbR9tL20/bU9tX21vbX9tj22fba9tv23Pbd9t723/bg9uH24vbj9uT25fbm9uf26Pbp9ur26/bs9u327vbv9vD28fby9vP29Pb19vb29/b49vn2+vb79vz2QPdB90L3Q/dE90X3RvdH90j3SfdK90v3TPdN9073T/dQ91H3UvdT91T3VfdW91f3WPdZ91r3W/dc9133Xvdf92D3Yfdi92P3ZPdl92b3Z/do92n3avdr92z3bfdu92/3cPdx93L3c/d093X3dvd393j3efd693v3fPd99373gPeB94L3g/eE94X3hveH94j3ifeK94v3jPeN9473j/eQ95H3kveT95T3lfeW95f3mPeZ95r3m/ec9533nvef96D3ofei96P3pPel96b3p/eo96n3qver96z3rfeu96/3sPex97L3s/e097X3tve397j3ufe697v3vPe99773v/fA98H3wvfD98T3xffG98f3yPfJ98r3y/fM9833zvfP99D30ffS99P31PfV99b31/fY99n32vfb99z33ffe99/34Pfh9+L34/fk9+X35vfn9+j36ffq9+v37Pft9+737/fw9/H38vfz9/T39ff29/f3+Pf59/r3+/f890D4QfhC+EP4RPhF+Eb4R/hI+En4SvhL+Ez4TfhO+E/4UPhR+FL4U/hU+FX4VvhX+Fj4Wfha+Fv4XPhd+F74X/hg+GH4Yvhj+GT4Zfhm+Gf4aPhp+Gr4a/hs+G34bvhv+HD4cfhy+HP4dPh1+Hb4d/h4+Hn4evh7+Hz4ffh++ID4gfiC+IP4hPiF+Ib4h/iI+In4iviL+Iz4jfiO+I/4kPiR+JL4k/iU+JX4lviX+Jj4mfia+Jv4nPid+J74n/ig+KH4ovij+KT4pfim+Kf4qPip+Kr4q/is+K34rviv+LD4sfiy+LP4tPi1+Lb4t/i4+Ln4uvi7+Lz4vfi++L/4wPjB+ML4w/jE+MX4xvjH+Mj4yfjK+Mv4zPjN+M74z/jQ+NH40vjT+NT41fjW+Nf42PjZ+Nr42/jc+N343vjf+OD44fji+OP45Pjl+Ob45/jo+On46vjr+Oz47fju+O/48Pjx+PL48/j0+PX49vj3+Pj4+fj6+Pv4/PhA+UH5QvlD+UT5RflG+Uf5SPlJ+Ur5S/lM+U35TvlP+VD5UflS+VP5VPlV+Vb5V/lY+Vn5Wvlb+Vz5Xfle+V/5YPlh+WL5Y/lk+WX5Zvln+Wj5aflq+Wv5bPlt+W75b/lw+XH5cvlz+XT5dfl2+Xf5ePl5+Xr5e/l8+X35fvmA+YH5gvmD+YT5hfmG+Yf5iPmJ+Yr5i/mM+Y35jvmP+ZD5kfmS+ZP5lPmV+Zb5l/mY+Zn5mvmb+Zz5nfme+Z/5oPmh+aL5o/mk+aX5pvmn+aj5qfmq+av5rPmt+a75r/mw+bH5svmz+bT5tfm2+bf5uPm5+br5u/m8+b35vvm/+cD5wfnC+cP5xPnF+cb5x/nI+cn5yvnL+cz5zfnO+c/50PnR+dL50/nU+dX51vnX+dj52fna+dv53Pnd+d753/ng+eH54vnj+eT55fnm+ef56Pnp+er56/ns+e357vnv+fD58fny+fP59Pn1+fb59/n4+fn5+vn7+fz5oAD9AP4A/wDE7c3uc+1+7YDtle287cztzu357ULuWe5h7mLuY+5l7mnubO517oHug+6E7o3ule6X7pjum+637r7uzu7a7tvu3e7q7kmB/O6UgZCBk4GVgfvuaYFqgZaBe4FDgXyBRIFegU+CUIJRglKCU4JUglWCVoJXgliCRoFHgYOBgYGEgUiBl4FggmGCYoJjgmSCZYJmgmeCaIJpgmqCa4Jsgm2CboJvgnCCcYJygnOCdIJ1gnaCd4J4gnmCbYFfgW6BT4FRgU2BgYKCgoOChIKFgoaCh4KIgomCioKLgoyCjYKOgo+CkIKRgpKCk4KUgpWCloKXgpiCmYKagm+BYoFwgWCBoQCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8AkYGSgcqBUIH67o+B";

function _b64ToU16(b64){
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i) & 0xFF;
  return new Uint16Array(bytes.buffer);
}
const __CP932_CPS  = _b64ToU16(__CP932_CPS_B64);
const __CP932_VALS = _b64ToU16(__CP932_VALS_B64);

function _cp932Find(codePoint){
  let lo=0, hi=__CP932_CPS.length-1;
  while(lo<=hi){
    const mid = (lo+hi)>>1;
    const v = __CP932_CPS[mid];
    if(v===codePoint) return __CP932_VALS[mid];
    if(v<codePoint) lo=mid+1; else hi=mid-1;
  }
  return null;
}

function cp932EncodeEx(str){
  const out = [];
  let hadReplace = false;
  for(let i=0;i<str.length;i++) {
    const code = str.charCodeAt(i);
    // Surrogate pair (outside BMP) -> replace
    if(code>=0xD800 && code<=0xDFFF) { out.push(0x3F); hadReplace = true; continue; }
    const vv = _cp932Find(code);
    if(vv===null) {
      out.push(0x3F);
      hadReplace = true;
    } else if(vv < 0x100) {
      out.push(vv);
    } else {
      out.push((vv>>8)&0xFF, vv&0xFF);
    }
  }
  return {bytes: new Uint8Array(out), hadReplace};
}

function cp932Encode(str){
  return cp932EncodeEx(str).bytes;
}
// ===== CP932 TABLE END =====

function _sjisEncode(str){ return cp932Encode(str); }

function cmcdDeriveLayout(u8){
  const layout=[];
  let p=0;
  const n=CMCD_FIELDS.length;
  for(let i=0;i<n;i++){
    while(p<2048 && u8[p]===0) p++;
    const start=p;
    while(p<2048 && u8[p]!==0) p++;
    while(p<2048 && u8[p]===0) p++;
    const nextStart=p;
    const len = Math.max(2, nextStart - start);
    layout.push({start, len});
  }
  while(layout.length<n){
    const last = layout.length ? (layout[layout.length-1].start + layout[layout.length-1].len) : 0;
    const remain = 2048 - last;
    const each = Math.floor(remain / (n-layout.length) / 2) * 2 || 2;
    layout.push({start:last, len: (layout.length===n-1)?(2048-last):each});
  }
  for(let i=0;i<layout.length;i++){
    layout[i].start = clamp(layout[i].start, 0, 2047);
    layout[i].len = clamp(layout[i].len, 2, 2048-layout[i].start);
  }
  return layout;
}


function cmcdFillInputsFromBytes(u8){
  if(!u8 || u8.length!==2048) return;
  state.cmcdLayout = CMCD_FIXED_SLOTS;
  state.cmcdBytes  = u8;

  // Ver: 2 bytes LE numeric
  const ver = (u8[0] | (u8[1]<<8)) >>> 0;
  const verEl = document.querySelector('[data-cmcd="Ver"]');
  if(verEl) verEl.value = String(ver);

  for(const key of CMCD_KEYS_UI){
    if(key==="Ver") continue;
    const sl = _cmcdSlotForKey(key);
    if(!sl) continue;
    const s = sl[0], len = sl[1];
    const raw = u8.slice(s, s+len);
    let end = raw.length;
    for(let j=0;j<raw.length;j++){ if(raw[j]===0){ end=j; break; } }
    const txt = _sjisDecode(raw.slice(0,end)).replace(/\s+$/g,"");
    const inp = document.querySelector(`[data-cmcd="${key}"]`);
    if(inp) inp.value = txt;
  }

  const dbg = $("cmcdRawArea");
  if(dbg){
    const lines = [];
    for(const k of CMCD_KEYS_UI){
      const v = document.querySelector(`[data-cmcd="${k}"]`)?.value || "";
      lines.push(`${k}: ${v}`);
    }
    dbg.value = lines.join("\n");
  }
}


function cmcdBuildBytesFromInputs(){
  const out = new Uint8Array(2048);
  out.fill(0);

  // Ver numeric 2 bytes LE
  const verStr = (document.querySelector('[data-cmcd="Ver"]')?.value || "0").trim();
  const verNum = Math.max(0, Math.min(65535, parseInt(verStr,10) || 0));
  out[0] = verNum & 0xFF;
  out[1] = (verNum>>8) & 0xFF;

  for(const key of CMCD_KEYS_UI){
    if(key==="Ver") continue;
    const sl = _cmcdSlotForKey(key);
    if(!sl) continue;
    const s = sl[0], len = sl[1];
    const v = (document.querySelector(`[data-cmcd="${key}"]`)?.value || "").toString();
    const bytes = _sjisEncode(v);
    const wlen = Math.min(bytes.length, Math.max(0, len-1)); // keep terminator
    out.set(bytes.slice(0,wlen), s);
  }

  const dbg = $("cmcdRawArea");
  if(dbg){
    const lines = [];
    for(const k of CMCD_KEYS_UI){
      const v = document.querySelector(`[data-cmcd="${k}"]`)?.value || "";
      lines.push(`${k}: ${v}`);
    }
    dbg.value = lines.join("\n");
  }
  return out;
}
function buildCmcdChunkFixed2048(){
  const payload = cmcdBuildBytesFromInputs();
  let any=false; for(let i=0;i<payload.length;i++){ if(payload[i]!==0){ any=true; break; } }
  if(!any) return null;

  const dataSize = 2048;
  const buf = new ArrayBuffer(_pad2(8 + dataSize));
  const dv = new DataView(buf);
  let o=0;
  o = _writeStr(dv,o,"cmcd");
  o = _writeU32(dv,o,dataSize);
  new Uint8Array(buf).set(payload, o);
  return buf;
}

function _renderCmcdGrid(grid, dataAttr){
  if(!grid) return;
  if(grid.dataset.ready==="1") return;
  grid.innerHTML = "";
  for(const key of CMCD_KEYS_UI){
    const lab = document.createElement("label");
    lab.className = "cmcdRow";
    const sp = document.createElement("span");
    sp.className = "cmcdKey";
    sp.textContent = key;
    const inp = document.createElement("input");
    inp.className = "cmcdVal";
    inp.type = "text";
    inp.setAttribute(dataAttr, key);
    inp.placeholder = key;
    lab.appendChild(sp);
    lab.appendChild(inp);
    grid.appendChild(lab);
  }
  grid.dataset.ready = "1";
}

function renderCmcdForm(){
  _renderCmcdGrid(document.querySelector('#cmcdDialog [data-tabpanel="cmcdIn"] .cmcdGrid'), "data-cmcd");
  _renderCmcdGrid($("cmcd_pm_grid"), "data-cmcdpm");
}


// ===============================
// CMCD Presets (localStorage)
// ===============================
const CMCD_PRESET_STORAGE_KEY = "wavcue_cmcd_presets_v1";
const CMCD_PRESET_ORDER_STORAGE_KEY = "wavcue_cmcd_preset_order_v1";

function _cmcdLoadPresetOrder(){
  if(state.cmcdPresetOrderLoaded) return state.cmcdPresetOrder || [];
  state.cmcdPresetOrderLoaded = true;
  try{
    const raw = localStorage.getItem(CMCD_PRESET_ORDER_STORAGE_KEY);
    const list = raw ? JSON.parse(raw) : [];
    state.cmcdPresetOrder = Array.isArray(list) ? list.filter(Boolean) : [];
  }catch(_){
    state.cmcdPresetOrder = [];
  }
  return state.cmcdPresetOrder || [];
}
function _cmcdSavePresetOrder(){
  try{
    localStorage.setItem(CMCD_PRESET_ORDER_STORAGE_KEY, JSON.stringify(state.cmcdPresetOrder || []));
  }catch(_){}
}
function _cmcdGetOrderedUserPresets(){
  _cmcdLoadUserPresets();
  _cmcdLoadPresetOrder();
  const list = (state.cmcdUserPresets || []).slice();
  const ids = list.map(p=>p && p.id).filter(Boolean);
  try{
    const norm = _qcNormalizePresetOrder(state.cmcdPresetOrder, ids);
    state.cmcdPresetOrder = norm;
    _cmcdSavePresetOrder();
    const byId = new Map(list.map(p=>[p.id,p]));
    const ordered = norm.map(id=>byId.get(id)).filter(Boolean);
    for(const p of list){ if(p && !norm.includes(p.id)) ordered.push(p); }
    return ordered;
  }catch(_){
    return list;
  }
}


function _cmcdLoadUserPresets(){
  if(state.cmcdUserPresetsLoaded) return state.cmcdUserPresets || [];
  state.cmcdUserPresetsLoaded = true;
  try{
    const raw = localStorage.getItem(CMCD_PRESET_STORAGE_KEY);
    const list = raw ? JSON.parse(raw) : [];
    state.cmcdUserPresets = Array.isArray(list) ? list.filter(p=>p && typeof p==="object") : [];
  }catch(e){
    state.cmcdUserPresets = [];
    try{ log("WARN: cmcdプリセット読み込み失敗: " + (e?.message || e)); }catch(_){}
  }
  return state.cmcdUserPresets || [];
}

function _cmcdSaveUserPresets(){
  try{
    localStorage.setItem(CMCD_PRESET_STORAGE_KEY, JSON.stringify(state.cmcdUserPresets || []));
  }catch(e){
    try{ log("WARN: cmcdプリセット保存失敗: " + (e?.message || e)); }catch(_){}
  }
}

function _cmcdGetPresetById(id){
  return (state.cmcdUserPresets || []).find(p=>p && p.id===id) || null;
}

function _cmcdNewId(){
  return "cmcd_" + Math.random().toString(36).slice(2,10) + Date.now().toString(36).slice(2,6);
}

function _cmcdCaptureInputs(){
      const values = {};
      for(const k of CMCD_KEYS_UI){
        const v = document.querySelector(`[data-cmcd="${k}"]`)?.value ?? "";
        values[k] = String(v);
      }
      return values;
}
function _cmcdSerializeInputs(){
  try{ return JSON.stringify(_cmcdCaptureInputs()); }catch(_){ return ""; }
}
function _cmcdApplySerializedToInputs(value){
  if(!value){ _cmcdClearInputs(); return; }
  let obj = null;
  try{
    obj = JSON.parse(String(value));
  }catch(_){
    obj = null;
  }
  if(obj && typeof obj === "object"){
    _cmcdApplyValuesToInputs(obj);
    return;
  }
  _cmcdClearInputs();
}
function _cmcdClearInputs(){
  document.querySelectorAll('[data-cmcd]').forEach(inp=>{ inp.value = ""; });
  try{ cmcdBuildBytesFromInputs(); }catch(_){ }
  try{ refreshCmcdView(); }catch(_){ }
}
function _cmcdHasValues(values){
  if(!values) return false;
  if(typeof values === "string"){
    let obj = null;
    try{ obj = JSON.parse(values); }catch(_){ obj = null; }
    if(obj && typeof obj === "object"){
      return CMCD_KEYS_UI.some(k=> String(obj[k] ?? "").trim());
    }
    return values.trim().length > 0;
  }
  if(typeof values !== "object") return false;
  return CMCD_KEYS_UI.some(k=> String(values[k] ?? "").trim());
}
function _cmcdApplyValuesToInputs(values){
  renderCmcdForm();
  for(const k of CMCD_KEYS_UI){
    const inp = document.querySelector(`[data-cmcd="${k}"]`);
    if(!inp) continue;
    inp.value = (values && (k in values)) ? String(values[k] ?? "") : "";
  }
  try{ cmcdBuildBytesFromInputs(); }catch(_){ }
  try{ refreshCmcdView(); }catch(_){ }
}
function _cmcdGetInputProxy(){
  return {
    get value(){ return _cmcdSerializeInputs(); },
    set value(v){
      if(!v || v === ""){ _cmcdClearInputs(); return; }
      if(typeof v === "object"){ _cmcdApplyValuesToInputs(v); return; }
      _cmcdApplySerializedToInputs(v);
    },
  };
}

try{
  window._cmcdCaptureInputs = window._cmcdCaptureInputs || _cmcdCaptureInputs;
  window._cmcdApplyValuesToInputs = window._cmcdApplyValuesToInputs || _cmcdApplyValuesToInputs;
  window._cmcdSerializeInputs = window._cmcdSerializeInputs || _cmcdSerializeInputs;
  window._cmcdApplySerializedToInputs = window._cmcdApplySerializedToInputs || _cmcdApplySerializedToInputs;
  window._cmcdInput = window._cmcdInput || _cmcdGetInputProxy();
}catch(_){ }

function _proGetActiveFileId(){
  return (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
}
function _proGetRecById(id){
  return (typeof window.__wavcueProGetRecById === "function") ? window.__wavcueProGetRecById(id) : null;
}
function _proGetActiveRec(){
  const id = _proGetActiveFileId();
  if(!id) return null;
  return _proGetRecById(id);
}
function _syncActiveRecAttachments(){
  const rec = _proGetActiveRec();
  if(!rec) return null;
  const list = Array.isArray(state.attachments) ? state.attachments.slice() : [];
  rec.attachments = list;
  rec.attachCount = list.length;
  return rec;
}
function _normalizeAttachmentList(list){
  if(!Array.isArray(list)) return [];
  return list.slice(0, 9).map((item)=>{
    if(!item) return null;
    if(typeof item === "string") return _attEnsureId({ name: item });
    if(typeof item === "object"){
      const name = item.name || item.fileName || item.filename || item.title || "";
      return _attEnsureId({ ...item, name });
    }
    return null;
  }).filter(Boolean);
}
function _isEmptyCmcdTemplateString(value){
  try{
    if(typeof value !== "string") return false;
    const obj = JSON.parse(value);
    if(!obj || typeof obj !== "object") return false;
    for(const key of Object.keys(obj)){
      const v = obj[key];
      if(v != null && String(v).trim().length > 0) return false;
    }
    return true;
  }catch(_){
    return false;
  }
}
function normalizeRecArtifacts(rec, stateLike){
  if(!rec) return;
  let imported = false;
  const src = stateLike || rec?._stateSnap || null;
  try{
    const cmcdCandidates = [
      rec.cmcd,
      rec.cmcdText,
      rec.cmcdValue,
      rec.cmcdInputs,
      rec.meta?.cmcd,
      rec.bwfj?.cmcd,
      src?.cmcd,
      src?.cmcdValue,
      src?.cmcdText,
      src?.cmcdInputs,
      src?.meta?.cmcd,
      src?.bwfj?.cmcd,
    ];
    if(!rec.cmcd){
      for(const c of cmcdCandidates){
        if(!c) continue;
        if(typeof c === "string"){ rec.cmcd = c; break; }
        if(typeof c === "object"){ try{ rec.cmcd = JSON.stringify(c); }catch(_){ rec.cmcd = ""; } break; }
      }
      if(rec.cmcd) imported = true;
    }
    if(typeof rec.cmcd !== "string") rec.cmcd = (rec.cmcd ? String(rec.cmcd) : "");
    const hasInputs = rec.cmcdInputs && window._cmcdInputsHasValues(rec.cmcdInputs);
    const hasStr = typeof rec.cmcd === "string" && rec.cmcd.trim().length > 0;
    const emptyTemplate = hasStr && _isEmptyCmcdTemplateString(rec.cmcd);
    if(hasInputs && (!hasStr || emptyTemplate)){
      try{ rec.cmcd = JSON.stringify(rec.cmcdInputs); }catch(_){ rec.cmcd = ""; }
      if(emptyTemplate){
        console.log("[CMCD] prefer inputs over empty template", {
          fileId: rec.fileId || rec.id,
          cmcdLen: rec.cmcd.length,
        });
      }
    }
  }catch(err){
    console.error("[MIGRATE] cmcd normalize error", err);
    rec.cmcd = typeof rec.cmcd === "string" ? rec.cmcd : "";
  }
  try{
    const attCandidates = [
      rec.attachments,
      rec.pdfs,
      rec.pdfAttachments,
      rec.attachedPdfs,
      rec.meta?.pdf,
      rec.bwfj?.pdf,
      src?.attachments,
      src?.pdfs,
      src?.pdfAttachments,
      src?.attachedPdfs,
      src?.meta?.attachments,
      src?.meta?.pdfs,
      src?.bwfj?.attachments,
      src?.bwfj?.pdfs,
    ];
    if(!Array.isArray(rec.attachments) || !rec.attachments.length){
      for(const list of attCandidates){
        if(Array.isArray(list) && list.length){
          rec.attachments = _normalizeAttachmentList(list);
          break;
        }
      }
      if(Array.isArray(rec.attachments) && rec.attachments.length) imported = true;
    }
    if(!Array.isArray(rec.attachments)) rec.attachments = [];
  }catch(err){
    console.error("[MIGRATE] pdf normalize error", err);
    rec.attachments = Array.isArray(rec.attachments) ? rec.attachments : [];
  }
  try{
    console.log("[MIGRATE]", "normalizeRecArtifacts", {
      fileId: rec.fileId || rec.id,
      cmcdLen: rec.cmcd.length,
      pdfCount: rec.attachments.length,
    });
    if(imported){
      console.log("[MIGRATE]", "imported", {
        fileId: rec.fileId || rec.id,
        cmcdLen: rec.cmcd.length,
        pdfCount: rec.attachments.length,
      });
    }else if(src){
      console.warn("[MIGRATE]", "no artifacts found", { fileId: rec.fileId || rec.id });
      if(typeof window.deepFindByKey === "function"){
        console.log("[MIGRATE][FIND]", "cmcd", window.deepFindByKey(src, (k)=> String(k).toLowerCase().includes("cmcd"), 20));
        console.log("[MIGRATE][FIND]", "pdf/attach", window.deepFindByKey(src, (k)=> {
          const key = String(k).toLowerCase();
          return key.includes("pdf") || key.includes("attach");
        }, 20));
        console.log("[MIGRATE][FIND]", "pdf arrays", window.deepFindByKey(src, (_k,v)=> {
          return Array.isArray(v) && v.length && (v[0]?.name || v[0]?.fileName || v[0]?.mime);
        }, 20));
      }
      if(typeof window.summarizeKeys === "function"){
        window.summarizeKeys(src, "stateLike");
      }
    }
  }catch(_){ }
}
try{
  if(typeof window.normalizeRecArtifacts !== "function"){
    window.normalizeRecArtifacts = normalizeRecArtifacts;
  }
}catch(_){ }


function _cmcdCapturePmInputs(){
  const values = {};
  document.querySelectorAll('[data-cmcdpm]').forEach(inp=>{
    const k = inp.getAttribute("data-cmcdpm");
    if(!k) return;
    values[k] = String(inp.value ?? "");
  });
  return values;
}
function _cmcdSetPmInputs(values){
  for(const k of CMCD_KEYS_UI){
    const inp = document.querySelector(`[data-cmcdpm="${k}"]`);
    if(!inp) continue;
    inp.value = (values && (k in values)) ? String(values[k] ?? "") : "";
  }
}
function _cmcdPreviewToText(values){
  const lines = [];
  for(const k of CMCD_KEYS_UI){
    const v = values && (k in values) ? String(values[k] ?? "") : "";
    if((v||"").trim()) lines.push(`${k}: ${v}`);
  }
  return lines.join("\n") || "（空）";
}

function _cmcdPopulatePresetSelects(){
  _cmcdLoadUserPresets();
  _cmcdLoadPresetOrder();

  const sel = $("cmcd_preset");
  if(sel){
    const keep = (state.cmcdPresetId || "");
    sel.innerHTML = "";
    const o0 = document.createElement("option");
    o0.value = "";
    o0.textContent = "（プリセットなし）";
    sel.appendChild(o0);
    for(const p of _cmcdGetOrderedUserPresets()){
      const o = document.createElement("option");
      o.value = p.id;
      o.textContent = p.name || "（無名）";
      sel.appendChild(o);
    }
    sel.value = (keep && _cmcdGetPresetById(keep)) ? keep : "";
  }

  const pick = $("cmcd_pm_pick");
  if(pick){
    const cur = pick.value;
    pick.innerHTML = "";
    const ph = document.createElement("option");
    ph.value = "";
    ph.textContent = "プリセットを選択して編集";
    ph.disabled = true; ph.hidden = true;
    pick.appendChild(ph);

    const oNew = document.createElement("option");
    oNew.value = "__new__";
    oNew.textContent = "新規作成";
    pick.appendChild(oNew);

    for(const p of _cmcdGetOrderedUserPresets()){
      const o = document.createElement("option");
      o.value = p.id;
      o.textContent = p.name || "（無名）";
      pick.appendChild(o);
    }
    pick.value = (cur && _cmcdGetPresetById(cur)) ? cur : "";
  }
}

function _cmcdApplyPreset(id){
  const p = _cmcdGetPresetById(id);
  if(!p) return;
  renderCmcdForm();
  const values = p.values || {};
  for(const k of CMCD_KEYS_UI){
    const inp = document.querySelector(`[data-cmcd="${k}"]`);
    if(!inp) continue;
    inp.value = (k in values) ? String(values[k] ?? "") : "";
  }
  const payload = cmcdBuildBytesFromInputs();
  try{ state.cmcdBytes = payload; }catch(_){}
  try{ refreshCmcdView(); }catch(_){}
}

// cmcd dialog tabs
function setCmcdTab(tab){
  const dlg = $("cmcdDialog");
  if(!dlg) return;
  dlg.querySelectorAll(".tabBtn").forEach(b=>{
    const on = (b.dataset.tab===tab);
    b.classList.toggle("active", on);
    b.setAttribute("aria-selected", on ? "true" : "false");
  });
  dlg.querySelectorAll(".tabPanel").forEach(p=>{
    const on = (p.dataset.tabpanel===tab);
    p.classList.toggle("active", on);
  });
}

function initCmcdTabsOnce(){
  const dlg = $("cmcdDialog");
  if(!dlg || dlg.dataset.tabsReady==="1") return;
  dlg.dataset.tabsReady = "1";
  dlg.querySelectorAll(".tabBtn").forEach(btn=>{
    btn.addEventListener("click", ()=> setCmcdTab(btn.dataset.tab || "cmcdIn"));
  });
  setCmcdTab("cmcdIn");
}

function setupCmcdDialog(){
  const dlg = $("cmcdDialog");
  if(!dlg) return;

  const cmcdInput = window._cmcdInput;
  let editId = "";

  const open = ()=>{
    renderCmcdForm();
    initCmcdTabsOnce();
    _cmcdPopulatePresetSelects();
    if(dlg.showModal) dlg.showModal(); else dlg.open = true;

    // default: preset select is "none" (do not auto-apply)
    const sel = $("cmcd_preset");
    if(sel) sel.value = state.cmcdPresetId || "";
  };
  const close = ()=>{ if(dlg.close) dlg.close(); else dlg.open = false; };

  const sync = ()=>{
    const payload = cmcdBuildBytesFromInputs();
    try{ state.cmcdBytes = payload; }catch(_){}
    try{ refreshCmcdView(); }catch(_){}
    return payload;
  };

  $("btnCmcd")?.addEventListener("click", open);
  $("btnCmcdClose")?.addEventListener("click", close);

  $("cmcd_preset")?.addEventListener("change", (e)=>{
    const id = (e.target && e.target.value) ? String(e.target.value) : "";
    state.cmcdPresetId = id;
    if(id) {
      undoCheckpoint();
      _cmcdApplyPreset(id);
      log("OK: cmcdプリセットを適用しました");
      setCmcdTab("cmcdIn");
    }
  });

  $("btnCmcdClear")?.addEventListener("click", ()=>{
    undoCheckpoint();
    if(cmcdInput) cmcdInput.value = "";
    else{
      document.querySelectorAll('[data-cmcd]').forEach(inp=> inp.value = "");
      sync();
    }
    const rec = _proGetActiveRec();
    if(rec){
      rec.cmcd = "";
      rec.cmcdInputs = null;
      console.log("[CMCD]", "clear", { fileId: rec.id, value: rec.cmcd });
      if(typeof window.commitAll === "function"){
        window.commitAll("cmcd:clear", { fileId: rec.id });
      }
    }
  });

  $("btnCmcdApply")?.addEventListener("click", ()=>{
    undoCheckpoint();
    sync();
    const rec = _proGetActiveRec();
    if(rec){
      const inputs = (typeof _cmcdCaptureInputs === "function") ? _cmcdCaptureInputs() : null;
      if(inputs && window._cmcdInputsHasValues(inputs)){
        rec.cmcdInputs = inputs;
        rec.cmcd = JSON.stringify(inputs);
      }else{
        rec.cmcdInputs = null;
        rec.cmcd = "";
      }
      console.log("[CMCD]", "apply", { fileId: rec.id, value: rec.cmcd });
      if(typeof window.commitAll === "function"){
        window.commitAll("cmcd:apply", { fileId: rec.id });
      }
    }
    log("OK: cmcd入力を反映しました");
    close();
  });

  dlg.addEventListener("input", ()=>{ sync(); });

  // ---- preset manager tab ----
  const fillEditorFromPreset = (id)=>{
    editId = id || "";
    const p = _cmcdGetPresetById(editId);
    const nameEl = $("cmcd_pm_name");
    if(!p){
      if(nameEl) nameEl.value = "";
      _cmcdSetPmInputs(null);
      return;
    }
    if(nameEl) nameEl.value = p.name || "";
    _cmcdSetPmInputs(p.values || {});
  };

  $("cmcd_pm_pick")?.addEventListener("change", (e)=>{
    const sel = (e && e.target) ? e.target : $("cmcd_pm_pick");
    const v = sel ? String(sel.value || "") : "";
    try{
      if(sel){
        sel.classList.toggle("isPlaceholder", (!v) || (v==="__new__"));
        sel.classList.toggle("isNew", v==="__new__");
      }
    }catch(_){ }
    if(v==="__new__"){
      editId = "";
      if($("cmcd_pm_name")) $("cmcd_pm_name").value = "";
      _cmcdSetPmInputs(null);
      return;
    }
    if(!v){
      editId = "";
      if($("cmcd_pm_name")) $("cmcd_pm_name").value = "";
      _cmcdSetPmInputs(null);
      return;
    }
    fillEditorFromPreset(v);
  });

  
  
  
  $("cmcd_pm_new")?.addEventListener("click", ()=>{
    const sel = $("cmcd_pm_pick");
    if(!sel) return;
    sel.value = "__new__";
    sel.dispatchEvent(new Event("change", {bubbles:true}));
    try{ sel.classList.toggle("isNew", String(sel.value||"")==="__new__"); }catch(_){ }
    try{ _cmcdPmToggleSortPanel(false); }catch(_){}
  });

  $("cmcd_pm_clone")?.addEventListener("click", ()=>{
    const srcId = String($("cmcd_pm_pick")?.value || editId || "").trim();
    if(!srcId || srcId==="__new__"){
      window.safeToast && window.safeToast("複製するプリセットを選択してください。","warn");
      return;
    }
    const base = _cmcdGetPresetById(srcId);
    if(!base){
      window.safeToast && window.safeToast("プリセットが見つかりません。","warn");
      return;
    }
    editId = "";
    const sel = $("cmcd_pm_pick");
    if(sel){
      sel.value = "__new__";
      try{ sel.classList.toggle("isNew", true); }catch(_){ }
    }
    if($("cmcd_pm_name")) $("cmcd_pm_name").value = String(base.name||"") + "（複製）";
    _cmcdSetPmInputs(base.values || null);
    try{ _cmcdPmToggleSortPanel(false); }catch(_){}
    window.safeToast && window.safeToast("複製しました。名前を調整して「保存」すると新規プリセットとして登録されます。","ok");
  });

  $("cmcd_pm_export")?.addEventListener("click", ()=>{
    _cmcdOpenPresetExportSelector();
  });

  $("cmcd_pm_import")?.addEventListener("click", ()=>{
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json,.json";
    inp.addEventListener("change", async ()=>{
      const f = inp.files && inp.files[0];
      if(!f) return;
      try{
        const txt = await f.text();
        const obj = JSON.parse(txt);
        const arr = Array.isArray(obj?.presets) ? obj.presets : (Array.isArray(obj) ? obj : null);
        if(!arr){
          window.safeToast && window.safeToast("JSON形式が不正です。","warn");
          return;
        }
        const existing = Array.isArray(state.cmcdUserPresets) ? state.cmcdUserPresets.slice() : [];
        const existingIds = new Set(existing.map(p=>p && p.id).filter(Boolean));
        const importedIds = [];

        for(const raw of arr){
          if(!raw) continue;
          const name = String(raw.name||"").trim() || "Imported";
          const values = (raw.values && typeof raw.values==="object") ? raw.values : {};
          let id = String(raw.id||"").trim();
          if(!id || existingIds.has(id)) id = _cmcdNewId();
          existingIds.add(id);
          existing.push({id, name, values});
          importedIds.push(id);
        }

        if(importedIds.length===0){
          window.safeToast && window.safeToast("インポート対象がありません。","warn");
          return;
        }

        state.cmcdUserPresets = existing;

        const allIds = existing.map(p=>p.id);
        let ord = _qcNormalizePresetOrder(state.cmcdPresetOrder, allIds);
        for(const id of importedIds){ if(!ord.includes(id)) ord.push(id); }
        state.cmcdPresetOrder = ord;

        _cmcdSavePresetOrder();
        _cmcdSaveUserPresets();
        _cmcdPopulatePresetSelects();

        const first = importedIds[0];
        const sel = $("cmcd_pm_pick");
        if(sel){
          sel.value = first;
          try{ sel.classList.toggle("isNew", false); }catch(_){ }
        }
        fillEditorFromPreset(first);
        window.safeToast && window.safeToast("インポートしました。","ok");
      }catch(e){
        window.safeToast && window.safeToast("インポートに失敗しました。","warn");
        try{ log("WARN: cmcdプリセットインポート失敗: "+(e?.message||e)); }catch(_){}
      }
    });
    inp.click();
  });


  $("cmcd_pm_delete")?.addEventListener("click", ()=>{
    const id = String($("cmcd_pm_pick")?.value || editId || "");
    if(!id || id==="__new__") return;
    if(!confirm("このプリセットを削除します。よろしいですか？")) return;

    const list = (state.cmcdUserPresets || []).slice().filter(p=>p && p.id!==id);
    state.cmcdUserPresets = list;

    const ids = list.map(p=>p.id);
    try{
      state.cmcdPresetOrder = _qcNormalizePresetOrder(state.cmcdPresetOrder, ids).filter(x=>ids.includes(x));
      _cmcdSavePresetOrder();
    }catch(_){}
    _cmcdSaveUserPresets();
    _cmcdPopulatePresetSelects();

    editId = "";
    if($("cmcd_pm_pick")) $("cmcd_pm_pick").value = "";
    if($("cmcd_pm_name")) $("cmcd_pm_name").value = "";
    _cmcdSetPmInputs(null);

    window.safeToast && window.safeToast("削除しました。","ok");
  });

$("cmcd_pm_save")?.addEventListener("click", ()=>{
    const pickVal = $("cmcd_pm_pick")?.value || "";
    const name = String($("cmcd_pm_name")?.value || "").trim();
    if(!name){
      window.safeToast && window.safeToast("プリセット名を入力してください。","warn");
      return;
    }

    const values = _cmcdCapturePmInputs();

    _cmcdLoadUserPresets();
    _cmcdLoadPresetOrder();

    // determine id: edit existing if selected, otherwise create new
    let id = "";
    if(pickVal && pickVal !== "__new__" && _cmcdGetPresetById(pickVal)){
      id = pickVal;
    }else if(editId && _cmcdGetPresetById(editId)){
      id = editId;
    }else{
      id = _cmcdNewId();
    }

    const preset = { id, name, values };

    const list = (state.cmcdUserPresets || []).slice();
    const i = list.findIndex(p=>p && p.id===id);
    if(i>=0) list[i] = preset; else list.push(preset);
    state.cmcdUserPresets = list;

    // keep order: if new, append to end; if rename, keep position
    const ids = list.map(p=>p.id);
    try{
      const norm = _qcNormalizePresetOrder(state.cmcdPresetOrder, ids);
      state.cmcdPresetOrder = norm;
      if(!norm.includes(id)) state.cmcdPresetOrder = norm.concat([id]);
      _cmcdSavePresetOrder();
    }catch(_){}

    _cmcdSaveUserPresets();
    _cmcdPopulatePresetSelects();

    editId = id;
    if($("cmcd_pm_pick")) $("cmcd_pm_pick").value = id;
    window.safeToast && window.safeToast("保存しました。","ok");
  });

  $("cmcd_pm_sortBtn")?.addEventListener("click", ()=>{ _cmcdPmToggleSortPanel(); });

  
  }




function _cmcdPmToggleSortPanel(force){
  const p = $("cmcd_pm_sortPanel");
  if(!p) return;
  const want = (typeof force==="boolean") ? force : !(p.dataset.open==="1");
  p.dataset.open = want ? "1" : "0";
  p.style.display = want ? "block" : "none";
  if(want){
    try{ _cmcdPmRenderSortList(); }catch(_){}
  }
}

function _cmcdPmRenderSortList(){
  const wrap = $("cmcd_pm_sortList");
  if(!wrap) return;
  const list = _cmcdGetOrderedUserPresets();
  wrap.innerHTML = "";
  if(!list.length){
    const empty = document.createElement("div");
    empty.className = "muted";
    empty.style.fontSize = "12px";
    empty.textContent = "プリセットがありません。";
    wrap.appendChild(empty);
    return;
  }
  for(const p of list){
    const row = document.createElement("div");
    row.className = "scSortItem";
    row.draggable = true;
    row.dataset.id = p.id;

    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.alignItems = "center";
    left.style.gap = "10px";

    const handle = document.createElement("div");
    handle.className = "scSortHandle";
    handle.textContent = "⋮⋮";
    left.appendChild(handle);

    const name = document.createElement("div");
    name.style.display = "flex";
    name.style.flexDirection = "column";
    name.style.gap = "2px";

    const t = document.createElement("div");
    t.textContent = p.name || p.id;
    name.appendChild(t);

    left.appendChild(name);

    // expand left to keep buttons aligned right
    left.style.flex = "1";

    const del = document.createElement("button");
    del.type = "button";
    del.className = "btn warn";
    del.style.borderRadius = "999px";
    del.style.padding = "6px 10px";
    del.style.fontSize = "12px";
    del.textContent = "削除";
    del.title = "このプリセットを削除します";
    del.addEventListener("pointerdown", (e)=>{ e.preventDefault(); e.stopPropagation(); });
    del.addEventListener("click", (e)=>{
      e.preventDefault(); e.stopPropagation();
      const id = p.id;
      if(!id) return;
      if(!confirm("このプリセットを削除します。よろしいですか？")) return;

      const list2 = (state.cmcdUserPresets || []).slice().filter(x=>x && x.id!==id);
      state.cmcdUserPresets = list2;

      const ids2 = list2.map(x=>x.id);
      try{
        state.cmcdPresetOrder = _qcNormalizePresetOrder(state.cmcdPresetOrder, ids2).filter(x=>ids2.includes(x));
        _cmcdSavePresetOrder();
      }catch(_){}
      _cmcdSaveUserPresets();
      _cmcdPopulatePresetSelects();

      // clear editor if we were editing the deleted preset
      if(String($("cmcd_pm_pick")?.value || "") === id){
        if($("cmcd_pm_pick")) $("cmcd_pm_pick").value = "";
        if($("cmcd_pm_name")) $("cmcd_pm_name").value = "";
        _cmcdSetPmInputs(null);
      }

      // refresh list (keep sort panel open)
      try{ _cmcdPmRenderSortList(); }catch(_){}

      window.safeToast && window.safeToast("削除しました。","ok");
    });

    row.appendChild(left);
    row.appendChild(del);
    wrap.appendChild(row);
  }
  _cmcdPmWireDragSort(wrap);
}

function _cmcdPmWireDragSort(container){
  if(!container || container.dataset.wired==="1") return;
  container.dataset.wired = "1";
  let dragging = null;

  container.addEventListener("dragstart", (e)=>{
    const item = e.target && e.target.closest ? e.target.closest(".scSortItem") : null;
    if(!item) return;
    dragging = item;
    item.classList.add("dragging");
    try{ e.dataTransfer.effectAllowed = "move"; }catch(_){}
    try{ e.dataTransfer.setData("text/plain", item.dataset.id||""); }catch(_){}
  });

  container.addEventListener("dragend", ()=>{
    if(dragging) dragging.classList.remove("dragging");
    for(const el of container.querySelectorAll(".scSortItem.dragOver")) el.classList.remove("dragOver");
    dragging = null;
    _cmcdPmCommitSortFromDom(container);
  });

  container.addEventListener("dragover", (e)=>{
    if(!dragging) return;
    e.preventDefault();
    const item = e.target && e.target.closest ? e.target.closest(".scSortItem") : null;
    if(!item || item===dragging) return;

    for(const el of container.querySelectorAll(".scSortItem.dragOver")) el.classList.remove("dragOver");
    item.classList.add("dragOver");

    const rect = item.getBoundingClientRect();
    const before = (e.clientY < rect.top + rect.height/2);

    if(before){
      if(item.previousSibling !== dragging) container.insertBefore(dragging, item);
    }else{
      if(item.nextSibling !== dragging) container.insertBefore(dragging, item.nextSibling);
    }
  });
}

function _cmcdPmCommitSortFromDom(container){
  try{
    const ids = Array.from(container.querySelectorAll(".scSortItem"))
      .map(el=>el.dataset.id)
      .filter(Boolean);

    const all = (state.cmcdUserPresets || []).slice();
    const allIds = all.map(p=>p.id);
    const norm = _qcNormalizePresetOrder(ids, allIds);

    state.cmcdPresetOrder = norm;
    _cmcdSavePresetOrder();

    _cmcdPopulatePresetSelects();
    window.safeToast && window.safeToast("並び順を保存しました。","ok");
  }catch(_){}
}


/* ===============================
   AUDIO_BUILD: RIFF/WAVE writer helpers
================================ */

function normalizePcmFmtPayload(payloadU8){
  const base = (payloadU8 instanceof Uint8Array) ? payloadU8 : new Uint8Array(payloadU8 || []);
  let normalized = false;
  let payload = base;
  try{
    if(payload.byteLength >= 18){
      const dv = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
      const wFormatTag = dv.getUint16(0, true);
      const cbSize = dv.getUint16(16, true);
      if(wFormatTag === 1 && cbSize === 0 && payload.byteLength > 16){
        payload = payload.slice(0, 16);
        normalized = true;
      }
    }
  }catch(_){ }
  return { payload, normalized };
}

function buildCueChunks(buffer, cues){
  const sr = (state && state.fileSr && isFinite(state.fileSr)) ? state.fileSr : ((buffer && buffer.sampleRate)?buffer.sampleRate:48000);
  let totalSamples = (state && state.fileTotalSamples && isFinite(state.fileTotalSamples)) ? state.fileTotalSamples : ((buffer && Number.isFinite(buffer.length)) ? buffer.length : 0);
  if(!totalSamples || totalSamples<=0){
    const dur = (buffer && Number.isFinite(buffer.duration)) ? buffer.duration : 0;
    totalSamples = Math.max(1, Math.round(dur * sr));
  }

  let exportCues = Array.isArray(cues) ? cues.slice() : [];

  // sanitize IDs: keep original when possible; remap only 0/duplicates
  try{ exportCues = normalizeCueIds(exportCues); }catch(_){ }
  const _usedIds = new Set(exportCues.map(c=> (c && isFinite(c.id)) ? (c.id>>>0) : 0).filter(id=>id!==0));
  const _allocUnusedId = ()=>{
    let id = 1;
    while(id===0 || _usedIds.has(id)) id++;
    _usedIds.add(id);
    return id>>>0;
  };

  const atts = Array.isArray(state.attachments) ? state.attachments.slice(0, 9) : [];
  const hasAttach = atts.some(a=>a && a.bytes && a.bytes.length);

  // 添付がある場合は NOTE1..NOTE9 を必要数だけ用意（重複禁止）
  if(hasAttach){
    for(let i=0;i<atts.length;i++){
      const wantLabel = `BC$NOTE${i+1}`;
      const has = exportCues.some(c=>{
        try{
          const lbl = ((c && c.label)!=null ? String(c.label) : "").trim();
          return lbl===wantLabel || lbl===`BC$NOTE(${i+1})`;
        }catch(_){ return false; }
      });
      if(!has){
        exportCues.push({ id: _allocUnusedId(), label: wantLabel, sec: 0 });
      }
    }
  }

  const _ecNormLbl = (s)=> String(s||"").trim().replace(/\s+/g,"");
  const isNoteCue = (c)=>{
    const t = _ecNormLbl(c && c.label);
    return /^BC\$NOTE\(?\d+\)?$/i.test(t);
  };
  const isLabel = (c, want)=>{
    const t = _ecNormLbl(c && c.label).toUpperCase();
    return t === want;
  };
  const rank = (c)=>{
    if(isNoteCue(c)) return 0;     // NOTE*
    if(isLabel(c,"BC$STANDBY")) return 1;
    if(isLabel(c,"BC$END")) return 2;
    if(isLabel(c,"BC$START")) return 3;
    if(isLabel(c,"BC$STOP")) return 4;
    return 5;
  };


  const sorted = exportCues.slice().sort((a,b)=>{
    const ra=rank(a), rb=rank(b);
    if(ra!==rb) return ra-rb;
    const ta=(a.sec||0), tb=(b.sec||0);
    if(ta!==tb) return ta-tb;
    return (a.id||0)-(b.id||0);
  });

  // ---- cue chunk ----
  const cueCount = sorted.length;
  const cueDataSize = 4 + cueCount * 24;
  const cueBuf = new ArrayBuffer(8 + cueDataSize + (cueDataSize%2));
  const cueDv = new DataView(cueBuf);
  _writeStr(cueDv, 0, "cue ");
  cueDv.setUint32(4, cueDataSize, true);
  cueDv.setUint32(8, cueCount, true);

  let p = 12;
  for(const c of sorted){
    let sampleOffset = Math.max(0, Math.min(totalSamples-1, Math.round((c.sec||0) * sr)));
    if(isNoteCue(c)) sampleOffset = 0; // NOTE固定

    cueDv.setUint32(p+0, (c.id>>>0), true);        // dwName
    cueDv.setUint32(p+4, 0, true);                 // dwPosition (互換性: 常に0)
    _writeStr(cueDv, p+8, "data");                 // fccChunk
    cueDv.setUint32(p+12, 0, true);                // dwChunkStart
    cueDv.setUint32(p+16, 0, true);                // dwBlockStart
    cueDv.setUint32(p+20, (sampleOffset>>>0), true);// dwSampleOffset
    p += 24;
  }

  // ---- LIST/adtl ----
  const lablParts = [];
  const fileParts = [];
  const noteCueIds = new Map(); // noteIndex -> cueId
  for(const c of sorted){
    let labelText = (c.label || "").toString().trim();

    // NOTE(1) などの表記ゆれを統一
    const m = /^BC\$NOTE\(?(\d+)\)?$/i.exec(labelText.replace(/\s+/g,""));
    let noteIndex = null;
    if(m){
      const n = parseInt(m[1],10);
      if(isFinite(n) && n>=1 && n<=9){
        noteIndex = n;
        labelText = `BC$NOTE${n}`;
        noteCueIds.set(n, (c.id>>>0));
      }
    }

    const __encLbl = cp932EncodeEx(labelText + "\0");
    if(__encLbl && __encLbl.hadReplace){ throw new Error("Label contains CP932-unencodable char"); }
    const labelBytes = (__encLbl && __encLbl.bytes) ? __encLbl.bytes : _sjisEncode(labelText + "\0");
    const lablSize = 4 + labelBytes.length;
    const pad = (lablSize % 2);
    const lablBuf = new ArrayBuffer(8 + lablSize + pad);
    const dv = new DataView(lablBuf);
    _writeStr(dv, 0, "labl");
    dv.setUint32(4, lablSize, true);
    dv.setUint32(8, (c.id>>>0), true);
    new Uint8Array(lablBuf, 12, labelBytes.length).set(labelBytes);
    lablParts.push(new Uint8Array(lablBuf));
  }

  // 添付がある場合は NOTE順に file サブチャンクを最後へまとめる
  if(hasAttach){
    for(let i=1;i<=atts.length;i++){
      const att = atts[i-1];
      const cueId = noteCueIds.get(i);
      if(!cueId) continue;
      if(att && ((att.bytes && att.bytes.length) || att._storeId!=null)){
        try{
          const bytes = (att.bytes && att.bytes.length) ? att.bytes : _pdfStoreGet(att._storeId);
          if(bytes && bytes.length) fileParts.push(pdfBuildFileSubchunk(att.name, bytes, cueId));
        }catch(_){ }
      }
    }
  }

  const subParts = [...lablParts, ...fileParts];
  const listContentLen = 4 + subParts.reduce((a,b)=>a+b.length,0);
  const listBuf = new ArrayBuffer(8 + listContentLen + (listContentLen % 2));
  const ldv = new DataView(listBuf);
  _writeStr(ldv, 0, "LIST");
  ldv.setUint32(4, listContentLen, true);
  _writeStr(ldv, 8, "adtl");
  let lp = 12;
  for(const part of subParts){
    new Uint8Array(listBuf, lp, part.length).set(part);
    lp += part.length;
  }

  // ---- plst（BC$NOTE以外のBC$を時間順に列挙 / 規格互換） ----
  let plstBuf = null;
  try{
    const bcList = sorted
      .filter(c=>{
        const t = _ecNormLbl(c && c.label).toUpperCase();
        return t.startsWith("BC$") && !t.startsWith("BC$NOTE") && !isNoteCue(c);
      })
      .slice()
      .sort((a,b)=>{
        const ta = (+a.sec || 0), tb = (+b.sec || 0);
        if(ta !== tb) return ta - tb;
        const la = _ecNormLbl(a.label).toUpperCase();
        const lb = _ecNormLbl(b.label).toUpperCase();
        if(la < lb) return -1;
        if(la > lb) return 1;
        return ((a.id>>>0) - (b.id>>>0));
      });

    const segCount = bcList.length;
    if(segCount > 0){
      const plstSize = 4 + segCount * 12;
      plstBuf = new ArrayBuffer(8 + plstSize + (plstSize % 2));
      const pdv = new DataView(plstBuf);
      _writeStr(pdv, 0, "plst");
      pdv.setUint32(4, plstSize, true);
      pdv.setUint32(8, segCount, true);

      let pp = 12;
      for(const c of bcList){
        pdv.setUint32(pp,   (c.id>>>0), true); // dwName
        pdv.setUint32(pp+4, 0,          true); // dwLength
        pdv.setUint32(pp+8, 1,          true); // dwLoops
        pp += 12;
      }
    }else{
      plstBuf = null;
    }
  }catch(_){
    plstBuf = null;
  }

return { cueChunk: cueBuf, listChunk: listBuf, plstChunk: plstBuf };
}



/* ===== BEXT helpers (preserve source by default) ===== */
function bextExtractCodingHistoryText(payloadU8){
  try{
    if(!payloadU8 || payloadU8.length < 602) return "";
    const u8 = payloadU8.subarray(602);
    let end=u8.length;
    for(let i=0;i<u8.length;i++){ if(u8[i]===0){ end=i; break; } }
    const t = new TextDecoder("utf-8").decode(u8.slice(0,end));
    return (t||"").trim();
  }catch(_){ return ""; }
}
function bextBuildPayloadV1FromBase(baseU8, codingHistoryText){
  const fixed = 602;
  let base = baseU8;
  if(!(base instanceof Uint8Array)) base = null;
  const createdNew = (!base || base.length < fixed);
  if(createdNew){
    base = new Uint8Array(fixed);
    base.fill(0);
  }
  // copy first 602 bytes
  const fixedOut = new Uint8Array(fixed);
  fixedOut.set(base.slice(0,fixed));
  // Preserve source bext version (v2 loudness fields live inside the 602-byte fixed area).
  // Only set version when we are creating a new bext from scratch.
  if(createdNew){
    try{
      const dv = new DataView(fixedOut.buffer);
      dv.setUint16(346, 1, true);
    }catch(_){ }
  }
  // normalize CRLF and ensure trailing CRLF if non-empty
  let t = (codingHistoryText||"");
  t = t.replace(/\r?\n/g, "\r\n");
  if(t && !t.endsWith("\r\n")) t += "\r\n";
  const hist = t ? new TextEncoder().encode(t) : new Uint8Array(0);

  const out = new Uint8Array(fixedOut.length + hist.length);
  out.set(fixedOut, 0);
  out.set(hist, fixedOut.length);
  return out;
}
function buildChunkFromPayload(id4, payloadU8){
  const payload = (payloadU8 instanceof Uint8Array) ? payloadU8 : new Uint8Array(payloadU8||[]);
  const size = payload.byteLength >>> 0;
  const total = _pad2(8 + size);
  const buf = new ArrayBuffer(total);
  const dv = new DataView(buf);
  _writeStr(dv, 0, id4);
  dv.setUint32(4, size, true);
  new Uint8Array(buf, 8, size).set(payload);
  return buf;
}
/* ===== /BEXT helpers ===== */


function bextValidateCodingHistoryStrict(codingHistoryText){
  const raw = String(codingHistoryText||"");
  const lines = raw.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").map(s=>s.trim()).filter(Boolean);
  if(!lines.length) return { ok:true };

  for(const line of lines){
    // ASCII only (BWF CodingHistory is specified as 7-bit ASCII)
    if(/[^\x20-\x7E]/.test(line)){
      return { ok:false, msg:"ASCII以外の文字が含まれています（全角や記号など）" };
    }
    const req = ["A=","F=","W=","M=","T="];
    for(const r of req){
      if(!line.includes(r)) return { ok:false, msg:`必須キー ${r} が見つかりません` };
    }
    if(!/F=\d+/.test(line)) return { ok:false, msg:"F= の数値が不正です" };
    if(!/W=\d+/.test(line)) return { ok:false, msg:"W= の数値が不正です" };
  }
  return { ok:true };
}

function buildBextChunk(){
  // Policy:
  // - If source WAV has bext and the textarea is empty -> preserve source bext as-is
  // - If source WAV has bext and textarea has text -> update *CodingHistory* only, keep other fields
  // - If no source bext -> create minimal BEXT v1 (602 bytes) + optional CodingHistory
  const ta = $("bextArea");
  const chText = ta ? (ta.value||"").trim() : "";

  if(chText){
    const v = bextValidateCodingHistoryStrict(chText);
    if(!v.ok){
      try{ safeToast(`BEXT(CodingHistory)形式が不正です: ${v.msg}`,"ng"); }catch(_){ }
      const err = new Error("BEXT_VALIDATION");
      err._bextValidation = true;
      throw err;
    }
  }

  try{
    if(state && state.srcBextPayload){
      const src = new Uint8Array(state.srcBextPayload);
      if(!chText){
        return buildChunkFromPayload("bext", src);
      }
      const updated = bextBuildPayloadV1FromBase(src, chText);
      return buildChunkFromPayload("bext", updated);
    }
    // no source bext
    const created = bextBuildPayloadV1FromBase(null, chText);
    return buildChunkFromPayload("bext", created);
  }catch(err){
    if(err && err._bextValidation) throw err;
    // last resort: do not block export
    const created = bextBuildPayloadV1FromBase(null, chText);
    return buildChunkFromPayload("bext", created);
  }
}


function buildIXmlChunk(){
  // iXML is not user-editable in this tool.
  // It is preserved as-is from the source WAV (pass-through) via chunk-level rebuild.
  return null;
}

function encodeWavPCM16WithCues(buffer, cues){
  const nCh = Math.min(2, buffer.numberOfChannels||1);
  const sr = buffer.sampleRate;
  const len = buffer.length;
  const bytesPerSample = 2;
  const blockAlign = nCh*bytesPerSample;
  const dataSize = len*blockAlign;

  // fmt
  const fmtDataSize = 16;
  const fmtChunkSize = 8 + fmtDataSize;
  const fmtBuf = new ArrayBuffer(_pad2(fmtChunkSize));
  const fmtDv = new DataView(fmtBuf);
  let f=0;
  f = _writeStr(fmtDv,f,"fmt ");
  f = _writeU32(fmtDv,f,fmtDataSize);
  f = _writeU16(fmtDv,f,1);
  f = _writeU16(fmtDv,f,nCh);
  f = _writeU32(fmtDv,f,sr);
  f = _writeU32(fmtDv,f,sr*blockAlign);
  f = _writeU16(fmtDv,f,blockAlign);
  f = _writeU16(fmtDv,f,16);

  // optional
  const bextBuf = buildBextChunk();
  const ixmlBuf = buildIXmlChunk();
  const cmcdBuf = buildCmcdChunkFixed2048();
  const {cueChunk, listChunk, plstChunk} = buildCueChunks(buffer, cues);

  // data header
  const dataHdr = new ArrayBuffer(8);
  const dataDv = new DataView(dataHdr);
  let d=0;
  d = _writeStr(dataDv,d,"data");
  d = _writeU32(dataDv,d,dataSize);

  // audio payload
  const audioBuf = new ArrayBuffer(_pad2(dataSize));
  const audioDv = new DataView(audioBuf);
  const ch0 = buffer.getChannelData(0);
  const ch1 = nCh>1 ? buffer.getChannelData(1) : ch0;
  const clamp16 = (x)=> Math.max(-1, Math.min(1, x));
  let p=0;
  for(let i=0;i<len;i++){
    p = _writeI16(audioDv,p, Math.round(clamp16(ch0[i])*32767));
    if(nCh>1) p = _writeI16(audioDv,p, Math.round(clamp16(ch1[i])*32767));
  }

  const parts = [
    ...(bextBuf?[bextBuf]:[]),
    fmtBuf,
    ...(ixmlBuf?[ixmlBuf]:[]),
    dataHdr,
    audioBuf,
    ...(cmcdBuf?[cmcdBuf]:[]),
    ...(cueChunk?[cueChunk]:[]),
    ...(plstChunk?[plstChunk]:[]),
    ...(listChunk?[listChunk]:[])
  ];

  let riffPayload = 4; // "WAVE"
  for(const part of parts) riffPayload += part.byteLength;

  const header = new ArrayBuffer(12);
  const hdv = new DataView(header);
  let h=0;
  h = _writeStr(hdv,h,"RIFF");
  h = _writeU32(hdv,h, riffPayload);
  h = _writeStr(hdv,h,"WAVE");

  return new Blob([header, ...parts], {type:"audio/wav"});
}


function exportStrategySummary(){
  const hasAttach = Array.isArray(state.attachments) && state.attachments.some(a=>a && a.bytes && a.bytes.length);
  const sigNow = cueSig(state.cues);
  const canInPlaceMove =
    !hasAttach &&
    !!state.srcAb &&
    !!state.cuePatchMeta &&
    !!state.loadedCueSig &&
    (sigNow === state.loadedCueSig);

  const reasons = [];
  if(hasAttach) reasons.push("添付あり");
  if(!state.srcAb) reasons.push("元バッファなし");
  if(!state.cuePatchMeta) reasons.push("in-place用メタ不足");
  if(!state.loadedCueSig) reasons.push("ロード署名なし");
  if(state.loadedCueSig && sigNow !== state.loadedCueSig) reasons.push("CUE編集あり（追加/削除/ラベル/順序など）");

  const chunksOk = Array.isArray(state.srcChunks) && state.srcChunks.length;
  const unknownCount = (()=>{ 
    try{
      const chunks = state.srcChunks;
      if(!Array.isArray(chunks)) return null;
      const known = new Set(["bext","fmt ","data","iXML","cmcd","cue ","plst","LIST:adtl"]);
      return chunks.filter(ch=>{
        const k = (ch.id==="LIST") ? `LIST:${ch.listType||""}` : ch.id;
        return !known.has(k);
      }).length;
    }catch(_){ return null; }
  })();

  return {
    method: canInPlaceMove ? "in-place patch（最小更新）" : "完全再構築（cue/LIST再生成）",
    canInPlaceMove,
    reasons: (canInPlaceMove ? [] : reasons),
    chunksOk: !!chunksOk,
    unknownCount
  };
}
function logExportPreflight(){
  const s = exportStrategySummary();
  log(`INFO: 書き出し方式: ${s.method}`);
  if(!s.canInPlaceMove && s.reasons && s.reasons.length){
    log(`INFO: 切替理由: ${s.reasons.join(" / ")}`);
  }
  if(s.chunksOk){
    if(s.unknownCount!=null){
      log(`INFO: 未知チャンク: ${s.unknownCount}件 → 書き出しで保持: YES（パススルー）`);
    }else{
      log("INFO: 未知チャンク → 書き出しで保持: YES（パススルー）");
    }
  }else{
    log("WARN: チャンク解析が不完全 → 未知チャンク保持が保証できません（フォールバック再構築の可能性）");
  }
}
function getProg(){
  const p = (typeof window !== "undefined") ? window._prog : null;
  if(p && typeof p.show==="function" && typeof p.hide==="function" && typeof p.set==="function") return p;
  return {
    show(){}, hide(){}, set(){}, yield: async()=>{},
    setText(){}, setLabel(){}, setSub(){}, setDetail(){}
  };
}
async function buildExportWavBytes(opts){
  const targetFileId = opts?.fileId;
  if(targetFileId && typeof setActiveFile === "function" && state.activeFileId !== targetFileId){
    await setActiveFile(targetFileId, { force:true });
  }
  if(!state.buffer || !state.srcFmtPayload || !state.srcDataPayload){
    throw _exportMakeError("書き出し前提データがありません", true);
  }
  const fmtNorm = normalizePcmFmtPayload(state.srcFmtPayload);
  const fmtPayload = fmtNorm.payload;
  const fmt16Normalized = fmtNorm.normalized ? 1 : 0;
// --- build replacements (editable chunks only) ---
  const bextBuf = buildBextChunk();                        // bext (version preserved)
  const cmcdBuf = buildCmcdChunkFixed2048();               // cmcd (fixed 2048)

  // cue / plst / LIST(adtl) (ファイル添付は LIST/adtl/file)
  // Hybrid: when ONLY moving existing cues (no add/remove/label change, no attachment),
  // patch the source 'cue ' chunk values in-place. Otherwise rebuild cue/LIST as before.
  let srcAbForBuild = state.srcAb;
  let cueChunk = null, listChunk = null, plstChunk = null;

  const hasAttach = Array.isArray(state.attachments) && state.attachments.some(a=>a && a.bytes && a.bytes.length);
  const sigNow = cueSig(state.cues);
  const canInPlaceMove =
    !hasAttach &&
    !!state.srcAb &&
    !!state.cuePatchMeta &&
    !!state.loadedCueSig &&
    (sigNow === state.loadedCueSig);

  if(canInPlaceMove){
    // Patch the existing 'cue ' chunk(s) sample offsets (no size/order changes)
    srcAbForBuild = applyCueInPlacePatch(state.srcAb, state.cuePatchMeta, state.cues, ((state.fileSr && isFinite(state.fileSr)) ? state.fileSr : state.buffer.sampleRate));
    cueChunk = null;
    listChunk = null;
    // plst は規格互換のため再生成（BC$NOTE除外 / 全BC$）
    try{ plstChunk = buildCueChunks(state.buffer, state.cues).plstChunk; }catch(_){ plstChunk = null; }
    log("INFO: CUEは元チャンクを更新（移動のみ / ハイブリッド）");
    if(plstChunk) log("INFO: plstを再生成（BC$NOTE除外 / 全BC$）");
  }else{
    const built = buildCueChunks(state.buffer, state.cues);
    cueChunk = built.cueChunk;
    listChunk = built.listChunk;
    plstChunk = built.plstChunk;
  }

  // data: only replace when auto-level fix was applied (PCM bytes are still PCM16)
  const dataBuf = (state.procApplied && state.procDataPayload)
    ? _makeChunk("data", state.procDataPayload)
    : null;

  const replacements = {
    bextBuf: (bextBuf instanceof Uint8Array) ? bextBuf : new Uint8Array(bextBuf),
    cmcdBuf: (cmcdBuf instanceof Uint8Array) ? cmcdBuf : new Uint8Array(cmcdBuf),
    cueBuf:  cueChunk ? ((cueChunk instanceof Uint8Array) ? cueChunk : new Uint8Array(cueChunk)) : null,
    plstBuf: plstChunk ? ((plstChunk instanceof Uint8Array) ? plstChunk : new Uint8Array(plstChunk)) : null,
    listBuf: listChunk ? ((listChunk instanceof Uint8Array) ? listChunk : new Uint8Array(listChunk)) : null,
    dataBuf: dataBuf, // Uint8Array from _makeChunk, or null
    fmtBuf:  fmtNorm.normalized ? _makeChunk("fmt ", fmtPayload) : null, // normalize PCM fmt=16 when cbSize=0
  };;

  try{
    console.log(`[EXPORT][layout] order=data>cmcd>cue>plst>adtl(labl-first,file-last) fmt16=${fmt16Normalized}`);
  }catch(_){ }

  // --- chunk-level rebuild (pass-through iXML + unknown chunks) ---
  let blob = null;
  const chunks = state.srcChunks || parseRiffChunks(state.srcAb);
  if(state.srcAb && chunks && Array.isArray(chunks) && chunks.length){
    blob = rebuildWaveFromOriginal(srcAbForBuild || state.srcAb, chunks, replacements);
  }else{
    // Fallback: canonical rebuild (rare). This may drop unknown chunks, so keep as last resort.
    log("WARN: チャンク解析に失敗したため、互換性保持が一部制限される可能性があります。");
    const fmtBuf  = _makeChunk("fmt ", fmtPayload);
    const pcmPayload = (state.procApplied && state.procDataPayload) ? state.procDataPayload : state.srcDataPayload;
    const dataBuf2 = _makeChunk("data", pcmPayload);
    const parts = [
      new Uint8Array(bextBuf),
      fmtBuf,
      dataBuf2,
      new Uint8Array(cmcdBuf),
      new Uint8Array(cueChunk),
      ...(plstChunk ? [new Uint8Array(plstChunk)] : []),
      new Uint8Array(listChunk),
    ];
    const outAb = _buildCanonicalWavFromParts(parts);
    blob = new Blob([outAb], {type:"audio/wav"});
  }
  const outAb = await blob.arrayBuffer();
  return new Uint8Array(outAb);
}
function buildExportReportJson(params){
  const saveRes = params?.saveRes || null;
  const suggested = params?.suggestedName || "output.wav";
  const verifyOk = params?.verifyOk ?? true;
  const verifyNotes = params?.verifyNotes || [];
  const verifyDiffLines = params?.verifyDiffLines || [];
  const exportBytes = params?.exportBytes || new Uint8Array();

  const lines = [];
  lines.push("WavCue Export Report");
  lines.push(`Date: ${new Date().toString()}`);
  lines.push(`Source: ${String(state.fileName||"")}`);
  const _outMode = String(saveRes?.mode||"");
  let _outName = "";
  if(_outMode === "ipc"){
    _outName = String(_baseNameFromPath(saveRes?.filePath) || saveRes?.suggested || suggested || "");
  }else{
    _outName = String(saveRes?.suggested || suggested || "");
  }
  if(_outName){
    lines.push(`Output: ${_outName} (${_outMode})`);
  }else{
    lines.push(`Output: — (${_outMode})`);
  }
  lines.push("Backup: export.wav (auto)");
  try{
    const norm=(s)=> String(s||"").trim().replace(/\s+/g,"").toUpperCase();
    const bcCount = (Array.isArray(state.cues)?state.cues:[]).filter(c=>{
      const t = norm(c && c.label);
      return t.startsWith("BC$") && !t.startsWith("BC$NOTE");
    }).length;
    lines.push(`plst: ${bcCount} segments (BC$NOTE excluded)`);
  }catch(_){ }

  lines.push("");
  lines.push("Change Summary (Original -> Current)");
  const diffs = (state._diff && state._diff.diffs) ? state._diff.diffs : diffSnapshots(state.originalSnapshot, takeSnapshot());
  diffs.forEach(d=> lines.push(`- [${d.sec}] ${d.item}: ${d.from} -> ${d.to}`));
  lines.push("");
  lines.push(`Self-Verify: ${verifyOk ? "PASS" : "FAIL"}`);
  verifyNotes.forEach(n=> lines.push(`- ${n}`));
  if(verifyDiffLines.length){
    lines.push("");
    verifyDiffLines.forEach(l=> lines.push(l));
  }
  try{
    const qc = (typeof getLastQcForCurrentFile === "function") ? getLastQcForCurrentFile() : (window.__wavcueLastQc?.result || null);
    const qcHas = !!qc;
    const ex = (typeof extractQcNgItems === "function") ? extractQcNgItems(qc) : { items: (qc?.items||[]), ng: (qc?.items||[]).filter(x=>x && x.ok===false) };
    const qcItems = Array.isArray(ex.items) ? ex.items : [];
    const qcNg = Array.isArray(ex.ng) ? ex.ng : [];
    const qcStatus = !qcHas ? "UNKNOWN" : (qcNg.length>0 ? "NG" : "OK");

    const qcPresetId = (qc && qc.presetId) ? String(qc.presetId) : String(state.qcPresetId || "");
    const qcPreset = (typeof _scGetPresetById === "function") ? _scGetPresetById(qcPresetId) : null;
    const qcPresetName = qcPreset ? String(qcPreset.name || "（無名）") : "（不明）";

    lines.push("");
    lines.push("QC (規格チェック)");
    lines.push(`- Result: ${qcStatus}`);
    lines.push(`- Preset: ${qcPresetName}${qcPresetId ? ` (id: ${qcPresetId})` : ""}`);

    if(qcPreset){
      const sr = Array.isArray(qcPreset.allowedSampleRates) && qcPreset.allowedSampleRates.length ? qcPreset.allowedSampleRates.join(",") : "制限なし";
      const bd = Array.isArray(qcPreset.allowedBits) && qcPreset.allowedBits.length ? qcPreset.allowedBits.join(",") : "制限なし";
      const ch = Array.isArray(qcPreset.allowedChannels) && qcPreset.allowedChannels.length ? qcPreset.allowedChannels.join(",") : "制限なし";
      lines.push(`- Target LUFS: ${qcPreset.targetLufs} ±${qcPreset.tolLufs} LU`);
      lines.push(`- TruePeak Max: ${qcPreset.maxTruePeakDb} dBTP`);
      lines.push(`- SampleRate: ${sr}`);
      lines.push(`- BitDepth: ${bd}`);
      lines.push(`- Channels: ${ch}`);
      if(Number.isFinite(qcPreset.silenceMinSec) || Number.isFinite(qcPreset.silenceMaxSec)){
        const a = Number.isFinite(qcPreset.silenceMinSec) ? qcPreset.silenceMinSec : 0;
        const b = Number.isFinite(qcPreset.silenceMaxSec) ? qcPreset.silenceMaxSec : 0;
        lines.push(`- Silence Allowance: ${a}〜${b} sec (前/後それぞれ)`);
      }
    }

    if(qcItems.length){
      lines.push("- Items:");
      qcItems.forEach(it=>{
        const label = String(it?.label || it?.name || it?.key || "項目");
        const ok = !(it && (it.ok===false || it.status==="ng" || it.pass===false));
        const reason = (it && (it.reason || it.message || it.detail)) ? String(it.reason || it.message || it.detail) : "";
        lines.push(`  - ${label}: ${ok ? "OK" : "NG"}${reason ? ` / ${reason}` : ""}`);
      });
    }else{
      lines.push("- Items: （詳細なし）");
    }
  }catch(e){
    try{ lines.push(""); lines.push("QC (規格チェック)"); lines.push(`- WARN: report追記に失敗: ${e?.name||"Error"} ${e?.message||""}`); }catch(_){ }
  }

  try{
    lines.push("");
    lines.push("CMCD");
    const cmcdApplied = !!state.cmcdBytes;
    const cmcdPresetId = String(state.cmcdPresetId || "");
    const cmcdPreset = (cmcdPresetId && typeof _cmcdGetPresetById === "function") ? _cmcdGetPresetById(cmcdPresetId) : null;
    const cmcdPresetName = cmcdPreset ? String(cmcdPreset.name || "（無名）") : (cmcdApplied ? "（手入力/未指定）" : "未適用");

    lines.push(`- Applied: ${cmcdApplied ? "YES" : "NO"}`);
    lines.push(`- Preset: ${cmcdPresetName}${cmcdPresetId ? ` (id: ${cmcdPresetId})` : ""}`);
  }catch(e){
    try{ lines.push(""); lines.push("CMCD"); lines.push(`- WARN: report追記に失敗: ${e?.name||"Error"} ${e?.message||""}`); }catch(_){ }
  }
  lines.push("");
  lines.push("Log (tail)");
  const logTxt = getLogText();
  const logLines = String(logTxt||"").split("\n");
  lines.push(logLines.slice(Math.max(0, logLines.length-200)).join("\n"));

  const reportText = lines.join("\n");
  const exportBase64 = _base64FromUint8(exportBytes instanceof Uint8Array ? exportBytes : new Uint8Array(exportBytes));
  const sourceFile = state.file;
  const sourceSizeBytes = Number.isFinite(sourceFile?.size) ? sourceFile.size : null;
  const sourceMtime = (typeof sourceFile?.lastModified === "number")
    ? new Date(sourceFile.lastModified).toISOString()
    : null;
  const overallEl = $("sc_overall");
  const overallText = String(overallEl?.textContent || "");
  const qcResult = !state.qcHasRun
    ? "UNKNOWN"
    : (overallText.includes("NG") ? "NG" : (overallText.includes("OK") ? "OK" : "UNKNOWN"));
  const exportBaseName = (() => {
    try{
      const p = String(saveRes?.filePath || "");
      if(!p) return "";
      const name = p.split(/[\\/]/).pop() || "";
      return name.replace(/\.[^.]+$/, "");
    }catch(_){ return ""; }
  })();

  return {
    reportText,
    exportBase64,
    exportBaseName,
    exportFileName: _outName,
    sourceFileName: String(state.fileName || ""),
    sourceSizeBytes,
    sourceMtime,
    exportSampleRate: Number.isFinite(state.buffer?.sampleRate) ? state.buffer.sampleRate : null,
    exportChannels: Number.isFinite(state.buffer?.numberOfChannels) ? state.buffer.numberOfChannels : null,
    qcResult,
    qcNotes: overallEl?.title ? String(overallEl.title) : null,
    qcPresetId: (typeof getLastQcForCurrentFile==="function" && getLastQcForCurrentFile()?.presetId)
      ? String(getLastQcForCurrentFile().presetId)
      : String(state.qcPresetId || ""),
    qcPresetName: (()=>{ try{
      const id = (typeof getLastQcForCurrentFile==="function" && getLastQcForCurrentFile()?.presetId) ? String(getLastQcForCurrentFile().presetId) : String(state.qcPresetId || "");
      const p = (typeof _scGetPresetById==="function") ? _scGetPresetById(id) : null;
      return p ? String(p.name || "（無名）") : null;
    }catch(_){ return null; } })(),
    qcDetail: (typeof getLastQcForCurrentFile==="function") ? (getLastQcForCurrentFile() || null) : (window.__wavcueLastQc?.result || null),

    cmcdApplied: !!state.cmcdBytes,
    cmcdPresetId: String(state.cmcdPresetId || ""),
    cmcdPresetName: (()=>{ try{
      const id = String(state.cmcdPresetId || "");
      const p = (id && typeof _cmcdGetPresetById==="function") ? _cmcdGetPresetById(id) : null;
      return p ? String(p.name || "（無名）") : null;
    }catch(_){ return null; } })(),
    appVersion: (typeof APP_VERSION === "string") ? APP_VERSION : null,
  };
}
function _exportMakeError(message, silent){
  const err = new Error(message);
  if(silent) err.silent = true;
  return err;
}
async function _exportOneWithSaveImpl(options){
  const saveHandler = options?.saveHandler;
  const progressEnabled = options?.progressEnabled !== false;
  const notifyOnError = options?.notifyOnError !== false;
  if(typeof saveHandler !== "function"){
    return { ok:false, error: _exportMakeError("saveHandler is unavailable.", false) };
  }
  if(!state.buffer || !state.srcFmtPayload || !state.srcDataPayload){
    log("WARN: 先にWAVを読み込んでください。（読み込み直後に書き出し可能です）");
    return { ok:false, error: _exportMakeError("書き出し前提データがありません", true) };
  }
  let __exportOK = false;
  try{
    log("INFO: 書き出し開始");
    try{ logExportPreflight(); }catch(_){ }

    const __cues = Array.isArray(state.cues) ? state.cues : [];
    if(__cues.length > 99){
      window.safeToast && window.safeToast("CUEは最大99件です（規格）","ng");
      log(`WARN: CUE数が上限（99）を超えています: ${__cues.length}件`);
      return { ok:false, error: _exportMakeError("CUE数が規格上限を超えています", true) };
    }
    try{
      const norm = (s)=> String(s||"").trim().replace(/\s+/g, "").toUpperCase();
      const notes = __cues.map(c=> norm(c && c.label)).filter(t=> /^BC\$NOTE\d+$/.test(t));
      const seen = new Set();
      const dups = [];
      for(const t of notes){ if(seen.has(t)) dups.push(t); else seen.add(t); }
      if(dups.length){
        window.safeToast && window.safeToast("NOTEラベルが重複しています（規格）","ng");
        log(`WARN: NOTEラベル重複: ${Array.from(new Set(dups)).join(", ")}`);
        return { ok:false, error: _exportMakeError("NOTEラベルが重複しています", true) };
      }
    }catch(_){ }

    try{
      const pcm = detectPcmFromFmtPayload(state.srcFmtPayload);
      if(!pcm.ok){
        window.safeToast && window.safeToast("非PCM形式は現在未対応です","ng");
        log(`WARN: 非PCM/未対応: ${pcm.reason}`);
        return { ok:false, error: _exportMakeError("非PCM形式は未対応です", true) };
      }
    }catch(_){ }

    try{
      const bad = [];
      for(const c of __cues){
        const s = (c && c.label != null) ? String(c.label) : "";
        if(!s) continue;
        const enc = cp932EncodeEx(s + "\\0");
        if(enc && enc.hadReplace){
          bad.push(s);
          if(bad.length >= 3) break;
        }
      }
      if(bad.length){
        window.safeToast && window.safeToast("ラベルにShift-JIS非対応文字が含まれます（書き出し不可）","ng");
        log(`WARN: ラベルShift-JIS非対応: ${bad.slice(0,2).join(" / ")}${bad.length>2?" ...":""}`);
        return { ok:false, error: _exportMakeError("ラベルにShift-JIS非対応文字が含まれます", true) };
      }
    }catch(err){
      window.safeToast && window.safeToast("ラベル文字の検査に失敗しました（書き出し不可）","ng");
      log(`WARN: ラベル検査失敗: ${String(err&&err.message||err)}`);
      return { ok:false, error: _exportMakeError("ラベル検査に失敗しました", true) };
    }

    let __exportBarShown = false;
    const __ensureExportBar = (sub)=>{
      if(!progressEnabled) return;
      if(__exportBarShown) return;
      getProg().show("書き出し中…", sub || "書き込み中…");
      __exportBarShown = true;
    };

    let autoBackupEnabled = true;
    let autoCleanupEnabled = true;
    let autoCleanupOnExport = true;
    try{
      const settings = await window.wavcue?.getSettings?.();
      autoBackupEnabled = settings?.autoBackupEnabled ?? true;
      autoCleanupEnabled = settings?.autoCleanup ?? true;
      autoCleanupOnExport = settings?.autoCleanup ?? true;
    }catch(_){ }
    const backupGate = guardBackup({ source: "export" });
    if(!backupGate.ok){
      autoBackupEnabled = false;
      autoCleanupEnabled = false;
      autoCleanupOnExport = false;
    }
    try{ scheduleDiffUpdate(true); }catch(_){ }

    const fallbackName = (state.fileName && String(state.fileName).trim()) ? String(state.fileName).trim() : "output.wav";
    const suggested = (options?.suggestedName && String(options.suggestedName).trim())
      ? String(options.suggestedName).trim()
      : fallbackName;
    const base = _baseNameNoExt(fallbackName || suggested || "output.wav");
    const backupBase = _sanitizeFileSegment(base);
// --- build replacements (editable chunks only) ---
    if(progressEnabled) getProg().set(0.18, "書き出し中…", "チャンク生成中");
    const exportBytes = await buildExportWavBytes({ fileId: options?.fileId });
    const blob = new Blob([exportBytes], {type:"audio/wav"});

    const _saveRes = await saveHandler(blob, suggested, (phase)=>{
      try{
        if(!progressEnabled) return;
        if(phase==="picker_open"){
          if(__exportBarShown){ getProg().hide(); __exportBarShown = false; }
        }else if(phase==="picked"){
          __ensureExportBar("書き込み準備…");
          getProg().set(0.86, "書き出し中…", "保存先確定…");
        }else if(phase==="writing"){
          __ensureExportBar("書き込み中…");
          getProg().set(0.92, "書き出し中…", "書き込み中…");
        }else if(phase==="download_start"){
          __ensureExportBar("ダウンロード開始…");
          getProg().set(0.90, "書き出し中…", "ダウンロード開始…");
        }else if(phase==="done"){
          if(__exportBarShown) getProg().set(0.96, "書き出し中…", "保存後処理…");
        }else if(phase==="cancel"){
          if(__exportBarShown){ getProg().hide(); __exportBarShown = false; }
        }
      }catch(_){ }
    });
    if(_saveRes && _saveRes.mode === "cancel"){
      log("INFO: 書き出しをキャンセルしました。");
      return { ok:false, canceled:true };
    }

    let verifyOk = true;
    const verifyNotes = [];
    const verifyDiffLines = [];
    try{
      const outAb = await blob.arrayBuffer();
      const oChunks = parseRiffChunks(state.srcAb) || [];
      const nChunks = parseRiffChunks(outAb) || [];
      const keepKeys = new Set(["bext","fmt ","data","cmcd","cue ","plst","LIST:adtl","iXML"]);
      const keyOf = (c)=> (c.id==="LIST" && c.listType) ? `LIST:${c.listType}` : c.id;
      const want = oChunks
        .map(c=>({k:keyOf(c), s:(c.size>>>0)}))
        .filter(x=>!keepKeys.has(x.k))
        .map(x=>`${x.k}:${x.s}`)
        .sort();
      const got = nChunks
        .map(c=>({k:keyOf(c), s:(c.size>>>0)}))
        .filter(x=>!keepKeys.has(x.k))
        .map(x=>`${x.k}:${x.s}`)
        .sort();
      if(want.join("|") !== got.join("|")){
        verifyOk = false;
        verifyNotes.push("未知/透過チャンクの保持が一致しません（件数/サイズ差分）。");
        try{
          const toCounts = (arr)=>{
            const m = new Map();
            for(const s of arr){ m.set(s, (m.get(s)||0) + 1); }
            return m;
          };
          const cw = toCounts(want);
          const cg = toCounts(got);
          const keys = new Set([...cw.keys(), ...cg.keys()]);
          const missing = [];
          const extra = [];
          for(const k of keys){
            const a = cw.get(k)||0;
            const b = cg.get(k)||0;
            if(a>b) missing.push([k, a-b]);
            else if(b>a) extra.push([k, b-a]);
          }
          const fmt = (k,n)=> n>1 ? `${k} (x${n})` : k;
          const byKey = (arr)=> arr.sort((p,q)=> (p[0]<q[0]?-1:p[0]>q[0]?1:0));
          byKey(missing); byKey(extra);
          if(missing.length || extra.length){
            verifyDiffLines.push("Self-Verify Differences (Unknown/Pass-through):");
            const LIM = 40;
            missing.slice(0,LIM).forEach(([k,n])=> verifyDiffLines.push(`- Missing: ${fmt(k,n)}`));
            if(missing.length > LIM) verifyDiffLines.push(`- Missing: ... (${missing.length - LIM} more)`);
            extra.slice(0,LIM).forEach(([k,n])=> verifyDiffLines.push(`- Extra: ${fmt(k,n)}`));
            if(extra.length > LIM) verifyDiffLines.push(`- Extra: ... (${extra.length - LIM} more)`);
          }
        }catch(_e){ }
      }
      const hadIXml = !!state.srcIXmlPayload;
      const hasIXmlOut = !!_riffExtractChunkPayload(outAb, "iXML");
      if(hadIXml && !hasIXmlOut){
        verifyOk = false;
        verifyNotes.push("iXMLが出力から欠落しています。");
      }
    }catch(e){
      verifyOk = false;
      verifyNotes.push("自己検証で例外が発生しました。");
    }

    if(autoBackupEnabled){
      try{
        const report = buildExportReportJson({
          saveRes: _saveRes,
          suggestedName: suggested,
          verifyOk,
          verifyNotes,
          verifyDiffLines,
          exportBytes,
        });
        const backupRes = await window.wavcue?.saveBackupReport?.({
          sourceBaseName: backupBase,
          backupNameHint: report.exportBaseName,
          exportDataBase64: report.exportBase64,
          reportText: report.reportText,
          sourceFileName: report.sourceFileName,
          sourceSizeBytes: report.sourceSizeBytes,
          sourceMtime: report.sourceMtime,
          exportFileName: report.exportFileName,
          exportSampleRate: report.exportSampleRate,
          exportChannels: report.exportChannels,
          qcResult: report.qcResult,
          qcNotes: report.qcNotes,
          qcPresetId: report.qcPresetId,
          qcPresetName: report.qcPresetName,
          qcDetail: report.qcDetail,
          cmcdApplied: report.cmcdApplied,
          cmcdPresetId: report.cmcdPresetId,
          cmcdPresetName: report.cmcdPresetName,
          appVersion: report.appVersion,
        });
        if(backupRes?.ok){
          log(`OK: バックアップを保存しました: ${backupRes?.jobFolderName || "job folder"}`);
          log("OK: レポートを書き出しました: report.txt");
        }else{
          log(`WARN: バックアップ保存に失敗: ${backupRes?.error || "unknown error"}`);
        }
      }catch(e){
        log(`WARN: バックアップ/レポート生成に失敗: ${e?.name||"Error"} ${e?.message||""}`);
      }
    }

    if(autoCleanupEnabled && autoCleanupOnExport){
      try{
        const cleanupResult = await window.wavcue?.runCleanupNow?.();
        if(cleanupResult?.ok){
          settingsLogAdd(`書き出し後のクリーンアップ: ${cleanupResult.summary.deletedCount}件削除 / ${formatBytes(cleanupResult.summary.deletedBytes)} 解放。`);
        }else if(cleanupResult){
          settingsLogAdd(`書き出し後のクリーンアップがエラーで終了しました（エラー ${cleanupResult.summary?.errorCount ?? "不明"}件）。`);
          window.safeToast && window.safeToast("自動クリーンアップがエラーで終了しました", "warn", 3600);
        }
      }catch(_){ }
    }

    __exportOK = true;
    let demoRemainingExportsAfter = null;
    try{ window.WavCueLicense?.recordExportOk?.(); }catch(_){}
    try{
      const stAfter = window.WavCueLicense?.getStateSafe?.();
      const remaining = stAfter?.demo?.remainingExports;
      if(stAfter?.tier === "demo" && Number.isFinite(remaining)){
        demoRemainingExportsAfter = remaining;
      }
      if(stAfter) applyLicenseUi(stAfter);
    }catch(_){}
    if(demoRemainingExportsAfter != null){
      log(`OK: 書き出しが完了しました（残り：${demoRemainingExportsAfter}回）`);
    }else{
      log("OK: 書き出し完了");
    }
    return { ok:true, save:_saveRes };
  }catch(e){
    log(`ERROR: Export failed: ${e?.name||"Error"} ${e?.message||""}`);
    if(e?.stack) log(String(e.stack).slice(0, 4000));
    if(notifyOnError && !(e && e.name==="AbortError") && !e?.silent){
      alert("書き出しに失敗しました。ログをご確認ください。");
    }
    return { ok:false, error:e };
  }finally{
    try{
      if(progressEnabled && __exportOK){
        getProg().set(1, "書き出し中…", "完了");
        await getProg().yield();
      }
    }catch(_){ }
    try{ if(progressEnabled) getProg().hide(); }catch(_){ }
  }
}

async function exportOneWithSave(options){
  const opts = options || {};
  if(!opts.saveHandler){
    return _exportOneWithSaveImpl({
      ...opts,
      saveHandler: _saveBlobWithFallback,
      progressEnabled: opts.progressEnabled !== false,
      notifyOnError: opts.notifyOnError !== false,
    });
  }
  return _exportOneWithSaveImpl(opts);
}

async function exportWav(){
  const gate = guardExport({ source: "singleExport" });
  if(gate?.tier === "demo" && !_demoExportNoticeShown){
    _demoExportNoticeShown = true;
    if(window.safeToast) window.safeToast(LICENSE_TEXT.demoNotice, "info");
  }
  if(!gate.ok){
    if(window.safeToast){
      if(gate.reason === "standard-auth-expired") window.safeToast(LICENSE_TEXT.standardAuthToast, "warn");
      else if(gate.reason === "demo_export_limit") window.safeToast(LICENSE_TEXT.demoExportLimitToast, "warn");
      else if(gate.reason === "demo_expired") window.safeToast(LICENSE_TEXT.demoExpiredToast, "warn");
      else window.safeToast(LICENSE_TEXT.exportStandardRequired, "warn");
    }
    return;
  }
  const suggested = (state.fileName && String(state.fileName).trim()) ? String(state.fileName).trim() : "output.wav";
  await exportOneWithSave({
    saveHandler: _saveBlobWithFallback,
    suggestedName: suggested,
    progressEnabled: true,
    notifyOnError: true,
  });
}

function normalizeExportFileName(name){
  const raw = String(name || "").trim();
  const baseName = (raw ? raw.split(/[\\/]/).pop() : "") || "output.wav";
  const extMatch = baseName.match(/\.[^.]+$/);
  const ext = (extMatch && extMatch[0]) ? extMatch[0] : ".wav";
  const base = extMatch ? baseName.slice(0, -ext.length) : baseName;
  const safeBase = _sanitizeFileSegment(base || "output");
  const safeExt = ext || ".wav";
  return { base: safeBase, ext: safeExt };
}
async function writeBlobToIpcFolder(folderPath, name, blob){
  if(!window.wavcue?.writeFileBase64){
    throw new Error("writeFileBase64 is unavailable.");
  }
  const { base, ext } = normalizeExportFileName(name);
  const dataBase64 = _base64FromArrayBuffer(await blob.arrayBuffer());
  const MAX_TRIES = 1000;
  for(let i=0; i<MAX_TRIES; i++){
    const suffix = i === 0 ? "" : `_${i}`;
    const fileName = `${base}${suffix}${ext}`;
    const res = await window.wavcue.writeFileBase64({
      folderPath,
      fileName,
      dataBase64,
    });
    if(res?.ok){
      return { mode:"ipc", filePath: res.filePath || fileName, suggested: fileName };
    }
    if(res?.error && /EEXIST/i.test(res.error)){
      continue;
    }
    throw new Error(res?.error || "write failed");
  }
  throw new Error("同名ファイルが多すぎます");
}
async function exportOneToTarget(targetOrOpts, suggestedName){
  if(typeof targetOrOpts === "string"){
    return exportOneToTarget({ target: { kind:"ipc", folderPath: targetOrOpts }, suggestedName });
  }
  const opts = (targetOrOpts && targetOrOpts.target) ? targetOrOpts : null;
  let target = opts ? opts.target : targetOrOpts;
  const name = opts ? opts.suggestedName : suggestedName;
  const fileId = opts?.fileId;
  if(!target && opts?.folderPath){
    target = { kind:"ipc", folderPath: opts.folderPath };
  }
  const saveHandler = async (blob, nameArg, onPhase)=>{
    if(target?.kind === "ipc"){
      if(onPhase) onPhase("writing");
      return await writeBlobToIpcFolder(target.folderPath, nameArg, blob);
    }
    throw new Error("export target is unavailable");
  };
  const res = await _exportOneWithSaveImpl({
    saveHandler,
    suggestedName: name,
    progressEnabled: false,
    notifyOnError: false,
    fileId,
  });
  const savedName = res?.save?.suggested || res?.save?.filePath || name;
  return { ok: !!res?.ok, error: res?.error, save: res?.save, savedName };
}

const WavCueExportCore = {
  getProg,
  buildExportWavBytes,
  exportOneWithSave,
  exportOneToTarget: async (optsOrFolder, nameArg)=>{
    if(typeof optsOrFolder === "string"){
      return exportOneToTarget(optsOrFolder, nameArg);
    }
    return exportOneToTarget(optsOrFolder);
  },
};
window.WavCueExportCore = WavCueExportCore;
window.getProg = WavCueExportCore.getProg;
window.buildExportWavBytes = WavCueExportCore.buildExportWavBytes;
window.exportOneWithSave = WavCueExportCore.exportOneWithSave;
/* Buttons */
function updateButtons(){
if($("btnCmcd")) $("btnCmcd").disabled = !state.buffer;
  const loaded = !!state.buffer;
  const st = LicenseCore.peekState?.();
  const demoLocked = st?.tier === "demo" && !!st?.demo?.isLocked;
  const standardExportAllowed = st?.tier === "standard" ? !st?.standard?.auth?.isHardExpired : true;
  $("btnPlay").disabled = !loaded || state.isPlaying;
  $("btnPause").disabled = !loaded || !state.isPlaying;
  $("btnZoomIn").disabled = !loaded;
  $("btnZoomOut").disabled = !loaded;
  $("btnVZoomIn").disabled = !loaded;
  $("btnVZoomOut").disabled = !loaded;
  $("btnExport").disabled = !loaded || demoLocked || !standardExportAllowed;
  if($("btnStdCheck")) $("btnStdCheck").disabled = !loaded || demoLocked;
  $("btnAddCustom").disabled = !loaded || demoLocked;
  $("btnAddPair").disabled = !loaded || demoLocked;

  // BC$ quick add
  if($("selBcLabel")) $("selBcLabel").disabled = !loaded || demoLocked;
  if($("btnAddBcLabel")) $("btnAddBcLabel").disabled = !loaded || demoLocked || !($("selBcLabel").value);
}

$("btnBrowse").addEventListener("click", ()=> $("fileInput").click());
$("fileInput").addEventListener("change", async (e)=>{
  const files = e.target.files;
  if(!files || !files.length) return;
  const add = window.__wavcueProAddFiles;
  if(typeof add === "function"){
    await add(files);
  }else{
    await loadFile(files[0]);
  }
  e.target.value = "";
});

$("btnPlay").addEventListener("click", play);
$("btnPause").addEventListener("click", pause);

const winMinBtn = $("winMinBtn");
const winMaxBtn = $("winMaxBtn");
const winCloseBtn = $("winCloseBtn");

const updateWinMaxIcon = async ()=>{
  if(!winMaxBtn || !window.wavcue?.winIsMaximized) return;
  const isMax = await window.wavcue.winIsMaximized();
  winMaxBtn.textContent = isMax ? "❐" : "▢";
  winMaxBtn.setAttribute("aria-label", isMax ? "元に戻す" : "最大化");
};

if(winMinBtn){
  winMinBtn.addEventListener("click", ()=> window.wavcue?.winMinimize?.());
}
if(winMaxBtn){
  winMaxBtn.addEventListener("click", async ()=>{
    window.wavcue?.winToggleMaximize?.();
    setTimeout(updateWinMaxIcon, 120);
  });
}
if(winCloseBtn){
  winCloseBtn.addEventListener("click", ()=> window.wavcue?.winClose?.());
}
window.addEventListener("resize", ()=>{ updateWinMaxIcon(); });
updateWinMaxIcon();

const settingsButton = document.getElementById("btnSettings");
const settingsDialog = $("settingsDialog");
const settingsClose = $("settingsClose");
const settingsLog = $("settingsLog");
const settingsBackupStatus = $("settingsBackupStatus");
const settingsCleanupResult = $("settingsCleanupResult");
const settingsCleanupProgress = $("settingsCleanupProgress");
const settingsCleanupConfirm = $("settingsCleanupConfirm");
const settingsCleanupConfirmCancel = $("settingsCleanupConfirmCancel");
const settingsCleanupConfirmRun = $("settingsCleanupConfirmRun");
const settingsRetentionDays = $("settingsRetentionDays");
const settingsBackupQuotaGB = $("settingsBackupQuotaGB");
const settingsMinKeepCount = $("settingsMinKeepCount");
const settingsDeleteMethod = $("settingsDeleteMethod");
const settingsAutoCleanup = $("settingsAutoCleanup");
const settingsResetRecommended = $("settingsResetRecommended");
const settingsRulesBadge = $("settingsRulesBadge");
let cachedAutoBackupEnabled = true;

const RECOMMENDED_SETTINGS = {
  autoCleanup: true,
  retentionDays: 30,
  backupQuotaGB: 5,
  minKeepCount: 20,
  deleteMethod: "trash",
  schemaVersion: 2,
};

const updateRulesBadge = ()=>{
  if(!settingsRulesBadge) return;
  const retentionValue = Number(settingsRetentionDays?.value ?? 30);
  const quotaValue = Number(settingsBackupQuotaGB?.value ?? 5);
  const minKeepValue = Number(settingsMinKeepCount?.value ?? 20);
  const deleteValue = settingsDeleteMethod?.value ?? "trash";
  const isRecommended = retentionValue === 30
    && quotaValue === 5
    && minKeepValue === 20
    && deleteValue === "trash";
  settingsRulesBadge.classList.toggle("is-hidden", !isRecommended);
};

const settingsLogAdd = (message)=>{
  if(!settingsLog) return;
  const stamp = new Date().toLocaleTimeString();
  settingsLog.textContent = `[${stamp}] ${message}\n${settingsLog.textContent || ""}`.trim();
};

const formatBytes = (bytes)=>{
  if(!bytes) return "0 B";
  const units = ["B","KB","MB","GB","TB"];
  let value = bytes;
  let idx = 0;
  while(value >= 1024 && idx < units.length - 1){
    value /= 1024;
    idx += 1;
  }
  return `${value.toFixed(1)} ${units[idx]}`;
};

const updateCleanupResult = (result)=>{
  if(!settingsCleanupResult) return;
  if(!result || !result.timestamp){
    settingsCleanupResult.textContent = "クリーンアップ履歴: 未実行";
    return;
  }
  const when = new Date(result.timestamp).toLocaleString();
  settingsCleanupResult.textContent = `クリーンアップ履歴 (${when}): ${result.deletedCount}件削除 / ${formatBytes(result.deletedBytes)} 解放 / エラー ${result.errorCount}件`;
};

const setSelectValue = (selectEl, value, fallback)=>{
  if(!selectEl) return;
  const next = String(value);
  const hasOption = Array.from(selectEl.options).some((option)=> option.value === next);
  selectEl.value = hasOption ? next : String(fallback);
};

const refreshSettingsData = async ()=>{
  if(!window.wavcue?.getSettings) return;
  try{ await window.wavcue.ensureDefaultFolders?.(); }catch(_){}
  const settings = await window.wavcue.getSettings();
  console.log("[Settings] loaded settings:", settings);
  if(settingsLog && settingsLog.textContent.trim() === "準備完了"){
    settingsLog.textContent = "クリーンアップログはバックアップ内のreport.txtに保存されます。";
  }
  cachedAutoBackupEnabled = settings.autoBackupEnabled ?? cachedAutoBackupEnabled;
  setSelectValue(settingsRetentionDays, settings.retentionDays ?? 30, 30);
  setSelectValue(settingsBackupQuotaGB, settings.backupQuotaGB ?? 5, 5);
  setSelectValue(settingsMinKeepCount, settings.minKeepCount ?? 20, 20);
  if(settingsDeleteMethod) settingsDeleteMethod.value = settings.deleteMethod || "trash";
  if(settingsAutoCleanup) settingsAutoCleanup.checked = !!settings.autoCleanup;
  updateRulesBadge();
  updateCleanupResult(settings.cleanupLastResult);

  if(settingsBackupStatus && window.wavcue?.getBackupStatus){
    try{
      const status = await window.wavcue.getBackupStatus();
      const oldest = status?.oldest ? new Date(status.oldest).toLocaleString() : "—";
      const latest = status?.latest ? new Date(status.latest).toLocaleString() : "—";
      settingsBackupStatus.textContent = `バックアップ状況: ${status?.jobCount ?? 0}件 / ${formatBytes(status?.totalBytes || 0)} / 最古 ${oldest} / 最新 ${latest}`;
    }catch(_){
      settingsBackupStatus.textContent = "バックアップ状況: 取得できませんでした。";
    }
  }
};

const openSettingsDialog = async ()=>{
  if(!settingsDialog) return;
  await refreshSettingsData();
  try{ settingsDialog.showModal(); }catch(_){ settingsDialog.open = true; }
};

const openCleanupConfirm = ()=>{
  if(!settingsCleanupConfirm) return;
  try{ settingsCleanupConfirm.showModal(); }catch(_){ settingsCleanupConfirm.open = true; }
};

const closeCleanupConfirm = ()=>{
  if(!settingsCleanupConfirm) return;
  _dialogCloseWithGuard(settingsCleanupConfirm);
};

if(settingsButton){
  settingsButton.addEventListener("click", openSettingsDialog);
}
if(settingsClose && settingsDialog){
  settingsClose.addEventListener("click", ()=>{ _dialogCloseWithGuard(settingsDialog); });
}
settingsDialog?.addEventListener("click", (e)=>{ if(e.target === settingsDialog){ _dialogCloseWithGuard(settingsDialog); } });
if(settingsCleanupConfirmCancel){
  settingsCleanupConfirmCancel.addEventListener("click", closeCleanupConfirm);
}
settingsCleanupConfirm?.addEventListener("click", (e)=>{ if(e.target === settingsCleanupConfirm){ closeCleanupConfirm(); } });

[settingsRetentionDays, settingsBackupQuotaGB, settingsMinKeepCount, settingsDeleteMethod].forEach((select)=>{
  if(!select) return;
  select.addEventListener("change", updateRulesBadge);
});

document.querySelectorAll("[data-settings-folder]").forEach((button)=>{
  button.addEventListener("click", async ()=>{
    const kind = button.dataset.settingsFolder;
    if(!kind || !window.wavcue?.openFolder) return;
    const gate = guardBackup({ source: "settings:folder" });
    if(!gate.ok){
      if(window.safeToast) window.safeToast(LICENSE_TEXT.backupDemo, "warn");
      return;
    }
    const result = await window.wavcue.openFolder(kind);
    const labelMap = { backups: "バックアップ" };
    const label = labelMap[kind] || kind;
    if(result.ok){
      settingsLogAdd(`${label}フォルダを開きました。`);
    }else{
      settingsLogAdd(`${label}フォルダを開けませんでした。${result.message || "不明なエラー"}`);
    }
  });
});

$("settingsCleanupNow")?.addEventListener("click", async ()=>{
  if(!window.wavcue?.runCompleteCleanup) return;
  const gate = guardBackup({ source: "settings:cleanup" });
  if(!gate.ok){
    if(window.safeToast) window.safeToast(LICENSE_TEXT.backupDemo, "warn");
    return;
  }
  openCleanupConfirm();
});

window.wavcue?.onCleanupProgress?.((payload)=>{
  if(payload?.message && settingsCleanupProgress){
    settingsCleanupProgress.textContent = payload.message;
  }
});

settingsCleanupConfirmRun?.addEventListener("click", async ()=>{
  if(!window.wavcue?.runCompleteCleanup) return;
  const gate = guardBackup({ source: "settings:cleanup" });
  if(!gate.ok){
    if(window.safeToast) window.safeToast(LICENSE_TEXT.backupDemo, "warn");
    return;
  }
  closeCleanupConfirm();
  if(settingsCleanupProgress) settingsCleanupProgress.textContent = "完全クリーンアップを開始しています...";
  settingsLogAdd("完全クリーンアップを開始しました。");
  const result = await window.wavcue.runCompleteCleanup();
  if(result.ok){
    settingsLogAdd(`完全クリーンアップが完了しました。${result.summary.deletedCount}件削除 / ${formatBytes(result.summary.deletedBytes)} 解放 / エラー ${result.summary.errorCount}件。`);
    window.safeToast && window.safeToast(`完全クリーンアップを実行しました（${result.summary.deletedCount}件削除 / ${formatBytes(result.summary.deletedBytes)} 解放）`, "ok", 3200);
  }else{
    settingsLogAdd(`完全クリーンアップがエラーで終了しました。エラー ${result.summary?.errorCount ?? "不明"}件。`);
    window.safeToast && window.safeToast("完全クリーンアップがエラーで終了しました", "warn", 3600);
  }
  updateCleanupResult(result.summary);
  await refreshSettingsData();
});

settingsResetRecommended?.addEventListener("click", async ()=>{
  if(typeof window.wavcue?.setSettings !== "function") return;
  const gate = guardBackup({ source: "settings:reset" });
  if(!gate.ok){
    if(window.safeToast) window.safeToast(LICENSE_TEXT.backupDemo, "warn");
    return;
  }
  try{
    await window.wavcue.setSettings(RECOMMENDED_SETTINGS);
    await refreshSettingsData();
    settingsLogAdd("設定を推奨値に戻しました。");
    if(typeof toast === "function"){
      toast("設定を推奨値に戻しました", "ok", 2600);
    }else if(window.safeToast){
      window.safeToast("設定を推奨値に戻しました", "ok", 2600);
    }
  }catch(error){
    if(typeof toast === "function"){
      toast("設定の初期化に失敗しました", "err", 3200);
    }else if(window.safeToast){
      window.safeToast("設定の初期化に失敗しました", "err", 3200);
    }
    settingsLogAdd("設定の初期化に失敗しました。");
    console.error(error);
  }
});

async function onSaveSettingsClicked(){
  try{
    const gate = guardBackup({ source: "settings:save" });
    if(!gate.ok){
      if(window.safeToast) window.safeToast(LICENSE_TEXT.backupDemo, "warn");
      return;
    }
    const patch = {
      autoBackupEnabled: !!cachedAutoBackupEnabled,
      retentionDays: Number(settingsRetentionDays?.value || 30),
      backupQuotaGB: Number(settingsBackupQuotaGB?.value || 5),
      minKeepCount: Number(settingsMinKeepCount?.value || 20),
      deleteMethod: settingsDeleteMethod?.value || "trash",
      autoCleanup: !!settingsAutoCleanup?.checked,
      autoCleanupOnExport: !!settingsAutoCleanup?.checked,
      autoCleanupOnQuit: false,
      autoCleanupOnStartup: false,
    };
    console.log("[Settings] save clicked, patch:", patch);
    if(typeof window.wavcue?.setSettings !== "function"){
      throw new Error("settings:set unavailable");
    }
    const result = await window.wavcue.setSettings(patch);
    console.log("[Settings] setSettings resolved:", result);
    updateRulesBadge();
    settingsLogAdd("設定を保存しました。");
    if(typeof toast === "function"){
      toast("設定を保存しました", "ok", 2400);
    }else if(window.safeToast){
      window.safeToast("設定を保存しました", "ok", 2400);
    }
  }catch(error){
    if(typeof toast === "function"){
      toast("設定の保存に失敗しました", "err", 3200);
    }else if(window.safeToast){
      window.safeToast("設定の保存に失敗しました", "err", 3200);
    }
    settingsLogAdd("設定の保存に失敗しました。");
    console.error(error);
  }
}

$("settingsSave")?.addEventListener("click", onSaveSettingsClicked);

$("btnZoomIn").addEventListener("click", ()=>{
  if(!state.buffer) return;
  state.zoom = clamp(state.zoom*1.25, 1, 32);
  ensureVisibleSec(currentPlayheadSec());
  drawAll();
});
$("btnZoomOut").addEventListener("click", ()=>{
  if(!state.buffer) return;
  state.zoom = clamp(state.zoom/1.25, 1, 32);
  ensureVisibleSec(currentPlayheadSec());
  drawAll();
});
$("btnVZoomIn").addEventListener("click", ()=>{
  if(!state.buffer) return;
  state.vZoom = clamp(state.vZoom*1.25, 0.25, 10);
  drawAll();
});
$("btnVZoomOut").addEventListener("click", ()=>{
  if(!state.buffer) return;
  state.vZoom = clamp(state.vZoom/1.25, 0.25, 10);
  drawAll();
});


$("btnAddPair").addEventListener("click", ()=> addCuePair());
$("chkLinkPair").checked = true; state.linkPair = true;
$("chkLinkPair").addEventListener("change", ()=>{
  undoCheckpoint();
  state.linkPair = $("chkLinkPair").checked;
  if(!state.linkPair) state.dragPair = null;
  log(`連動移動: ${state.linkPair ? "ON" : "OFF"}`);
  renderCues();
  _forceWaveRedraw();
});
$("btnAddCustom").addEventListener("click", ()=>{
  const v = ($("customLabel").value||"").trim();
  if(!v) return;
  addCue(v);
  $("customLabel").value = "";
});
// BC$ dropdown add (playhead)
(function(){
  const sel = $("selBcLabel");
  const btn = $("btnAddBcLabel");
  if(!sel || !btn) return;

  sel.addEventListener("change", ()=>{ updateButtons(); });

  btn.addEventListener("click", ()=>{
    if(!state.buffer) return;
    const label = (sel.value || "").trim();
    if(!label) return;

    // NOTE is fixed at head (0s) and must be unique per NOTE number
    if(/^BC\$NOTE[1-9]$/.test(label)){
      if(state.cues.some(c=>c.label===label)){
        toast(`${label} は既に存在します`, "err");
        return;
      }
      undoCheckpoint();
      const id = state.nextCueId++;
      state.cues.push({id, label, sec: 0});
      log(`CUE+: ${label} @ 0.000s`);
      renderCues();
      drawAll();
      toast(`${label} を先頭(0秒)に追加しました`, "ok");
      return;
    }

    // normal: add at playhead
    addCue(label);
    toast(`${label} を追加しました`, "ok");
  });
})();

$("customLabel").addEventListener("keydown",(e)=>{
  // Safety: do NOT add cues on Enter while typing labels.
  if(e.key==="Enter"){
    e.preventDefault();
    e.stopPropagation();
    // Intentionally do nothing. Use the ＋追加 button to add.
  }
});

// ===== Export pre-check modal (LUFS/TruePeak/etc.) =====
function _ecEscape(s){
  return String(s??"")
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#39;");
}

function _ecParseFmtInfo(){
  try{
    const p = state.srcFmtPayload;
    if(!p) return null;
    const dv = new DataView(p.buffer, p.byteOffset, p.byteLength);
    if(p.byteLength < 16) return null;
    const audioFormat = dv.getUint16(0, true);
    const numChannels = dv.getUint16(2, true);
    const sampleRate  = dv.getUint32(4, true);
    const bitsPerSample = dv.getUint16(14, true);
    return {audioFormat, numChannels, sampleRate, bitsPerSample};
  }catch(_){ return null; }
}
function _ecFmtTime(sec){
  const s = Math.max(0, Number(sec)||0);
  const mm = Math.floor(s/60);
  const ss = s - mm*60;
  return `${mm.toString().padStart(2,"0")}:${ss.toFixed(3).padStart(6,"0")}`;
}
function _ecDb(x){
  if(!isFinite(x) || x<=0) return "-∞";
  return (20*Math.log10(x)).toFixed(2);
}
function _ecDb10(x){
  if(!isFinite(x) || x<=0) return "-∞";
  return (10*Math.log10(x)).toFixed(2);
}
function _ecFindRange(){
  // If both STNBY and END exist, analyze between them; else analyze whole file.
  const cues = Array.isArray(state.cues) ? state.cues : [];
  const pick = (kw)=> cues
    .filter(c=> (c?.label||"").toUpperCase().includes(kw))
    .sort((a,b)=> (a.sec||0)-(b.sec||0))[0] || null;

  const st = pick("STNBY") || pick("STANBY") || pick("STANDBY");
  const edAll = cues.filter(c=> (c?.label||"").toUpperCase().includes("END"))
                    .sort((a,b)=> (a.sec||0)-(b.sec||0));
  let ed = null;
  if(st){
    ed = edAll.find(c=> (c.sec||0) > (st.sec||0)) || null;
  }else{
    ed = edAll[0] || null;
  }

  const dur = state.buffer ? state.buffer.duration : 0;
  const start = st ? Math.max(0, Math.min(dur, st.sec||0)) : 0;
  const end   = (st && ed) ? Math.max(0, Math.min(dur, ed.sec||0)) : dur;

  const hasSeg = !!(st && ed && end>start);
  return {hasSeg, start, end, st, ed};
}

function _ecComputeIntegratedLufs(buffer, startSec, endSec){
  const sr = buffer.sampleRate;
  const nch = buffer.numberOfChannels;
  const start = Math.max(0, Math.floor(startSec*sr));
  const end = Math.min(buffer.length, Math.floor(endSec*sr));
  if(end <= start+1) return {lufs: null, blocks: 0};

  const win = Math.max(1, Math.floor(sr * 0.400)); // 400ms
  const hop = Math.max(1, Math.floor(sr * 0.100)); // 100ms
  const absGate = -70;

  const blocks = [];
  for(let s=start; s+win<=end; s+=hop){
    let sum = 0;
    for(let ch=0; ch<nch; ch++){
      const d = buffer.getChannelData(ch);
      for(let i=s; i<s+win; i++){
        const v = d[i];
        sum += v*v;
      }
    }
    const ms = sum / (win * nch);
    const l = -0.691 + (ms>0 ? 10*Math.log10(ms) : -Infinity);
    if(isFinite(l)) blocks.push({ms, l});
  }
  if(blocks.length===0) return {lufs: null, blocks: 0};

  const aboveAbs = blocks.filter(b=> b.l > absGate);
  if(aboveAbs.length===0) return {lufs: null, blocks: blocks.length};

  const meanMs = aboveAbs.reduce((a,b)=>a+b.ms,0)/aboveAbs.length;
  const ungated = -0.691 + 10*Math.log10(Math.max(1e-20, meanMs));
  const relGate = ungated - 10;

  const aboveRel = aboveAbs.filter(b=> b.l > relGate);
  const meanMs2 = aboveRel.length ? (aboveRel.reduce((a,b)=>a+b.ms,0)/aboveRel.length) : meanMs;
  const gated = -0.691 + 10*Math.log10(Math.max(1e-20, meanMs2));
  return {lufs: gated, blocks: blocks.length};
}

function _ecComputePeaks(buffer, startSec, endSec){
  const sr = buffer.sampleRate;
  const nch = buffer.numberOfChannels;
  const start = Math.max(0, Math.floor(startSec*sr));
  const end = Math.min(buffer.length, Math.floor(endSec*sr));
  if(end <= start+1) return {samplePeak: 0, truePeak: 0, clipped: 0};

  let samplePeak = 0;
  let truePeak = 0;
  let clipped = 0;

  // Linear 4x inter-sample peak approximation (fast, no OfflineAudioContext).
  for(let ch=0; ch<nch; ch++){
    const d = buffer.getChannelData(ch);
    for(let i=start; i<end-1; i++){
      const a = d[i];
      const b = d[i+1];
      const da = Math.abs(a);
      if(da > samplePeak) samplePeak = da;
      if(da >= 0.9999) clipped++;

      const step = (b - a) * 0.25;
      // k=0..3 (include a)
      let v = a;
      for(let k=0; k<4; k++){
        const av = Math.abs(v);
        if(av > truePeak) truePeak = av;
        v += step;
      }
    }
    const last = Math.abs(d[end-1]);
    if(last > samplePeak) samplePeak = last;
    if(last >= 0.9999) clipped++;
    if(last > truePeak) truePeak = last;
  }
  return {samplePeak, truePeak, clipped};
}

function _ecComputeSilence(buffer, startSec, endSec){
  const sr = buffer.sampleRate;
  const nch = buffer.numberOfChannels;
  const start = Math.max(0, Math.floor(startSec*sr));
  const end = Math.min(buffer.length, Math.floor(endSec*sr));
  if(end <= start+1) return {maxSilentSec: 0};

  const block = Math.max(1, Math.floor(sr * 0.100)); // 100ms
  const threshDb = -60;
  const thresh = Math.pow(10, threshDb/20); // amplitude RMS threshold
  const minSilentBlocks = 1; // >= 0.1s

  let maxRun = 0;
  let run = 0;

  for(let s=start; s<end; s+=block){
    const e = Math.min(end, s+block);
    let sum = 0;
    const n = (e - s) * nch;
    for(let ch=0; ch<nch; ch++){
      const d = buffer.getChannelData(ch);
      for(let i=s; i<e; i++){
        const v = d[i];
        sum += v*v;
      }
    }
    const rms = Math.sqrt(sum / Math.max(1, n));
    if(rms <= thresh){
      run++;
      if(run > maxRun) maxRun = run;
    }else{
      run = 0;
    }
  }
  const maxSilentSec = (maxRun >= minSilentBlocks) ? (maxRun * 0.1) : 0;
  return {maxSilentSec};
}



/* ===============================
   DIFF_SUMMARY: change summary (sellable UI)
================================ */

function _tsStamp(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function _backupStamp(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function _sanitizeFileSegment(value){
  return String(value || "output")
    .replace(/[<>:"/\\|?*\u0000-\u001F]/g, "_")
    .replace(/\s+/g, " ")
    .trim() || "output";
}
function _baseNameNoExt(name){
  const n = String(name||"output.wav");
  return n.replace(/\.[^/.]+$/,"");
}
async function downloadTextFile(filename, text){
  try{
    const encoder = new TextEncoder();
    const payload = encoder.encode(String(text || ""));
    const res = await saveExportBytes(payload, filename || "report.txt");
    if(res?.mode === "cancel"){
      return res;
    }
    return res;
  }catch(e){
    log(`WARN: テキスト書き出しに失敗: ${e?.message||e}`);
    return null;
  }
}
function getLogText(){
  const box = $("logBox2") || $("logBox");
  if(!box) return "";
  const lines = [];
  box.querySelectorAll(".logLine").forEach(el=> lines.push(el.textContent||""));
  return lines.reverse().join("\n");
}

function _snapCmcd(){
  const obj = {};
  try{
    for(const k of (window.CMCD_KEYS_UI || [])){
      const v = document.querySelector(`[data-cmcd="${CSS.escape(k)}"]`)?.value ?? "";
      obj[k] = String(v);
    }
  }catch(_){}
  return obj;
}
function _snapCues(){
  const cues = Array.isArray(state.cues) ? state.cues.slice() : [];
  return cues
    .map(c=>({ label: String(c.label||"").trim(), sec: Number((c.sec||0).toFixed(3)) }))
    .sort((a,b)=> (a.sec-b.sec) || a.label.localeCompare(b.label));
}
function takeSnapshot(){
  const snap = {
    fileName: String(state.fileName||""),
    procApplied: !!state.procApplied,
    bextCodingHistory: String($("bextArea")?.value || "").trim(),
    cmcd: _snapCmcd(),
    cues: _snapCues(),
    attach: null,
    chunks: [],
  };
  try{
    if(state.pdfAttach && state.pdfAttach.bytes && state.pdfAttach.bytes.length){
      snap.attach = {
        name: String(state.pdfAttach.name||""),
        kind: String(state.pdfAttach.kind || _fileKindFromName(state.pdfAttach.name) || "FILE"),
        size: Number(state.pdfAttach.bytes.length||0),
      };
    }
  }catch(_){ snap.attach = null; }

  try{
    if(Array.isArray(state.srcChunks)){
      snap.chunks = state.srcChunks.map(ch=>({ id: String(ch.id||""), size: Number(ch.size||0) }));
    }
  }catch(_){ snap.chunks = []; }

  return snap;
}

function diffSnapshots(a, b){
  const out = [];
  const add = (sec, item, from, to, badge="chg")=>{
    out.push({sec, item, from, to, badge});
  };
  if(!a || !b) return out;

  // 1) Processing
  if(!!a.procApplied !== !!b.procApplied){
    add("音声", "ラウドネスノーマライズ", a.procApplied ? "あり" : "なし", b.procApplied ? "あり" : "なし");
  }

  // 2) Attachment
  const aHas = !!a.attach, bHas = !!b.attach;
  if(aHas !== bHas){
    add("添付", "ファイル添付", aHas ? `${a.attach.kind} / ${a.attach.name}` : "なし", bHas ? `${b.attach.kind} / ${b.attach.name}` : "なし");
  }else if(aHas && bHas){
    const aKey = `${a.attach.kind}|${a.attach.name}|${a.attach.size}`;
    const bKey = `${b.attach.kind}|${b.attach.name}|${b.attach.size}`;
    if(aKey !== bKey){
      add("添付", "添付内容", `${a.attach.kind} / ${a.attach.name} (${Math.round(a.attach.size/1024)}KB)`, `${b.attach.kind} / ${b.attach.name} (${Math.round(b.attach.size/1024)}KB)`);
    }
  }

  // 3) bext
  const aCh = (a.bextCodingHistory||"").trim();
  const bCh = (b.bextCodingHistory||"").trim();
  if(aCh !== bCh){
    const fa = aCh ? `入力あり（${aCh.split(/\r?\n/).length}行）` : "空";
    const fb = bCh ? `入力あり（${bCh.split(/\r?\n/).length}行）` : "空";
    add("bext", "CodingHistory", fa, fb);
  }

  // 4) cmcd (only show changed non-Ver)
  try{
    const keys = (window.CMCD_KEYS_UI || []).filter(k=>k!=="Ver");
    const changed = [];
    for(const k of keys){
      const av = String(a.cmcd?.[k] ?? "");
      const bv = String(b.cmcd?.[k] ?? "");
      if(av !== bv){
        // hide if both empty
        if(!av.trim() && !bv.trim()) continue;
        changed.push(k);
      }
    }
    if(changed.length){
      add("cmcd", "入力項目", `${changed.length}項目`, `${changed.length}項目`);
      // add per key (limit)
      const lim = 6;
      changed.slice(0, lim).forEach(k=>{
        add("cmcd", k, String(a.cmcd?.[k] ?? ""), String(b.cmcd?.[k] ?? ""));
      });
      if(changed.length > lim){
        add("cmcd", "…", `ほか${changed.length-lim}項目`, "");
      }
    }
  }catch(_){}

  // 5) cues: compare by label and moved
  try{
    const mapA = new Map((a.cues||[]).map(c=>[c.label, c.sec]));
    const mapB = new Map((b.cues||[]).map(c=>[c.label, c.sec]));
    const labels = new Set([...mapA.keys(), ...mapB.keys()]);
    const added=[], removed=[], moved=[];
    labels.forEach(l=>{
      const ha = mapA.has(l), hb = mapB.has(l);
      if(!ha && hb) added.push(l);
      else if(ha && !hb) removed.push(l);
      else if(ha && hb){
        const sa = mapA.get(l), sb = mapB.get(l);
        if(Number(sa) !== Number(sb)) moved.push({label:l, from:sa, to:sb});
      }
    });
    if(added.length || removed.length || moved.length){
      add("CUE", "変更件数", `${removed.length}削除 / ${moved.length}移動 / ${added.length}追加`, `${removed.length}削除 / ${moved.length}移動 / ${added.length}追加`);
      moved.slice(0,6).forEach(mv=>{
        add("CUE", mv.label || "(no label)", `${mv.from.toFixed(3)}s`, `${mv.to.toFixed(3)}s`);
      });
      if(moved.length > 6) add("CUE", "…", `ほか${moved.length-6}件移動`, "");
    }
  }catch(_){}

  if(!out.length){
    out.push({sec:"—", item:"変更", from:"なし（原本のまま）", to:"—", badge:"ok"});
  }
  return out;
}

function _renderDiffTo(el, diffs){
  if(!el) return;
  if(!diffs || !diffs.length){
    el.innerHTML = "<div class='muted'>—</div>";
    return;
  }
  const hasChanges = !(diffs.length===1 && diffs[0].badge==="ok");
  const badge = hasChanges ? `<span class="diffBadge chg">変更あり</span>` : `<span class="diffBadge ok">変更なし</span>`;
  const rows = diffs.map(d=>{
    const sec = (d.sec||"").toString();
    const item = (d.item||"").toString();
    const from = (d.from==null ? "" : String(d.from));
    const to = (d.to==null ? "" : String(d.to));
    return `<tr>
      <td><span class="diffBadge ${d.badge==="ok"?"ok":"chg"}">${_ecEscape(sec)}</span></td>
      <td>${_ecEscape(item)}</td>
      <td class="diffMono">${_ecEscape(from)}</td>
      <td class="diffMono">${_ecEscape(to)}</td>
    </tr>`;
  }).join("");
  el.innerHTML = `
    <div class="rowBetween" style="align-items:center;gap:10px;margin-bottom:8px">
      <div style="font-weight:800">変更サマリ</div>
      ${badge}
    </div>
    <table class="diffTable" aria-label="変更サマリ テーブル">
      <thead><tr><th style="width:96px">区分</th><th style="width:180px">項目</th><th>変更前</th><th>変更後</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

let _diffTimer = 0;
function updateDiffUI(){
  try{
    if(!state.buffer) return;
    if(!state.originalSnapshot){
      // If user edited before load snapshot, fallback to "current as baseline"
      state.originalSnapshot = takeSnapshot();
    }
    const cur = takeSnapshot();
    const diffs = diffSnapshots(state.originalSnapshot, cur);
    state._diff = {cur, diffs};
    _renderDiffTo($("diffBox"), diffs);
    _renderDiffTo($("ec_diffBox"), diffs);
  }catch(_){}
}
function scheduleDiffUpdate(force=false){
  if(force){
    try{ if(_diffTimer) clearTimeout(_diffTimer); }catch(_){}
    _diffTimer = 0;
    updateDiffUI();
    return;
  }
  if(_diffTimer) return;
  _diffTimer = setTimeout(()=>{ _diffTimer = 0; updateDiffUI(); }, 0);
}

function initDiffSummary(){
  try{
    $("bextArea")?.addEventListener("input", ()=> scheduleDiffUpdate());
    document.querySelectorAll('[data-cmcd]').forEach(el=>{
      el.addEventListener("input", ()=> scheduleDiffUpdate(), {passive:true});
    });
  }catch(_){}
}

function getLastQcForCurrentFile(){
  const last = window.__wavcueLastQc;
  if(!last || !last.result) return null;
  const cur = String(state.fileName || "");
  if(cur && last.fileKey && cur !== last.fileKey) return null;
  return last.result;
}

function extractQcNgItems(qcResult){
  const items = qcResult?.items || qcResult?.rows || qcResult?.results || [];
  const normalized = Array.isArray(items) ? items : [];
  const ng = normalized.filter(it => it && (it.ok === false || it.status === "ng" || it.pass === false));
  return { items: normalized, ng };
}

function renderExportQc(qcResult){
  const summaryEl = document.getElementById("exportQcSummary");
  const listEl = document.getElementById("exportQcList");
  if(!summaryEl || !listEl) return;

  if(!qcResult){
    summaryEl.textContent = "未チェック";
    listEl.innerHTML = "";
    return;
  }

  const { items, ng } = extractQcNgItems(qcResult);
  const okCount = Math.max(0, items.length - ng.length);

  summaryEl.textContent = (ng.length === 0)
    ? `OK（${okCount}/${items.length}）`
    : `NG（${ng.length}件） / OK（${okCount}/${items.length}）`;

  listEl.innerHTML = "";
  items.forEach(it=>{
    const label = it.label || it.name || it.key || "項目";
    const ok = !(it.ok === false || it.status === "ng" || it.pass === false);
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.justifyContent = "space-between";
    row.style.gap = "10px";
    row.style.padding = "8px 10px";
    row.style.borderRadius = "10px";
    row.style.background = "rgba(255,255,255,0.04)";
    row.innerHTML = `
      <div style="font-weight:600">${label}</div>
      <div style="font-size:12px;opacity:.9">${ok ? "OK" : "NG"}</div>
    `;
    if(!ok){
      row.style.outline = "1px solid rgba(255,80,80,0.35)";
    }
    listEl.appendChild(row);
  });
}

function openExportQcNgDialog(qcResult){
  const dlg = document.getElementById("exportQcNgDialog");
  const list = document.getElementById("exportQcNgList");
  if(!dlg || !list) return false;

  const { ng } = extractQcNgItems(qcResult);
  list.innerHTML = "";
  ng.forEach(it=>{
    const label = it.label || it.name || it.key || "項目";
    const reason = it.reason || it.message || it.detail || "";
    const row = document.createElement("div");
    row.style.padding = "8px 10px";
    row.style.borderRadius = "10px";
    row.style.background = "rgba(255,80,80,0.10)";
    row.style.outline = "1px solid rgba(255,80,80,0.30)";
    row.innerHTML = `<div style="font-weight:700">${label}</div>${reason ? `<div style="opacity:.9;font-size:12px;margin-top:2px">${reason}</div>` : ""}`;
    list.appendChild(row);
  });

  try{
    if(dlg.open) dlg.close();
  }catch(_){}
  try{
    dlg.showModal();
  }catch(_){
    try{ dlg.show(); }catch(__){}
  }
  return true;
}


/* ===============================
   QC_EXPORTCHECK: pre-export analyzer
================================ */

function _ecSet(id, text){
  const el = document.getElementById(id);
  if(!el) return;
  el.textContent = text;
}
function _ecNormalizeLabel(s){
  return String(s ?? "").trim().toLowerCase().replace(/\s+/g, "");
}
function _ecFindQcItem(label, qcResult){
  const items = qcResult?.items || qcResult?.rows || qcResult?.results || [];
  const normalized = Array.isArray(items) ? items : [];
  const target = _ecNormalizeLabel(label);
  if(!target) return null;
  for(const it of normalized){
    const name = _ecNormalizeLabel(it?.label || it?.name || it?.key || "");
    if(name && name === target) return it;
  }
  return null;
}
function _ecSetResult(id, label, text, qcResult){
  const el = document.getElementById(id);
  if(!el) return;
  const qcItem = _ecFindQcItem(label, qcResult);
  if(!qcItem){
    el.textContent = text;
    return;
  }
  const ok = !(qcItem.ok === false || qcItem.status === "ng" || qcItem.pass === false);
  const badgeClass = ok ? "ok" : "ng";
  el.innerHTML = `${_ecEscape(text)} <span class="badge ${badgeClass}">${ok ? "OK" : "NG"}</span>`;
}
function _ecSetHtml(id, html){
  const el = document.getElementById(id);
  if(!el) return;
  el.innerHTML = html;
}

function _ecRowShow(keyId, valId, show){
  const k = document.getElementById(keyId);
  const v = document.getElementById(valId);
  if(k) k.style.display = show ? "" : "none";
  if(v) v.style.display = show ? "" : "none";
}
function _ecHideOptionalRows(){
  _ecRowShow("ec_k_cuecount", "ec_cuecount", false);
  _ecRowShow("ec_k_noteuniq", "ec_noteuniq", false);
  _ecRowShow("ec_k_plst", "ec_plst", false);
  _ecRowShow("ec_k_lblenc", "ec_lblenc", false);
}

async function _ecRunAndShow(){
  const dlg = $("exportCheckDialog");
  if(!dlg) return;
  const qcResult = getLastQcForCurrentFile();

  if(!state.buffer){
    _ecSet("ec_range", "—");
    _ecSetResult("ec_lufs", "Integrated LUFS", "—", qcResult);
    _ecSetResult("ec_tp", "TruePeak", "—", qcResult);
    _ecSetResult("ec_sr", "サンプルレート", "—", qcResult);
    _ecSetResult("ec_bd", "bit深度", "—", qcResult);
    _ecSetResult("ec_ch", "チャンネル", "—", qcResult);
    _ecSetResult("ec_len", "本編秒数", "—", qcResult);
    _ecSetResult("ec_clip", "クリッピング", "—", qcResult);
    _ecSetResult("ec_silence", "無音", "—", qcResult);
    _ecSetResult("ec_file", "ファイル", "—", qcResult);
    _ecSetResult("ec_cuecount", "CUE数", "—", qcResult);
    _ecSetResult("ec_noteuniq", "NOTEラベル", "—", qcResult);
    _ecSetResult("ec_plst", "plst", "—", qcResult);
    _ecSetResult("ec_lblenc", "ラベル文字", "—", qcResult);
    _ecHideOptionalRows();
    try{ const b=$("exportCheckRun"); if(b){ b.disabled=true; b.title=""; } }catch(_){ }
    _ecSetHtml("ec_cues", "<div class='muted'>—</div>");
    dlg.showModal();
    return;
  }

  // Range
  try{ const b=$("exportCheckRun"); if(b){ b.disabled=false; b.title=""; } }catch(_){ }
  _ecHideOptionalRows();

  const range = _ecFindRange();
  const startSec = range.hasSeg ? range.start : 0;
  const endSec = range.hasSeg ? range.end : state.buffer.duration;
  const lenSec = Math.max(0, endSec - startSec);
  _ecSetResult("ec_len", "本編秒数", `${lenSec.toFixed(3)} s`, qcResult);
  _ecSet("ec_range",
    range.hasSeg
      ? `STNBY〜END（${_ecFmtTime(startSec)} → ${_ecFmtTime(endSec)} / ${lenSec.toFixed(3)}s）`
      : `全体（0:00.000 → ${_ecFmtTime(state.buffer.duration)} / ${state.buffer.duration.toFixed(3)}s）`
  );

  // LUFS
  _ecSetResult("ec_lufs", "Integrated LUFS", "計測中…", qcResult);
  const lufsRes = _ecComputeIntegratedLufs(state.buffer, startSec, endSec);
  _ecSetResult("ec_lufs", "Integrated LUFS", (lufsRes.lufs==null) ? "—" : `${lufsRes.lufs.toFixed(2)} LUFS`, qcResult);

  // Peaks / Clip
  _ecSetResult("ec_tp", "TruePeak", "計測中…", qcResult);
  const pk = _ecComputePeaks(state.buffer, startSec, endSec);
  const tpDb = _ecDb(pk.truePeak);
  _ecSetResult("ec_tp", "TruePeak", `${tpDb} dBTP（approx）`, qcResult);
  _ecSetResult("ec_clip", "クリッピング", (pk.clipped>0) ? `検出あり（samples: ${pk.clipped}）` : "検出なし", qcResult);

  // Silence (head/tail like StdCheck)
  try{
    const preset = _scGetPresetById(state.qcPresetId);
    const silMin = (preset && isFinite(preset.silenceMinSec)) ? Number(preset.silenceMinSec) : 0.0;
    const silMax = (preset && isFinite(preset.silenceMaxSec)) ? Number(preset.silenceMaxSec) : ((preset && isFinite(preset.silenceAllowSec)) ? Number(preset.silenceAllowSec) : 0.5);
    const td = (CFG?.STDCHK_SILENCE_THRESHOLD_DB ?? -60);
    const ht = _scComputeHeadTailSilence(state.buffer, startSec, endSec, td);
    if(!ht.hasSound){
      _ecSetResult("ec_silence", "無音", `全区間無音（${lenSec.toFixed(2)}s）`, qcResult);
    }else{
      const head = ht.headSec || 0;
      const tail = ht.tailSec || 0;
      let txt = `前 ${head.toFixed(2)}s / 後 ${tail.toFixed(2)}s`;
      const under = (head < silMin) || (tail < silMin);
      const over = (head > silMax) || (tail > silMax);
      if(under && over) txt += "（不足/超過）";
      else if(under) txt += "（不足）";
      else if(over) txt += "（超過）";
      txt += `（許容 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s）`;
      _ecSetResult("ec_silence", "無音", txt, qcResult);
    }
  }catch(e){
    // fallback to legacy silence check
    const sil = _ecComputeSilence(state.buffer, startSec, endSec);
    _ecSetResult("ec_silence", "無音", sil.maxSilentSec>0 ? `検出あり（最長 ${sil.maxSilentSec.toFixed(1)}s）` : "検出なし", qcResult);
  }


  // Format info
  const fmt = _ecParseFmtInfo();
  _ecSetResult("ec_sr", "サンプルレート", fmt ? `${fmt.sampleRate} Hz` : `${state.buffer.sampleRate} Hz`, qcResult);
  _ecSetResult("ec_bd", "bit深度", fmt ? `${fmt.bitsPerSample} bit` : "—", qcResult);
  const chN = fmt ? fmt.numChannels : state.buffer.numberOfChannels;
  const chLabel = (chN===1) ? "モノラル" : (chN===2) ? "ステレオ" : `${chN} ch`;
  _ecSetResult("ec_ch", "チャンネル", chLabel, qcResult);

  // File (CSV/PDF/XML/TEXT)
  const _atts = Array.isArray(state.attachments) ? state.attachments : [];
  const _a0 = (_atts[0] && _atts[0].bytes) ? _atts[0] : ((state.pdfAttach && state.pdfAttach.bytes) ? state.pdfAttach : null);
  if(_a0){
    const kb = Math.round(_a0.bytes.length/1024);
    const kind = _a0.kind || _fileKindFromName(_a0.name) || _fileKindFromMime(_a0.mime) || 'FILE';
    const name = _a0.name || ('attached' + (_fileExtForKind(kind) || ''));
    const more = (_atts.length > 0) ? (_atts.length - 1) : 0;
    const moreTxt = (more > 0) ? (' 他' + more + '件') : '';
    _ecSetResult("ec_file", "ファイル", `あり（${kind} / ${name} / ${kb}KB）` + moreTxt, qcResult);
  }else{
    _ecSetResult("ec_file", "ファイル", "なし", qcResult);
  }

// Cues list
  const cues = Array.isArray(state.cues) ? state.cues.slice().sort((a,b)=> (a.sec||0)-(b.sec||0)) : [];
  if(cues.length){
    const rows = cues.map(c=>{
      const t = _ecFmtTime(c.sec||0);
      const label = String(c.label||"").trim() || "(no label)";
      return `<div class="ecCueRow"><span class="ecCueT">${t}</span><span class="ecCueL">${_ecEscape(label)}</span></div>`;
    }).join("");
    _ecSetHtml("ec_cues", rows);
  }else{
    _ecSetHtml("ec_cues", "<div class='muted'>（CUEなし）</div>");
  }

  // --- BWF-J checks (JPPA-1-2018) ---
  const cueCount = cues.length;
  const cueCountOk = (cueCount <= 99);
  _ecSetResult("ec_cuecount", "CUE数", cueCountOk ? `${cueCount}件` : `NG（${cueCount}件 / 最大99）`, qcResult);
  _ecRowShow("ec_k_cuecount","ec_cuecount", !cueCountOk);

  // NOTE label uniqueness (NOTE1..NOTE9 must be unique)
  const _ecNormLbl = (s)=> String(s||"").trim().replace(/\s+/g, "");
  const _noteLabels = cues
    .map(c=> _ecNormLbl(c && c.label).toUpperCase())
    .filter(t=> /^BC\$NOTE\d+$/i.test(t));
  const _seen = new Set();
  const _dups = [];
  for(const t of _noteLabels){
    if(_seen.has(t)) _dups.push(t);
    else _seen.add(t);
  }
  const noteOk = (_dups.length === 0);
  _ecSetResult("ec_noteuniq", "NOTEラベル", noteOk ? "OK" : `NG（重複: ${Array.from(new Set(_dups)).join(", ")}）`, qcResult);
  _ecRowShow("ec_k_noteuniq","ec_noteuniq", !noteOk);

  // plst segments: list all BC$ cues except NOTE (export logic will generate plst; UI shows only when NG)
  let plstOk = true;
  let plstInfo = "";
  try{
    const plstCount = cues.filter(c=>{
      const t = _ecNormLbl(c && c.label).toUpperCase();
      return t.startsWith("BC$") && !t.startsWith("BC$NOTE") && !/^BC\$NOTE\d+$/i.test(t);
    }).length;
    plstInfo = plstCount ? `${plstCount} segments（BC$NOTE除外）` : "なし";
  }catch(err){
    plstOk = false;
    plstInfo = `NG（plst算出失敗）`;
    try{ logWarn("PLST", `plst count calc failed: ${String(err&&err.message||err)}`); }catch(_){ }
  }
  _ecSetResult("ec_plst", "plst", plstInfo, qcResult);
  _ecRowShow("ec_k_plst","ec_plst", !plstOk);


  // Label encoding（Shift-JIS/CP932）: 変換不能文字が含まれる場合はNG（書き出し不可）
  let lblEncOk = true;
  let lblBad = [];
  try{
    for(const c of cues){
      const s = (c && c.label != null) ? String(c.label) : "";
      if(!s) continue;
      const enc = cp932EncodeEx(s + "\0");
      if(enc && enc.hadReplace){
        lblEncOk = false;
        lblBad.push(s);
        if(lblBad.length >= 3) break;
      }
    }
  }catch(err){
    lblEncOk = false;
    try{ logWarn("LABEL", `cp932 encode check failed: ${String(err&&err.message||err)}`); }catch(_){ }
  }
  if(!lblEncOk){
    const ex = lblBad.length ? (" 例: " + lblBad.slice(0,2).map(x=>("「" + x.slice(0,24) + "」")).join(" / ")) : "";
    _ecSetResult("ec_lblenc", "ラベル文字", "NG（Shift-JIS非対応文字）" + ex, qcResult);
  }else{
    _ecSetResult("ec_lblenc", "ラベル文字", "OK", qcResult);
  }
  _ecRowShow("ec_k_lblenc","ec_lblenc", !lblEncOk);


  // Gate export button when NG
  try{
    const btn = $("exportCheckRun");
    if(btn){
      const blocked = (!cueCountOk) || (!noteOk) || (!plstOk) || (!lblEncOk);
      btn.disabled = blocked;
      btn.title = blocked ? "規格NGがあります（CUE数 / NOTEラベル / ラベル文字など）。" : "";
    }
  }catch(_){ }

  try{ scheduleDiffUpdate(true); }catch(_){ }

  try{ renderExportQc(getLastQcForCurrentFile()); }catch(_){ }
  dlg.showModal();
}

async function doFinalExport(){
  try{
    log("INFO: 書き出し（チェック後）");
    await exportWav();
  }catch(e){
    log("ERR: 書き出し失敗: "+(e&&e.stack?e.stack:e));
    try{ toast("書き出しに失敗しました。画面下のログをご確認ください。","err"); }catch(_){}
  }
}

function _ecWire(){
  const dlg = $("exportCheckDialog");
  if(!dlg) return;

  const close = ()=>{ _dialogCloseWithGuard(dlg); };

  // Close when clicking outside the modal content (dialog backdrop)
  dlg.addEventListener("click", (e)=>{
    if(e.target === dlg) close();
  });

  // Close on ESC
  dlg.addEventListener("cancel", (e)=>{ e.preventDefault(); close(); });

  // Run export after confirmation
  $("exportCheckRun")?.addEventListener("click", async ()=>{
    const qcResult = getLastQcForCurrentFile();
    if(qcResult){
      const { ng } = extractQcNgItems(qcResult);
      if(ng.length > 0){
        close();
        openExportQcNgDialog(qcResult);
        return;
      }
    }
    close();
    await doFinalExport();
  });

  const refreshBtn = $("exportQcRefreshBtn");
  if(refreshBtn && !refreshBtn.dataset.bound){
    refreshBtn.dataset.bound = "1";
    refreshBtn.addEventListener("click", ()=>{
      const summaryEl = $("exportQcSummary");
      if(summaryEl) summaryEl.textContent = "チェック中…";
      try{ _scRunMeasureAndRender({switchToResults:false}); }catch(_){}
      try{ renderExportQc(getLastQcForCurrentFile()); }catch(_){}
    });
  }
}


// replace export click to open modal
$("btnExport").addEventListener("click", async ()=>{
  try{
    const gate = guardExport({ source: "exportButton" });
    if(gate?.tier === "demo" && !_demoExportNoticeShown){
      _demoExportNoticeShown = true;
      if(window.safeToast) window.safeToast(LICENSE_TEXT.demoNotice, "info");
    }
    if(!gate.ok){
      if(window.safeToast){
        if(gate.reason === "standard-auth-expired") window.safeToast(LICENSE_TEXT.standardAuthToast, "warn");
        else if(gate.reason === "demo_export_limit") window.safeToast(LICENSE_TEXT.demoExportLimitToast, "warn");
        else if(gate.reason === "demo_expired") window.safeToast(LICENSE_TEXT.demoExpiredToast, "warn");
        else window.safeToast(LICENSE_TEXT.exportStandardRequired, "warn");
      }
      return;
    }
    await _ecRunAndShow();
  }catch(e){
    log("ERR: チェック失敗: "+(e&&e.stack?e.stack:e));
    alert("チェックでエラーが発生しました。ログをご確認ください。");
  }
});
_ecWire();
if($("exportQcNgCancelBtn")){
  $("exportQcNgCancelBtn").addEventListener("click", ()=>{
    try{ $("exportQcNgDialog")?.close(); }catch(_){}
  });
}
if($("exportQcNgProceedBtn")){
  $("exportQcNgProceedBtn").addEventListener("click", async ()=>{
    try{ $("exportQcNgDialog")?.close(); }catch(_){}
    await doFinalExport();
  });
}
// ===== /Export pre-check modal =====

// ===== Standard Check modal (separate) =====
function _scSet(id, text){
  const el = document.getElementById(id);
  if(!el) return;
  el.textContent = text;
}
function _scSetHtml(id, html, title){
  const el = document.getElementById(id);
  if(!el) return;
  el.innerHTML = html;
  if(title!==undefined){
    const t = (title==null) ? "" : String(title);
    // Put the reason on both the cell and the pills inside it,
    // so hovering the badge still shows the same tooltip.
    el.title = t;
    try{
      el.querySelectorAll(".scPill").forEach(n=>{ n.title = t; });
    }catch(_){}
  }
}


function _scFmtList(list, unit){
  if(!Array.isArray(list) || list.length===0) return "制限なし";
  return list.join(" / ") + (unit||"");
}
function _scFmtChList(list){
  if(!Array.isArray(list) || list.length===0) return "制限なし";
  return list.map(_scFormatCh).join(" / ");
}
function _scRenderTargets(preset){
  if(!preset){
    _scSet("sc_lufs_t", "—");
    _scSet("sc_tp_t", "—");
    _scSet("sc_sr_t", "—");
    _scSet("sc_bd_t", "—");
    _scSet("sc_ch_t", "—");
    _scSet("sc_clip_t", "—");
    _scSet("sc_silence_t", "—");
    return;
  }
  const l = (isFinite(preset.targetLufs) && isFinite(preset.tolLufs))
    ? `${preset.targetLufs.toFixed(1)} ±${preset.tolLufs.toFixed(1)} LUFS`
    : "—";
  const tp = (isFinite(preset.maxTruePeakDb))
    ? `${preset.maxTruePeakDb.toFixed(2)} dBTP 以下`
    : "—";
  const sr = _scFmtList(preset.allowedSampleRates, " Hz");
  const bd = _scFmtList(preset.allowedBits, " bit");
  const ch = _scFmtChList(preset.allowedChannels);
  const clip = `1db以上`;
  const silMin = (isFinite(preset.silenceMinSec)) ? Number(preset.silenceMinSec) : 0.0;
  const silMax = (isFinite(preset.silenceMaxSec)) ? Number(preset.silenceMaxSec) : ((isFinite(preset.silenceAllowSec)) ? Number(preset.silenceAllowSec) : 0.5);
  const sil = `前/後 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s`;

  _scSet("sc_lufs_t", l);
  _scSet("sc_tp_t", tp);
  _scSet("sc_sr_t", sr);
  _scSet("sc_bd_t", bd);
  _scSet("sc_ch_t", ch);
  _scSet("sc_clip_t", clip);
  _scSet("sc_silence_t", sil);
}
function _scPill(kind, label){
  const k = (kind==="ok"||kind==="warn"||kind==="ng") ? kind : "";
  const safe = String(label||"").replace(/[&<>"]/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c]));
  return `<span class="scPill ${k}">${safe}</span>`;
}
function _scDb(x){
  if(!isFinite(x) || x<=0) return "-∞";
  return (20*Math.log10(x)).toFixed(2);
}

/* ===============================
   QC Preset Store (user editable)
   - defaults live in CFG.QC_PRESETS
   - user overrides/additions stored in localStorage
================================ */
const LS_QC_PRESETS_KEY = "BWFJ_QC_PRESETS_V1";

/**
 * Preset storage
 * - Prefer localStorage (simple, synchronous)
 * - Fallback to IndexedDB when localStorage is blocked (common in strict / file:// environments)
 *  ※アプリ化時は、ここをアプリ内ストレージ実装へ差し替え予定
 */
const QC_IDB_DB = "BWFJ_EDITOR_DB_V1";
const QC_IDB_STORE = "kv";
const _qcIdb = { openPromise: null, db: null, disabled: false, err: "" };

function _qcCanUseLocalStorage(){
  try{
    const k="__BWFJ_LS_TEST__";
    localStorage.setItem(k,"1");
    localStorage.removeItem(k);
    return true;
  }catch(_){
    return false;
  }
}

function _qcIdbEnsure(){
  if(_qcIdb.disabled) return Promise.reject(new Error(_qcIdb.err || "IndexedDB disabled"));
  if(_qcIdb.db) return Promise.resolve(_qcIdb.db);
  if(_qcIdb.openPromise) return _qcIdb.openPromise;

  _qcIdb.openPromise = new Promise((resolve, reject)=>{
    try{
      const req = indexedDB.open(QC_IDB_DB, 1);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if(!db.objectStoreNames.contains(QC_IDB_STORE)){
          db.createObjectStore(QC_IDB_STORE, { keyPath: "k" });
        }
      };
      req.onsuccess = ()=>{
        _qcIdb.db = req.result;
        _qcIdb.err = "";
        resolve(_qcIdb.db);
      };
      req.onerror = ()=>{
        _qcIdb.disabled = true;
        _qcIdb.err = req.error?.message || "IndexedDB open failed";
        reject(req.error || new Error(_qcIdb.err));
      };
    }catch(e){
      _qcIdb.disabled = true;
      _qcIdb.err = e?.message || String(e);
      reject(e);
    }
  });

  return _qcIdb.openPromise;
}

function _qcIdbGet(key){
  return _qcIdbEnsure().then(db=>new Promise((resolve, reject)=>{
    try{
      const tx = db.transaction(QC_IDB_STORE, "readonly");
      const st = tx.objectStore(QC_IDB_STORE);
      const r = st.get(String(key));
      r.onsuccess = ()=> resolve(r.result ? r.result.v : null);
      r.onerror = ()=> reject(r.error || new Error("IndexedDB get failed"));
    }catch(e){ reject(e); }
  }));
}
function _qcIdbSet(key, value){
  return _qcIdbEnsure().then(db=>new Promise((resolve, reject)=>{
    try{
      const tx = db.transaction(QC_IDB_STORE, "readwrite");
      const st = tx.objectStore(QC_IDB_STORE);
      const r = st.put({k:String(key), v:String(value)});
      r.onsuccess = ()=> resolve(true);
      r.onerror = ()=> reject(r.error || new Error("IndexedDB set failed"));
    }catch(e){ reject(e); }
  }));
}

function _qcParsePresetPayload(raw){
  if(!raw) return [];
  const obj = JSON.parse(raw);
  const list = Array.isArray(obj?.presets) ? obj.presets : (Array.isArray(obj) ? obj : []);
  return (Array.isArray(list) ? list : [])
    .filter(p=>p && typeof p.id==="string")
    .map(p=>{
      // 旧形式（silenceAllowSec/silenceWarnSec 等）も読み込めるようにしつつ、新形式（min/max）へ正規化
      const maxSecRaw =
        (p.silenceMaxSec!=null) ? Number(p.silenceMaxSec)
        : (p.silenceAllowSec!=null) ? Number(p.silenceAllowSec)
        : (p.silenceWarnSec!=null) ? Number(p.silenceWarnSec)
        : 0.5;

      const minSecRaw =
        (p.silenceMinSec!=null) ? Number(p.silenceMinSec)
        : 0.0;

      const silMin = (isFinite(minSecRaw) && minSecRaw >= 0) ? minSecRaw : 0.0;
      const silMax0 = (isFinite(maxSecRaw) && maxSecRaw >= 0) ? maxSecRaw : 0.5;
      const silMax = (silMax0 < silMin) ? silMin : silMax0;

      return ({
        id: String(p.id),
        name: String(p.name||"カスタム"),
        targetLufs: (p.targetLufs==null? -24 : Number(p.targetLufs)),
        tolLufs: (p.tolLufs==null? 1.0 : Number(p.tolLufs)),
        maxTruePeakDb: (p.maxTruePeakDb==null? -1.0 : Number(p.maxTruePeakDb)),
        allowedSampleRates: Array.isArray(p.allowedSampleRates) ? p.allowedSampleRates.map(n=>Number(n)).filter(n=>isFinite(n)) : [],
        allowedBits: Array.isArray(p.allowedBits) ? p.allowedBits.map(n=>Number(n)).filter(n=>isFinite(n)) : [],
        allowedChannels: Array.isArray(p.allowedChannels) ? p.allowedChannels.map(n=>Number(n)).filter(n=>isFinite(n)) : [],
        silenceMinSec: silMin,
        silenceMaxSec: silMax,
        __origin: "user",
      });
    });
}


function _qcParsePresetOrder(raw){
  if(!raw) return null;
  try{
    const obj = JSON.parse(raw);
    if(Array.isArray(obj?.order)){
      return obj.order.map(x=>String(x)).filter(x=>x);
    }
  }catch(_){}
  return null;
}

function _qcNormalizePresetOrder(order, allIds){
  const ids = Array.isArray(allIds) ? allIds.map(x=>String(x)).filter(x=>x) : [];
  const setAll = new Set(ids);
  const base = Array.isArray(order) ? order.map(x=>String(x)).filter(x=>x) : [];
  const out = [];
  const seen = new Set();
  for(const id of base){
    if(!setAll.has(id)) continue;
    if(seen.has(id)) continue;
    seen.add(id); out.push(id);
  }
  for(const id of ids){
    if(seen.has(id)) continue;
    seen.add(id); out.push(id);
  }
  return out;
}


function _qcPresetEqCore(a,b){
  if(!a||!b) return false;
  const numEq = (x,y)=> (isFinite(x)&&isFinite(y) ? Math.abs(Number(x)-Number(y))<1e-9 : String(x)===String(y));
  const arrEq = (x,y)=>{
    const ax = Array.isArray(x)? x.map(n=>Number(n)).filter(n=>isFinite(n)).sort((p,q)=>p-q) : [];
    const ay = Array.isArray(y)? y.map(n=>Number(n)).filter(n=>isFinite(n)).sort((p,q)=>p-q) : [];
    if(ax.length!==ay.length) return false;
    for(let i=0;i<ax.length;i++){ if(!numEq(ax[i],ay[i])) return false; }
    return true;
  };
  return (
    numEq(a.targetLufs,b.targetLufs) &&
    numEq(a.tolLufs,b.tolLufs) &&
    numEq(a.maxTruePeakDb,b.maxTruePeakDb) &&
    arrEq(a.allowedSampleRates,b.allowedSampleRates) &&
    arrEq(a.allowedBits,b.allowedBits) &&
    arrEq(a.allowedChannels,b.allowedChannels) &&
    numEq(a.silenceMinSec,b.silenceMinSec) &&
    numEq(a.silenceMaxSec,b.silenceMaxSec)
  );
}

/**
 * user preset ids must never collide with default preset ids.
 * If a collision exists (typically due to older bugs), we migrate:
 *   - if identical to default core settings -> drop (redundant)
 *   - else -> assign a new user id (keep name/settings)
 */
function _qcMigrateUserPresets_NoDefaultIdCollision(list){
  const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
  const defIds = new Set(defaults.map(p=>p.id));
  const defMap = new Map(defaults.map(p=>[p.id,p]));
  const out = [];
  let migrated = false;

  for(const p of (Array.isArray(list)?list:[])){
    if(!p || typeof p.id!=="string") continue;
    if(defIds.has(p.id)){
      const d = defMap.get(p.id);
      if(d && _qcPresetEqCore(p,d)){
        migrated = true; // redundant override
        continue;
      }
      const newId = _qcMakeNewId();
      out.push({...p, id:newId});
      migrated = true;
    }else{
      out.push(p);
    }
  }
  return {list: out, migrated};
}

function _qcLoadUserPresets(){
  // 1) localStorage (best effort)
  if(_qcCanUseLocalStorage()){
    try{
      const raw = localStorage.getItem(LS_QC_PRESETS_KEY);
      const parsed = _qcParsePresetPayload(raw);
      const ord = _qcParsePresetOrder(raw);
      if(Array.isArray(ord)) state.qcPresetOrder = ord;
      return parsed;
    }catch(e){
      try{ log("WARN: プリセット読み込み失敗（localStorage）: "+(e?.message||e)); }catch(_){}
    }
  }

  // 2) IndexedDB fallback (async)
  //    ※この関数は同期で返す必要があるため、まず空配列を返し、後で反映する
  _qcIdbGet(LS_QC_PRESETS_KEY).then(raw=>{
    try{
      const parsed = _qcParsePresetPayload(raw);
      const ord = _qcParsePresetOrder(raw);
      if(Array.isArray(ord)) state.qcPresetOrder = ord;

      const list = parsed;
      if(Array.isArray(list)){
        // Avoid clobbering user edits that happened before async IDB hydration finishes
        if(state.qcUserPresetsDirty){
          try{ log("INFO: IDBプリセット反映をスキップ（既に編集あり）"); }catch(_){}
          return;
        }

        state.qcUserPresets = list;
        state.qcUserPresetsHydrated = true;

        // Normalize order + initial preset = first
        try{
          const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
          const mergedIds = [...defaults.map(d=>d.id), ...list.map(p=>p.id)].filter(Boolean);
          const norm = _qcNormalizePresetOrder(state.qcPresetOrder, mergedIds);
          state.qcPresetOrder = norm;
          state.qcPresetId = norm[0] || (CFG.QC_DEFAULT_PRESET_ID || mergedIds[0] || null);
          // persist updated order (best effort)
          try{ _qcSaveUserPresets(state.qcUserPresets); }catch(_){}
        }catch(_){}

        // UIを最新化（モーダルが開いている/開いていない両方に対応）
        try{
          _scPopulatePresetSelect();
          if(state.qcPresetId && $("sc_preset")) $("sc_preset").value = state.qcPresetId;
          _scUpdatePresetDesc();
          if(document.getElementById("stdCheckDialog")?.open){
            try{ _scRenderTargets(_scGetPresetById(state.qcPresetId)); }catch(_){ }
            if(state.qcHasRun) _scRunMeasureAndRender({switchToResults:false}); else _scResetResultsBlank();
          }
          if($("sc_presetMgr") && $("sc_presetMgr").style.display==="block") _scPresetMgrFillFromCurrent(false);
        }catch(_){}
      }
    }catch(e){
      try{ log("WARN: プリセット読み込み失敗（IndexedDB）: "+(e?.message||e)); }catch(_){}
    }
  }).catch(_=>{ /* ignore */ });

  return [];
}

function _qcSaveUserPresets(list){
  const safe = Array.isArray(list) ? list : [];
  const ord = Array.isArray(state.qcPresetOrder) ? state.qcPresetOrder : [];
  const payload = JSON.stringify({version:2, presets:safe, order:ord});

  // 1) localStorage
  if(_qcCanUseLocalStorage()){
    try{
      localStorage.setItem(LS_QC_PRESETS_KEY, payload);
      state.qcPresetSaveError = "";
      return true;
    }catch(e){
      state.qcPresetSaveError = (e && e.message) ? e.message : String(e);
      try{ log("WARN: プリセット保存失敗（localStorage）: "+state.qcPresetSaveError); }catch(_){}
      // fallback below
    }
  }

  // 2) IndexedDB fallback (async write)
  if(typeof indexedDB !== "undefined"){
    _qcIdbSet(LS_QC_PRESETS_KEY, payload).then(()=>{
      state.qcPresetSaveError = "";
      try{ log("INFO: プリセット保存（IndexedDB）"); }catch(_){}
    }).catch(e=>{
      state.qcPresetSaveError = (e && e.message) ? e.message : String(e);
      try{ log("WARN: プリセット保存失敗（IndexedDB）: "+state.qcPresetSaveError); }catch(_){}
    });
    // “ブラウザ内保存”としては成立するため、同期返り値は true 扱い
    return true;
  }

  // no storage
  if(!state.qcPresetSaveError) state.qcPresetSaveError = "この環境では保存できません（localStorage/IndexedDB）";
  return false;
}

function _qcPresetStoreHint(){ return ""; }


function _qcEnsureLoaded(){
  if(state.qcUserPresetsLoaded) return;
  state.qcUserPresetsLoaded = true;
  if(!Array.isArray(state.qcPresetOrder)) state.qcPresetOrder = [];
  state.qcUserPresets = _qcLoadUserPresets();

  // Normalize order against currently known presets (defaults + user)
  try{
    const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
    const user = Array.isArray(state.qcUserPresets) ? state.qcUserPresets : [];
    const userMap = new Map(user.map(p=>[p.id, p]));
    const mergedIds = [];

    for(const d of defaults){
      mergedIds.push(String(d.id));
    }
    for(const u of user){
      if(!u || typeof u.id!=="string") continue;
      if(!mergedIds.includes(u.id)) mergedIds.push(u.id);
    }

    const norm = _qcNormalizePresetOrder(state.qcPresetOrder, mergedIds);
    const changed = JSON.stringify(norm) !== JSON.stringify(state.qcPresetOrder);
    state.qcPresetOrder = norm;

    // 初期プリセット = 並び順の先頭（起動時は常に先頭を採用）
    state.qcPresetId = norm[0] || (CFG.QC_DEFAULT_PRESET_ID || mergedIds[0] || null);

    if(changed){
      try{ _qcSaveUserPresets(state.qcUserPresets); }catch(_){}
    }
  }catch(_){}

  // warmup IDB so first save feels instant
  try{ if(typeof indexedDB !== "undefined") _qcIdbEnsure().catch(()=>{}); }catch(_){}
}

function _qcGetAllPresets(){
  _qcEnsureLoaded();
  const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
  const user = Array.isArray(state.qcUserPresets) ? state.qcUserPresets : [];
  const userMap = new Map(user.map(p=>[p.id, {...p, __origin:"user"}]));
  const defIds = defaults.map(p=>p.id);
  const merged = [];

  // keep default order, but allow user override by same id
  for(const d of defaults){
    const u = userMap.get(d.id);
    merged.push(u ? {...u} : {...d, __origin:"default"});
  }
  // append user-only presets
  for(const u of user){
    if(!defIds.includes(u.id)){
      merged.push({...u, __origin:"user"});
    }
  }

  // apply persisted order (defaults + user)
  try{
    const ord = _qcNormalizePresetOrder(state.qcPresetOrder, merged.map(p=>p.id));
    const map = new Map(merged.map(p=>[p.id,p]));
    const out = [];
    for(const id of ord){
      const pp = map.get(id);
      if(pp) out.push(pp);
      map.delete(id);
    }
    // append any leftovers (shouldn't happen)
    for(const pp of map.values()) out.push(pp);
    return out;
  }catch(_){
    return merged;
  }
}

function _qcNormalizePreset(p){
  const id = String((p && p.id)!=null ? p.id : _qcMakeNewId());
  const name = String((p && p.name) || "カスタム");
  const targetLufs = (p && p.targetLufs!=null) ? Number(p.targetLufs) : -24;
  const tolLufs = (p && p.tolLufs!=null) ? Number(p.tolLufs) : 1.0;
  const maxTruePeakDb = (p && p.maxTruePeakDb!=null) ? Number(p.maxTruePeakDb) : -1.0;

  const allowedSampleRates = Array.isArray(p?.allowedSampleRates) ? p.allowedSampleRates.map(n=>Number(n)).filter(n=>isFinite(n)) : [];
  const allowedBits = Array.isArray(p?.allowedBits) ? p.allowedBits.map(n=>Number(n)).filter(n=>isFinite(n)) : [];
  const allowedChannels = Array.isArray(p?.allowedChannels) ? p.allowedChannels.map(n=>Number(n)).filter(n=>isFinite(n)) : [];

  const maxRaw =
    (p && p.silenceMaxSec!=null) ? Number(p.silenceMaxSec)
    : (p && p.silenceAllowSec!=null) ? Number(p.silenceAllowSec)
    : 0.5;

  const minRaw =
    (p && p.silenceMinSec!=null) ? Number(p.silenceMinSec)
    : 0.0;

  const silMin = (isFinite(minRaw) && minRaw >= 0) ? minRaw : 0.0;
  const silMax0 = (isFinite(maxRaw) && maxRaw >= 0) ? maxRaw : 0.5;
  const silMax = (silMax0 < silMin) ? silMin : silMax0;

  return _scStripPresetMeta({
    id, name,
    targetLufs, tolLufs, maxTruePeakDb,
    allowedSampleRates, allowedBits, allowedChannels,
    silenceMinSec: silMin,
    silenceMaxSec: silMax,
  });

}

function _qcImportUserPresetsFromObject(obj){
  // Import QC presets from JSON and MERGE into existing user presets (do not overwrite).
  const list = Array.isArray(obj?.presets) ? obj.presets : (Array.isArray(obj) ? obj : []);
  const sanitized = (Array.isArray(list) ? list : [])
    .filter(p=>p!=null)
    .map(_qcNormalizePreset);

  const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
  const defIds = new Set(defaults.map(p=>p.id));
  // For safety: never import into a default id directly (avoid unintended override). We'll re-id it.
  const incoming = sanitized.map(p=>{
    if(p && typeof p.id==="string" && defIds.has(p.id)){
      const newId = _qcMakeNewId();
      const newName = String(p.name||"カスタム") + "（インポート）";
      return {...p, id:newId, name:newName};
    }
    return p;
  });
_qcEnsureLoaded();
  const existing = Array.isArray(state.qcUserPresets) ? state.qcUserPresets.slice() : [];
  const map = new Map(existing.map(p=>[p.id, p]));
  const next = existing.slice();
  const addedIds = [];

  for(const p0 of (Array.isArray(incoming)?incoming:[])){
    if(!p0 || typeof p0.id!=="string") continue;
    const p = p0;
    if(map.has(p.id)){
      const ex = map.get(p.id);
      // If completely identical to existing, skip (no need to duplicate)
      if(ex && _qcPresetEqCore(ex, p)) continue;
      // Collision: keep existing, import as new preset with new ID
      const newId = _qcMakeNewId();
      const baseName = (typeof p.name==="string" && p.name.trim()) ? p.name.trim() : "プリセット";
      const newName = baseName + "（インポート）";
      const pp = {...p, id:newId, name:newName};
      next.push(pp);
      map.set(pp.id, pp);
      addedIds.push(pp.id);
    }else{
      next.push(p);
      map.set(p.id, p);
      addedIds.push(p.id);
    }
  }

  state.qcUserPresets = next;
  state.qcUserPresetsDirty = true;
  // append imported presets to order
  if(!Array.isArray(state.qcPresetOrder)) state.qcPresetOrder = [];
  for(const id of addedIds){ if(id && !state.qcPresetOrder.includes(id)) state.qcPresetOrder.push(id); }
  const ok = _qcSaveUserPresets(next);

  // Auto-select the first imported/added preset if available.
  const firstId = addedIds[0] || null;
  if(firstId){
    state.qcPresetId = firstId;
  }
  return {ok, count: addedIds.length, total: next.length, firstId, addedIds};
}

function _qcExportUserPresets(selectedIds){
  _qcEnsureLoaded();
  const all = Array.isArray(state.qcUserPresets) ? state.qcUserPresets : [];
  let presets = all;
  if(Array.isArray(selectedIds) && selectedIds.length){
    const set = new Set(selectedIds);
    presets = all.filter(p=>set.has(p.id));
  }
  const payload = {version:1, presets};
  if(!presets.length){ alert("エクスポートするプリセットがありません。"); return; }
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  // allow user to choose save location when supported (File System Access API)
  _saveJsonWithFallback(blob, "BWFJ_qc_presets.json");
}

function _qcWirePresetExportSelector(){
  const ov = $("scExportSelDialog");
  if(!ov || ov.dataset.wired) return;
  ov.dataset.wired = "1";

  // click on backdrop closes
  ov.addEventListener("click", (e)=>{
    if(e.target === ov) _qcClosePresetExportSelector();
  });
  ov.addEventListener("cancel", (e)=>{ e.preventDefault(); _qcClosePresetExportSelector(); });

  $("sc_es_all")?.addEventListener("click", ()=>{
    ov.querySelectorAll('input[type="checkbox"][data-id]').forEach(cb=>{ cb.checked = true; });
  });
  $("sc_es_none")?.addEventListener("click", ()=>{
    ov.querySelectorAll('input[type="checkbox"][data-id]').forEach(cb=>{ cb.checked = false; });
  });
  $("sc_es_export")?.addEventListener("click", ()=>{
    const ids = Array.from(ov.querySelectorAll('input[type="checkbox"][data-id]'))
      .filter(cb=>cb.checked)
      .map(cb=>cb.dataset.id)
      .filter(Boolean);
    if(ids.length===0){ alert("エクスポートするプリセットを選択してください。"); return; }
    _qcExportUserPresets(ids);
    _qcClosePresetExportSelector();
    window.safeToast("プリセットをエクスポートしました。","ok");
  });
}

function _qcOpenPresetExportSelector(){
  _qcEnsureLoaded();
  _qcWirePresetExportSelector();
  const list = Array.isArray(state.qcUserPresets) ? state.qcUserPresets : [];
  if(list.length===0){ alert("エクスポートできるカスタムプリセットがありません。"); return; }
  // If 0 or 1, export immediately (no need to choose)
  if(list.length<=1){
    _qcExportUserPresets(list.map(p=>p.id));
    window.safeToast("プリセットをエクスポートしました。","ok");
    return;
  }
  const ov = $("scExportSelDialog");
  const box = $("sc_es_list");
  if(!ov || !box){
    _qcExportUserPresets(list.map(p=>p.id));
    window.safeToast("プリセットをエクスポートしました。","ok");
    return;
  }
  box.innerHTML = "";
  for(const p of list){
    const row = document.createElement("div");
    row.className = "item";
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = true;
    cb.dataset.id = p.id;
    cb.id = "sc_es_" + p.id;

    const wrap = document.createElement("div");
    wrap.style.minWidth = "0";

    const lab = document.createElement("label");
    lab.htmlFor = cb.id;
    lab.textContent = (p.name && String(p.name).trim()) ? p.name : p.id;

    const meta = document.createElement("div");
    meta.className = "mutedSmall";
    meta.textContent = p.id;

    wrap.appendChild(lab);
    wrap.appendChild(meta);
    row.appendChild(cb);
    row.appendChild(wrap);
    box.appendChild(row);
  }
  try{ if(!ov.open) ov.showModal(); }catch(e){ /* ignore */ }
}

function _qcClosePresetExportSelector(){
  const ov = $("scExportSelDialog");
  if(!ov) return;
  try{ if(ov.open) ov.close(); }catch(e){ /* ignore */ }
}


/* ===== cmcd preset export selector (選択式) ===== */
function _cmcdEnsureLoaded(){
  try{ _cmcdLoadUserPresets(); }catch(_){}
  try{ _cmcdLoadPresetOrder(); }catch(_){}
}

async function _cmcdExportUserPresets(ids){
  _cmcdEnsureLoaded();
  const list = Array.isArray(state.cmcdUserPresets) ? state.cmcdUserPresets : [];
  const ord = Array.isArray(state.cmcdPresetOrder) ? state.cmcdPresetOrder : list.map(p=>p.id);
  const set = new Set((ids||[]).filter(Boolean));
  const presets = list.filter(p=>set.has(p.id));
  const order = ord.filter(id=>set.has(id));
  for(const id of set){ if(!order.includes(id)) order.push(id); }
  const payload = JSON.stringify({kind:"cmcd_presets", version:1, presets, order}, null, 2);
  await downloadTextFile(`WavCue_cmcd_presets_${_tsStamp()}.json`, payload);
}

function _cmcdWirePresetExportSelector(){
  const ov = $("cmcdExportSelDialog");
  if(!ov || ov.dataset.wired) return;
  ov.dataset.wired = "1";

  ov.addEventListener("click", (e)=>{
    if(e.target === ov) _cmcdClosePresetExportSelector();
  });
  ov.addEventListener("cancel", (e)=>{ e.preventDefault(); _cmcdClosePresetExportSelector(); });

  $("cmcd_es_all")?.addEventListener("click", ()=>{
    ov.querySelectorAll('input[type="checkbox"][data-id]').forEach(cb=>{ cb.checked = true; });
  });
  $("cmcd_es_none")?.addEventListener("click", ()=>{
    ov.querySelectorAll('input[type="checkbox"][data-id]').forEach(cb=>{ cb.checked = false; });
  });
  $("cmcd_es_export")?.addEventListener("click", async()=>{
    const ids = Array.from(ov.querySelectorAll('input[type="checkbox"][data-id]'))
      .filter(cb=>cb.checked)
      .map(cb=>cb.dataset.id)
      .filter(Boolean);
    if(ids.length===0){ alert("エクスポートするプリセットを選択してください。"); return; }
    await _cmcdExportUserPresets(ids);
    _cmcdClosePresetExportSelector();
    window.safeToast && window.safeToast("cmcdプリセットをエクスポートしました。","ok");
  });
}

function _cmcdClosePresetExportSelector(){
  const ov = $("cmcdExportSelDialog");
  if(!ov) return;
  try{ if(ov.open) ov.close(); }catch(e){ /* ignore */ }
}

function _cmcdOpenPresetExportSelector(){
  _cmcdEnsureLoaded();
  _cmcdWirePresetExportSelector();
  const list = Array.isArray(state.cmcdUserPresets) ? state.cmcdUserPresets : [];
  if(list.length===0){ alert("エクスポートできるcmcdプリセットがありません。"); return; }
  if(list.length<=1){
    _cmcdExportUserPresets(list.map(p=>p.id));
    window.safeToast && window.safeToast("cmcdプリセットをエクスポートしました。","ok");
    return;
  }
  const ov = $("cmcdExportSelDialog");
  const box = $("cmcd_es_list");
  if(!ov || !box){
    _cmcdExportUserPresets(list.map(p=>p.id));
    window.safeToast && window.safeToast("cmcdプリセットをエクスポートしました。","ok");
    return;
  }
  box.innerHTML = "";
  for(const p of list){
    const row = document.createElement("div");
    row.className = "item";
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = true;
    cb.dataset.id = p.id;
    cb.id = "cmcd_es_" + p.id;

    const wrap = document.createElement("div");
    wrap.style.minWidth = "0";

    const lab = document.createElement("label");
    lab.htmlFor = cb.id;
    lab.textContent = (p.name && String(p.name).trim()) ? p.name : p.id;

    const meta = document.createElement("div");
    meta.className = "mutedSmall";
    meta.textContent = p.id;

    wrap.appendChild(lab);
    wrap.appendChild(meta);

    row.appendChild(cb);
    row.appendChild(wrap);
    box.appendChild(row);
  }
  try{ ov.showModal(); }catch(e){ try{ ov.setAttribute("open",""); }catch(_){} }
}
/* ===== /cmcd preset export selector ===== */


function _qcIsUserPreset(id){
  _qcEnsureLoaded();
  return Array.isArray(state.qcUserPresets) && state.qcUserPresets.some(p=>p.id===id);
}

function _qcUpsertUserPreset(preset){
  _qcEnsureLoaded();
  const list = Array.isArray(state.qcUserPresets) ? state.qcUserPresets : [];
  const idx = list.findIndex(p=>p.id===preset.id);
  const isNew = (idx < 0);
  if(idx>=0) list[idx] = preset;
  else list.push(preset);

  state.qcUserPresets = list;
  state.qcUserPresetsDirty = true;

  // maintain order (new presets append to end)
  if(isNew){
    if(!Array.isArray(state.qcPresetOrder)) state.qcPresetOrder = [];
    if(!state.qcPresetOrder.includes(preset.id)) state.qcPresetOrder.push(preset.id);
  }

  return _qcSaveUserPresets(list);
}

function _qcDeleteUserPreset(id){
  _qcEnsureLoaded();
  const list = Array.isArray(state.qcUserPresets) ? state.qcUserPresets : [];
  const next = list.filter(p=>p.id!==id);
  state.qcUserPresets = next;
  state.qcUserPresetsDirty = true;

  // remove from order for non-default presets; default ids stay in order
  try{
    const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
    const defIds = new Set(defaults.map(p=>p.id));
    if(!defIds.has(id) && Array.isArray(state.qcPresetOrder)){
      state.qcPresetOrder = state.qcPresetOrder.filter(x=>x!==id);
    }
  }catch(_){}

  return _qcSaveUserPresets(next);
}

function _qcMakeNewId(){
  try{
    const r = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now());
    return "user_"+r.replace(/[^a-zA-Z0-9_]/g,"").slice(0,32);
  }catch(_){
    return "user_"+String(Date.now());
  }
}

function _scParseCsvInts(str){
  if(!str) return [];
  return String(str).split(",").map(s=>parseInt(s.trim(),10)).filter(n=>Number.isFinite(n));
}

function _scGetPresetById(id){
  const list = _qcGetAllPresets();
  return list.find(p=>p.id===id) || list[0] || null;
}
function _scPopulatePresetSelect(){
  const list = _qcGetAllPresets();

  // main preset select (for checking)
  const sel = $("sc_preset");
  if(sel){
    sel.innerHTML = "";
    for(const p of list){
      const opt = document.createElement("option");
      opt.value = p.id;
      const isCustom = (p.__origin==="user");
      opt.textContent = p.name + (isCustom ? "（カスタム）" : "");
      sel.appendChild(opt);
    }
    const cur = state.qcPresetId || CFG.QC_DEFAULT_PRESET_ID || (list[0] && list[0].id);
    if(cur) sel.value = cur;
  }

  // preset pick (for editing)
  const pick = $("sc_pm_pick");
  if(pick){
    const keep = (pick.value||"").trim();
    pick.innerHTML = "";
    const head = document.createElement("option");
    head.value = "";
    head.textContent = "プリセットを選択して編集";
    head.disabled = true;
    head.hidden = true;
    pick.appendChild(head);
    const optNew = document.createElement("option");
    optNew.value = "__new__";
    optNew.textContent = "新規作成";
    optNew.disabled = true;
    optNew.hidden = true;
    pick.appendChild(optNew);
    for(const p of list){
      const opt = document.createElement("option");
      opt.value = p.id;
      const isCustom = (p.__origin==="user");
      opt.textContent = p.name + (isCustom ? "（カスタム）" : "");
      pick.appendChild(opt);
    }
    // restore selection if possible
    if(keep==="__new__") pick.value = "__new__";
    else if(keep && list.some(p=>p.id===keep)) pick.value = keep;
    else pick.value = "";
    _scPmUpdatePickVisual();
  }
  try{ if(_scPmIsSortOpen()) _scPmRenderSortList(); }catch(_){ }
}
function _scUpdatePresetDesc(){ /* プリセット説明UIは使用しない */ }
function _scComputeHeadTailSilence(buffer, startSec, endSec, threshDb){
  const sr = buffer.sampleRate;
  const nch = buffer.numberOfChannels;
  const start = Math.max(0, Math.floor(startSec*sr));
  const end = Math.min(buffer.length, Math.floor(endSec*sr));
  if(end <= start+1) return {hasSound:false, headSec:0, tailSec:0};

  const td = (isFinite(threshDb) ? threshDb : (CFG?.STDCHK_SILENCE_THRESHOLD_DB ?? -60));
  const thresh = Math.pow(10, td/20); // RMS amplitude threshold
  const block = Math.max(1, Math.floor(sr * 0.010)); // 10ms

  const total = end - start;
  const blocks = Math.max(1, Math.ceil(total / block));

  let first = -1;
  let last = -1;

  for(let bi=0; bi<blocks; bi++){
    const s = start + bi*block;
    const e = Math.min(end, s+block);
    let sum = 0;
    const n = Math.max(1, (e - s) * nch);
    for(let ch=0; ch<nch; ch++){
      const d = buffer.getChannelData(ch);
      for(let i=s; i<e; i++){
        const v = d[i];
        sum += v*v;
      }
    }
    const rms = Math.sqrt(sum / n);
    if(rms >= thresh){
      if(first < 0) first = bi;
      last = bi;
    }
  }

  if(first < 0){
    const dur = (end - start) / sr;
    return {hasSound:false, headSec:dur, tailSec:dur};
  }

  const soundStart = start + first*block;
  const soundEnd = Math.min(end, start + (last+1)*block);
  const headSec = (soundStart - start) / sr;
  const tailSec = (end - soundEnd) / sr;

  return {hasSound:true, headSec, tailSec};
}

function _scDetectEffectiveMono(buffer, startSec, endSec){
  try{
    if(!buffer || buffer.numberOfChannels < 2) return {isEffectiveMono:false};
    const sr = buffer.sampleRate;
    const start = Math.max(0, Math.floor(startSec*sr));
    const end = Math.min(buffer.length, Math.floor(endSec*sr));
    const nFrames = end - start;
    if(nFrames <= sr*0.1) return {isEffectiveMono:false}; // too short (<100ms)

    const L = buffer.getChannelData(0);
    const R = buffer.getChannelData(1);

    // downsample for speed
    const maxSamples = 200000; // plenty for stable stats
    const step = Math.max(1, Math.floor(nFrames / maxSamples));

    let sumLL=0, sumRR=0, sumLR=0, sumDiff=0;
    let n=0;

    for(let i=start; i<end; i+=step){
      const l = L[i];
      const r = R[i];
      sumLL += l*l;
      sumRR += r*r;
      sumLR += l*r;
      const d = l - r;
      sumDiff += d*d;
      n++;
    }
    if(n<10) return {isEffectiveMono:false};

    const rms = Math.sqrt((sumLL + sumRR) / (2*n));
    if(!(rms>1e-5)) return {isEffectiveMono:false}; // near silence

    const corr = sumLR / Math.sqrt((sumLL||1e-12) * (sumRR||1e-12));
    const diffRms = Math.sqrt(sumDiff / n);
    const diffRatio = diffRms / (rms + 1e-12);

    // "effective mono" = L and R are almost identical (dual-mono)
    const isEffectiveMono = (corr > 0.995) && (diffRatio < 0.03);

    return {isEffectiveMono, corr, diffRatio};
  }catch(e){
    return {isEffectiveMono:false, error:String(e && (e.message||e))};
  }
}

function _scFormatCh(n){
  return (n===1) ? "モノラル" : (n===2) ? "ステレオ" : `${n} ch`;
}
function _scOverallTag(summary){
  if(summary.failCount>0) return _scPill("ng", "NG");
  if(summary.warnCount>0) return _scPill("warn", "注意");
  return _scPill("ok", "OK");
}


function _scStripPresetMeta(p){
  // remove helper fields for storage
  const q = {...p};
  delete q.__origin;
  delete q.__meta;
  return q;
}


function _scPresetMgrSetLocked(locked){
  const mgr = $("sc_presetMgr");
  if(!mgr) return;
  mgr.classList.toggle("isLocked", !!locked);

  const fieldIds = ["sc_pm_name","sc_pm_target","sc_pm_tol","sc_pm_tpmax","sc_pm_srsel","sc_pm_bitssel","sc_pm_chsel","sc_pm_silmin","sc_pm_silmax"];
  for(const id of fieldIds){
    const el = $(id);
    if(el) el.disabled = !!locked;
  }
  // action buttons that should require an active edit target
  const actionIds = ["sc_pm_clone","sc_pm_save","sc_pm_delete"];
  for(const id of actionIds){
    const el = $(id);
    if(el) el.disabled = !!locked;
  }
}

function _scPresetMgrResetBlank(){
  if($("sc_pm_id")) $("sc_pm_id").value = "";
  if($("sc_pm_desc")) $("sc_pm_desc").value = "";
  if($("sc_pm_name")) $("sc_pm_name").value = "";

  if($("sc_pm_target")) $("sc_pm_target").value = "";
  if($("sc_pm_tol")) $("sc_pm_tol").value = "";
  if($("sc_pm_tpmax")) $("sc_pm_tpmax").value = "";

  if($("sc_pm_srsel")) $("sc_pm_srsel").value = "";
  if($("sc_pm_bitssel")) $("sc_pm_bitssel").value = "";
  if($("sc_pm_chsel")) $("sc_pm_chsel").value = "";

  if($("sc_pm_silmin")) $("sc_pm_silmin").value = "0.00";
  if($("sc_pm_silmax")) $("sc_pm_silmax").value = "0.50";

  _scSet("sc_pm_hint", "");
}


function _scPmUpdatePickVisual(){
  const pick = $("sc_pm_pick");
  if(!pick) return;
  const v = (pick.value||"").trim();
  const isPh = (!v) || (v==="__new__");
  pick.classList.toggle("isPlaceholder", isPh);
  pick.classList.toggle("isNew", v==="__new__");
}


function _scPmIsSortOpen(){
  const p = $("sc_pm_sortPanel");
  return !!(p && p.dataset.open==="1");
}
function _scPmToggleSortPanel(force){
  const p = $("sc_pm_sortPanel");
  if(!p) return;
  const want = (typeof force==="boolean") ? force : !(p.dataset.open==="1");
  p.dataset.open = want ? "1" : "0";
  p.style.display = want ? "block" : "none";
  if(want){
    try{ _scPmRenderSortList(); }catch(_){}
  }
}
function _scPmRenderSortList(){
  const wrap = $("sc_pm_sortList");
  if(!wrap) return;

  const defaults = (CFG && Array.isArray(CFG.QC_PRESETS)) ? CFG.QC_PRESETS : [];
  const defIds = new Set(defaults.map(p=>p.id));

  const list = _qcGetAllPresets(); // already ordered
  const ids = list.map(p=>p.id);

  // ensure order includes everything shown
  try{
    const norm = _qcNormalizePresetOrder(state.qcPresetOrder, ids);
    state.qcPresetOrder = norm;
    _qcSaveUserPresets(state.qcUserPresets);
  }catch(_){}

  wrap.innerHTML = "";
  if(!list.length){
    const empty = document.createElement("div");
    empty.className = "muted";
    empty.style.fontSize = "12px";
    empty.textContent = "プリセットがありません。";
    wrap.appendChild(empty);
    return;
  }

  for(const p of list){
    const row = document.createElement("div");
    row.className = "scSortItem";
    row.draggable = true;
    row.dataset.id = p.id;

    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.alignItems = "center";
    left.style.gap = "10px";

    const handle = document.createElement("div");
    handle.className = "muted";
    handle.style.fontSize = "14px";
    handle.style.cursor = "grab";
    handle.textContent = "≡";
    left.appendChild(handle);

    const name = document.createElement("div");
    name.style.display = "flex";
    name.style.flexDirection = "column";
    name.style.gap = "2px";

    const t = document.createElement("div");
    t.textContent = p.name || p.id;
    name.appendChild(t);

    const sub = document.createElement("div");
    sub.className = "muted";
    sub.style.fontSize = "11px";
    const isDef0 = defIds.has(p.id);
    const isOverride0 = _qcIsUserPreset(p.id);
    sub.textContent = isDef0 ? (isOverride0 ? "デフォルト（編集済み）" : "デフォルト") : "カスタム";
    name.appendChild(sub);

    left.appendChild(name);

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.gap = "8px";
    right.style.alignItems = "center";

    const del = document.createElement("button");
    del.type = "button";
    del.className = "btn warn";
    del.style.borderRadius = "999px";
    del.style.padding = "6px 10px";
    del.style.fontSize = "12px";

    const isDef = defIds.has(p.id);
    const isOverride = _qcIsUserPreset(p.id);

    if(isDef && !isOverride){
      del.textContent = "削除";
      del.disabled = true;
      del.style.opacity = "0.4";
      del.title = "デフォルトは削除できません";
    }else if(isDef && isOverride){
      del.textContent = "リセット";
      del.title = "デフォルト内容へ戻します（編集内容を削除）";
      del.addEventListener("click", (e)=>{
        e.preventDefault(); e.stopPropagation();
        if(!confirm("このデフォルトプリセットの編集内容をリセットします。よろしいですか？")) return;
        _qcDeleteUserPreset(p.id); // removes override only, order stays
        _scPopulatePresetSelect();
        if($("sc_pm_pick")) $("sc_pm_pick").value = p.id;
        _scPresetMgrFillFromCurrent(false);
        window.safeToast && window.safeToast("リセットしました。","ok");
      });
    }else{
      del.textContent = "削除";
      del.addEventListener("click", (e)=>{
        e.preventDefault(); e.stopPropagation();
        const id = p.id;
        if(!id) return;
        if(!confirm("このプリセット（カスタム）を削除します。よろしいですか？")) return;
        _qcDeleteUserPreset(id);

        // if current preset was deleted, fall back to first in order
        if(state.qcPresetId === id){
          const all = _qcGetAllPresets();
          const first = (all[0] && all[0].id) || (CFG.QC_DEFAULT_PRESET_ID || null);
          state.qcPresetId = first;
        }

        _scPopulatePresetSelect();
        try{ if(_scPmIsSortOpen()) _scPmRenderSortList(); }catch(_){}
        window.safeToast && window.safeToast("削除しました。","ok");
      });
    }

    right.appendChild(del);

    row.appendChild(left);
    row.appendChild(right);
    wrap.appendChild(row);
  }

  _scPmWireDragSort(wrap);
}

function _scPmWireDragSort(container){
  if(!container || container.dataset.wired==="1") return;
  container.dataset.wired = "1";

  let dragging = null;

  container.addEventListener("dragstart", (e)=>{
    const item = e.target && e.target.closest ? e.target.closest(".scSortItem") : null;
    if(!item) return;
    dragging = item;
    item.classList.add("dragging");
    try{ e.dataTransfer.effectAllowed = "move"; }catch(_){}
    try{ e.dataTransfer.setData("text/plain", item.dataset.id||""); }catch(_){}
  });

  container.addEventListener("dragend", ()=>{
    if(dragging) dragging.classList.remove("dragging");
    for(const el of container.querySelectorAll(".scSortItem.dragOver")) el.classList.remove("dragOver");
    dragging = null;
    _scPmCommitSortFromDom(container);
  });

  container.addEventListener("dragover", (e)=>{
    if(!dragging) return;
    e.preventDefault();
    const item = e.target && e.target.closest ? e.target.closest(".scSortItem") : null;
    if(!item || item===dragging) return;

    for(const el of container.querySelectorAll(".scSortItem.dragOver")) el.classList.remove("dragOver");
    item.classList.add("dragOver");

    const rect = item.getBoundingClientRect();
    const before = (e.clientY < rect.top + rect.height/2);
    if(before){
      container.insertBefore(dragging, item);
    }else{
      container.insertBefore(dragging, item.nextSibling);
    }
  });

  container.addEventListener("drop", (e)=>{
    e.preventDefault();
    for(const el of container.querySelectorAll(".scSortItem.dragOver")) el.classList.remove("dragOver");
    _scPmCommitSortFromDom(container);
  });
}

function _scPmCommitSortFromDom(container){
  try{
    const ids = Array.from(container.querySelectorAll(".scSortItem"))
      .map(el=>el.dataset.id)
      .filter(Boolean);

    const all = _qcGetAllPresets();
    const allIds = all.map(p=>p.id);
    const norm = _qcNormalizePresetOrder(ids, allIds);

    state.qcPresetOrder = norm;
    _qcSaveUserPresets(state.qcUserPresets);

    _scPopulatePresetSelect(); // refresh dropdowns
    window.safeToast && window.safeToast("並び順を保存しました。","ok");
  }catch(_){}
}
function _scPresetMgrEnterIdle(){
  _qcEnsureLoaded();
  _scPopulatePresetSelect();
  if($("sc_pm_pick")) $("sc_pm_pick").value = "";
  _scPmUpdatePickVisual();
  _scPresetMgrResetBlank();
  _scPresetMgrSetLocked(true);
  try{ _scPmToggleSortPanel(false); }catch(_){ }
}

function _scPresetMgrStartNewBlank(){
  if($("sc_pm_pick")) $("sc_pm_pick").value = "__new__";
  _scPmUpdatePickVisual();
  _scPresetMgrResetBlank();
  _scPresetMgrSetLocked(false);
  if($("sc_pm_clone")) $("sc_pm_clone").disabled = true;
  if($("sc_pm_delete")) $("sc_pm_delete").disabled = true;
  _scSet("sc_pm_hint", "新規プリセットを作成します。必須項目を入力して「保存」してください。 / " + _qcPresetStoreHint());
}

function _scPresetMgrStartEditPreset(id){
  const p = _scGetPresetById(id);
  if(!p){ window.safeToast("プリセットが見つかりません","warn"); return; }
  state.qcPresetId = p.id;
  if($("sc_preset")) $("sc_preset").value = p.id;
  _scUpdatePresetDesc();
  _scPresetMgrFillFromPreset(p, true);
  _scPresetMgrSetLocked(false);
  if($("sc_pm_clone")) $("sc_pm_clone").disabled = false;
  if($("sc_pm_delete")) $("sc_pm_delete").disabled = false;
}

function _scPresetMgrFillFromPreset(p, forceOpen=false){
  const mgr = $("sc_presetMgr");
  if(!mgr) return;
  if(forceOpen) mgr.style.display = "block";
  if(!p) return;

  $("sc_pm_id").value = p.id || "";
  $("sc_pm_desc").value = ""; // UIでは使用しない
  $("sc_pm_name").value = p.name || "";

  $("sc_pm_target").value = (p.targetLufs!=null && isFinite(p.targetLufs)) ? p.targetLufs : "";
  $("sc_pm_tol").value = (p.tolLufs!=null && isFinite(p.tolLufs)) ? p.tolLufs : "";
  $("sc_pm_tpmax").value = (p.maxTruePeakDb!=null && isFinite(p.maxTruePeakDb)) ? p.maxTruePeakDb : "";

  const sr0 = Array.isArray(p.allowedSampleRates) && p.allowedSampleRates.length ? String(p.allowedSampleRates[0]) : "";
  const bd0 = Array.isArray(p.allowedBits) && p.allowedBits.length ? String(p.allowedBits[0]) : "";
  const ch0 = Array.isArray(p.allowedChannels) && p.allowedChannels.length ? String(p.allowedChannels[0]) : "";

  const srs = $("sc_pm_srsel"); if(srs) srs.value = sr0;
  const bds = $("sc_pm_bitssel"); if(bds) bds.value = bd0;
  const chs = $("sc_pm_chsel"); if(chs) chs.value = ch0;

  $("sc_pm_silmin").value = (p.silenceMinSec!=null && isFinite(p.silenceMinSec)) ? p.silenceMinSec : 0.0;
  $("sc_pm_silmax").value = (p.silenceMaxSec!=null && isFinite(p.silenceMaxSec)) ? p.silenceMaxSec : ((p.silenceAllowSec!=null && isFinite(p.silenceAllowSec)) ? p.silenceAllowSec : 0.5);

  const isCustom = _qcIsUserPreset(p.id);
  const originTxt = isCustom ? "このプリセットはカスタム（保存済み）です。" : "このプリセットはデフォルトです。保存すると同じプリセット名でカスタムとして上書きされます。";
  _scSet("sc_pm_hint", originTxt + " / " + _qcPresetStoreHint());
  if($("sc_pm_pick")) $("sc_pm_pick").value = p.id || "";
}

function _scPresetMgrFillFromCurrent(forceOpen=false){
  const p = _scGetPresetById(state.qcPresetId) || _qcGetAllPresets()[0];
  _scPresetMgrFillFromPreset(p, forceOpen);
}

function _scPresetMgrReadForm(idFallback){
  let id = ($("sc_pm_id")?.value || "").trim() || (idFallback||"").trim();
  const isNew = !id;
  if(isNew){
    id = _qcMakeNewId();
    if($("sc_pm_id")) $("sc_pm_id").value = id;
  }

  const name = ($("sc_pm_name")?.value || "").trim() || "カスタム";
  const targetLufsStr = ($("sc_pm_target")?.value ?? "").trim();
  const targetLufs = (targetLufsStr === "") ? NaN : parseFloat(targetLufsStr);

  const tolLufsStr = ($("sc_pm_tol")?.value ?? "").trim();
  const tolLufs = (tolLufsStr === "") ? NaN : parseFloat(tolLufsStr);

  const maxTruePeakDbStr = ($("sc_pm_tpmax")?.value ?? "").trim();
  const maxTruePeakDb = (maxTruePeakDbStr === "") ? NaN : parseFloat(maxTruePeakDbStr);

  if(!isFinite(targetLufs) || !isFinite(tolLufs) || !isFinite(maxTruePeakDb)){
    alert("ラウドネス値 / 許容範囲 / TruePeak 上限 を正しく入力してください。");
    return null;
  }

  const srV = ($("sc_pm_srsel")?.value || "").trim();
  const bdV = ($("sc_pm_bitssel")?.value || "").trim();
  const chV = ($("sc_pm_chsel")?.value || "").trim();

  const allowedSampleRates = srV ? [Number(srV)] : [];
  const allowedBits = bdV ? [Number(bdV)] : [];
  const allowedChannels = chV ? [Number(chV)] : [];

  const silMinStr = ($("sc_pm_silmin")?.value ?? "").trim();
  const silMaxStr = ($("sc_pm_silmax")?.value ?? "").trim();
  const silMin = (silMinStr === "") ? NaN : parseFloat(silMinStr);
  const silMax = (silMaxStr === "") ? NaN : parseFloat(silMaxStr);
  if(!isFinite(silMin) || silMin < 0 || !isFinite(silMax) || silMax < 0){
    alert("無音許容範囲（秒）を正しく入力してください。");
    return null;
  }
  if(silMax < silMin){
    alert("無音許容範囲：最大値は最小値以上にしてください。");
    return null;
  }

  const preset = {
    id, name,
    targetLufs, tolLufs, maxTruePeakDb,
    allowedSampleRates, allowedBits, allowedChannels,
    // silence: min/max (and legacy allow for backward compatibility)
    silenceMinSec: silMin,
    silenceMaxSec: silMax,
    silenceAllowSec: silMax,
    __origin: "user",
  };
  return _scStripPresetMeta(preset);
}



function _scCurrentFileKey(){
  const f = state.file;
  if(!f) return "";
  const lm = (typeof f.lastModified === "number") ? f.lastModified : 0;
  return `${f.name||""}|${f.size||0}|${lm}`;
}

function _scResetResultsBlank(){
  // "チェック"実行までは「結果」列のみ空欄（項目/目標は表示）
  const ids = ["sc_lufs","sc_tp","sc_sr","sc_bd","sc_ch","sc_clip","sc_silence"];
  for(const id of ids){
    try{ _scSet(id, ""); }catch(_){}
  }
}

function _scSetTab(name){
  try{ state.scActiveTab = (name==="preset") ? "preset" : "results"; }catch(_){}
  const btnR = $("sc_tab_results");
  const btnP = $("sc_tab_preset");
  const paneR = $("sc_resultsPane");
  const paneP = $("sc_presetMgr");
  if(!btnR || !btnP || !paneR || !paneP) return;

  const isPreset = (name === "preset");
  btnR.classList.toggle("active", !isPreset);
  btnP.classList.toggle("active", isPreset);
  btnR.setAttribute("aria-selected", String(!isPreset));
  btnP.setAttribute("aria-selected", String(isPreset));

  paneR.style.display = isPreset ? "none" : "block";
  paneP.style.display = isPreset ? "block" : "none";

  if(isPreset){
    try{ _scPresetMgrEnterIdle(); }catch(_){}
  }
}

function _scRunMeasureAndRender(opts){
  opts = opts || {};
  const switchToResults = (opts.switchToResults !== false);
  state.qcHasRun = true;
  const dlg = $("stdCheckDialog");
  // NOTE: batch/headless mode may run QC without opening the dialog.
  // Even when dlg is missing, still compute qcResult and update __wavcueLastQc.
  // UI rendering helpers (_scSet/_scSetHtml) are already no-op when elements are absent.
  if(switchToResults && dlg){
    try{ _scSetTab("results"); }catch(_){}
  }

  const preset0 = _scGetPresetById(state.qcPresetId);
  _scRenderTargets(preset0);

  if(!state.buffer){
    _scSet("sc_scope", "全体");
        _scSet("sc_lufs", "—");
    _scSet("sc_tp", "—");
    _scSet("sc_sr", "—");
    _scSet("sc_bd", "—");
    _scSet("sc_ch", "—");
    _scSet("sc_clip", "—");
    _scSet("sc_silence", "—");
        return;
  }


  const preset = preset0;
  _scUpdatePresetDesc();

  const buf = state.buffer;

  // Range: if STANBY/STANDBY and END exist, analyze between them
  const range = _ecFindRange();
  const startSec = range.hasSeg ? range.start : 0;
  const endSec = range.hasSeg ? range.end : buf.duration;
  const lenSec = Math.max(0, endSec - startSec);
  _scSet("sc_scope",
    range.hasSeg
      ? `範囲（${_ecFmtTime(startSec)} → ${_ecFmtTime(endSec)} / ${lenSec.toFixed(3)}s）`
      : `全体（0:00 → ${_ecFmtTime(endSec)} / ${lenSec.toFixed(3)}s）`
  );

  // Integrated LUFS (approx)
  const lufsRes = _ecComputeIntegratedLufs(buf, startSec, endSec);
  const lufs = lufsRes.lufs;
  const lufsTxt = (lufs==null) ? "—" : `${lufs.toFixed(1)} LUFS`;
  let lufsKind = "warn";
  if(preset && lufs!=null){
    const ok = Math.abs(lufs - preset.targetLufs) <= preset.tolLufs;
    lufsKind = ok ? "ok" : "ng";
  }
    const lufsReason = (preset && lufs!=null) ? (
    (lufsKind==="ok")
      ? `OK（目標 ${preset.targetLufs.toFixed(1)} ±${preset.tolLufs.toFixed(1)} / 実測 ${lufs.toFixed(1)}）`
      : `許容範囲外（目標 ${preset.targetLufs.toFixed(1)} ±${preset.tolLufs.toFixed(1)} → 許容 [${(preset.targetLufs-preset.tolLufs).toFixed(1)}, ${(preset.targetLufs+preset.tolLufs).toFixed(1)}] / 実測 ${lufs.toFixed(1)}）`
  ) : "";
  _scSetHtml("sc_lufs", `${lufsTxt} ${preset ? _scPill(lufsKind, preset && lufs!=null && lufsKind==="ok" ? "OK" : (lufsKind==="ng"?"NG":"—")) : ""}`, lufsReason);

  // Peaks (sample peak + approx true peak)
  const pk = _ecComputePeaks(buf, startSec, endSec);
  const tpDb = (pk && pk.truePeak!=null) ? (20*Math.log10(pk.truePeak)) : null;
  const tpTxt = (tpDb==null || !isFinite(tpDb)) ? "—" : `${tpDb.toFixed(2)} dBTP（approx）`;
  let tpKind = "warn";
  if(preset && tpDb!=null){
    tpKind = (tpDb <= preset.maxTruePeakDb) ? "ok" : "ng";
  }
    const tpReason = (preset && tpDb!=null && isFinite(tpDb)) ? (
    (tpKind==="ok")
      ? `OK（上限 ${preset.maxTruePeakDb.toFixed(2)} dBTP / 実測 ${tpDb.toFixed(2)} dBTP）`
      : `上限超過（上限 ${preset.maxTruePeakDb.toFixed(2)} dBTP / 実測 ${tpDb.toFixed(2)} dBTP）`
  ) : "";
  _scSetHtml("sc_tp", `${tpTxt} ${preset ? _scPill(tpKind, preset && tpDb!=null && tpKind==="ok" ? "OK" : (tpKind==="ng"?"NG":"—")) : ""}`, tpReason);

  // Format info (from fmt chunk when possible)
  const fmt = _ecParseFmtInfo();
  const sr = fmt ? fmt.sampleRate : buf.sampleRate;
  const bd = fmt ? fmt.bitsPerSample : null;
  const chN = fmt ? fmt.numChannels : buf.numberOfChannels;

  let srKind="warn", bdKind="warn", chKind="warn";
  if(preset){
    const srList = Array.isArray(preset.allowedSampleRates) ? preset.allowedSampleRates : [];
    const bdList = Array.isArray(preset.allowedBits) ? preset.allowedBits : [];
    const chList = Array.isArray(preset.allowedChannels) ? preset.allowedChannels : [];

    srKind = (srList.length===0 || srList.includes(sr)) ? "ok" : "ng";
    bdKind = (bd==null) ? "warn" : ((bdList.length===0 || bdList.includes(bd)) ? "ok" : "ng");
    chKind = (chList.length===0 || chList.includes(chN)) ? "ok" : "ng";
  }
    let srReason = "";
  if(preset){
    const allowed = preset.allowedSampleRates;
    if(!allowed || allowed.length===0) srReason = "（制限なし）";
    else {
      const a = allowed.join(", ");
      srReason = (srKind==="ok") ? `OK（許容: ${a} / 実測: ${sr}）` : `許容外（許容: ${a} / 実測: ${sr}）`;
    }
  }
  _scSetHtml("sc_sr", `${sr} Hz ${preset ? _scPill(srKind, srKind==="ok"?"OK":"NG") : ""}`, srReason);
    let bdReason = "";
  if(preset){
    const allowed = preset.allowedBits;
    if(!allowed || allowed.length===0) bdReason = "（制限なし）";
    else {
      const a = allowed.join(", ");
      bdReason = (bdKind==="ok") ? `OK（許容: ${a} / 実測: ${bd}）` : `許容外（許容: ${a} / 実測: ${bd}）`;
    }
  }
  _scSetHtml("sc_bd", `${bd!=null ? (bd+" bit") : "—"} ${preset ? _scPill(bdKind, (bdKind==="ok")?"OK":(bdKind==="ng"?"NG":"—")) : ""}`, bdReason);
    let chReason = "";
  if(preset){
    const allowed = preset.allowedChannels;
    if(!allowed || allowed.length===0) chReason = "（制限なし）";
    else {
      const a = allowed.map(_scFormatCh).join(", ");
      const v = _scFormatCh(chN);
      chReason = (chKind==="ok") ? `OK（許容: ${a} / 実測: ${v}）` : `許容外（許容: ${a} / 実測: ${v}）`;
    }
  }

  // Effective mono warning (dual-mono) within STANDBY→END range (or whole file if cues missing)
  let effMono = null;
  let effMonoWarn = false;
  if(chN===2){
    const segLabel = (range && range.hasSeg) ? "STANDBY→END間" : "全体";
    const sSec = (range && range.hasSeg) ? startSec : 0;
    const eSec = (range && range.hasSeg) ? endSec : (buf ? buf.duration : 0);
    effMono = _scDetectEffectiveMono(buf, sSec, eSec);
    effMonoWarn = !!(effMono && effMono.isEffectiveMono);
    if(effMonoWarn){
      const corrTxt = isFinite(effMono.corr) ? effMono.corr.toFixed(4) : "—";
      const drTxt = isFinite(effMono.diffRatio) ? (effMono.diffRatio*100).toFixed(2)+"%" : "—";
      const extra = `注意（${segLabel}でL/Rがほぼ同一＝実質モノラルの可能性 / corr=${corrTxt} / diff=${drTxt}）`;
      chReason = chReason ? (chReason + " / " + extra) : extra;
    }
  }

  _scSetHtml("sc_ch", `${_scFormatCh(chN)} ${preset ? _scPill(chKind, chKind==="ok"?"OK":"NG") : ""} ${effMonoWarn ? _scPill("warn","注意") : ""}`, chReason);

  // Clipping (sample-based)
  const clipDetected = (pk && pk.clipped && pk.clipped>0);
  const clipTxt = clipDetected ? `検出あり（${pk.clipped}）` : "検出なし";
    const clipReason = clipDetected ? `クリップ検出（clipped: ${pk.clipped}）` : "";
_scSetHtml("sc_clip", `${clipTxt} ${_scPill(clipDetected ? "ng" : "ok", clipDetected ? "NG" : "OK")}`, clipReason);

  // Silence (head/tail within allowed seconds)
const silMin = (preset && isFinite(preset.silenceMinSec)) ? Number(preset.silenceMinSec) : 0.0;
const silMax = (preset && isFinite(preset.silenceMaxSec)) ? Number(preset.silenceMaxSec) : ((preset && isFinite(preset.silenceAllowSec)) ? Number(preset.silenceAllowSec) : 0.5);
const sil = _scComputeHeadTailSilence(buf, startSec, endSec, (CFG?.STDCHK_SILENCE_THRESHOLD_DB ?? -60));
let silKind = "ok";
let silTag = "OK";
let silMsg = "—";
if(!sil.hasSound){
  silKind = "ng"; silTag = "NG";
  silMsg = `音声が検出できません（無音）`;
}else{
  const h = sil.headSec;
  const t = sil.tailSec;
  const okH = (h >= silMin) && (h <= silMax);
  const okT = (t >= silMin) && (t <= silMax);
  const ok = okH && okT;
  silKind = ok ? "ok" : "ng";
  silTag = ok ? "OK" : "NG";
  silMsg = `前 ${h.toFixed(2)}s / 後 ${t.toFixed(2)}s（許容 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s）`;
}
  let silReason = "";
  if(!sil.hasSound){ silReason = "音声が検出できません（無音）"; }
  else {
    const h = sil.headSec, t = sil.tailSec;
    const underH = (h < silMin);
    const underT = (t < silMin);
    const overH = (h > silMax);
    const overT = (t > silMax);
    if(!underH && !underT && !overH && !overT) silReason = `OK（前 ${h.toFixed(2)}s / 後 ${t.toFixed(2)}s / 許容 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s）`;
    else {
      const parts = [];
      if(underH) parts.push(`前が不足（${h.toFixed(2)}s）`);
      if(overH) parts.push(`前が許容超過（${h.toFixed(2)}s）`);
      if(underT) parts.push(`後が不足（${t.toFixed(2)}s）`);
      if(overT) parts.push(`後が許容超過（${t.toFixed(2)}s）`);
      silReason = `${parts.join(" / ")}（許容 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s）`;
    }
  }
  _scSetHtml("sc_silence", `${silMsg} ${_scPill(silKind, silTag)}`, silReason);

  // PDF attached
  const hasPdf = !!(state.pdfAttach && state.pdfAttach.bytes && state.pdfAttach.bytes.length>0);
    const pdfReason = hasPdf ? "OK（PDF添付あり）" : "PDFが添付されていません";
  _scSetHtml("sc_pdf", hasPdf ? `あり（${state.pdfAttach.name||"PDF"}） ${_scPill("ok","OK")}` : `なし ${_scPill("warn","注意")}`, pdfReason);

  // Overall
  const summary = {failCount:0, warnCount:0};
  const count = (k)=>{ if(k==="ng") summary.failCount++; else if(k==="warn") summary.warnCount++; };
  count(lufsKind); count(tpKind); count(srKind); count(bdKind); count(chKind);
  if(effMonoWarn) summary.warnCount++;
  if(clipDetected) summary.failCount++;
  if(silKind==="ng") summary.failCount++;
  // PDF is informational; do not include in overall judgment

    const ngList = [];
  if(lufsKind==="ng") ngList.push("ラウドネス");
  if(tpKind==="ng") ngList.push("TruePeak");
  if(srKind==="ng") ngList.push("サンプルレート");
  if(bdKind==="ng") ngList.push("bit深度");
  if(chKind==="ng") ngList.push("チャンネル");
  if(clipDetected) ngList.push("クリップ");
  if(silKind==="ng") ngList.push("無音（前/後）");
  const overallReason = (ngList.length>0) ? `NG: ${ngList.join(", ")}` : (summary.warnCount>0 ? "注意あり" : "OK");
  _scSetHtml("sc_overall", _scOverallTag(summary), overallReason);
  const qcResult = {
    items: [
      { key: "lufs", label: "Integrated LUFS", ok: lufsKind !== "ng", reason: lufsReason },
      { key: "tp", label: "TruePeak", ok: tpKind !== "ng", reason: tpReason },
      { key: "sr", label: "サンプルレート", ok: srKind !== "ng", reason: srReason },
      { key: "bd", label: "bit深度", ok: bdKind !== "ng", reason: bdReason },
      { key: "ch", label: "チャンネル", ok: chKind !== "ng", reason: chReason },
      { key: "clip", label: "クリッピング", ok: !clipDetected, reason: clipReason },
      { key: "silence", label: "無音", ok: silKind !== "ng", reason: silReason },
    ],
    summary: { ngCount: ngList.length, warnCount: summary.warnCount },
    presetId: state.qcPresetId || null,
  };
  window.__wavcueLastQc = {
    at: Date.now(),
    fileKey: String(state.fileName || ""),
    result: qcResult || {}
  };
  state.scLast = {presetId: state.qcPresetId, fileKey: _scCurrentFileKey(), lufs, tpDb, sr, bd, chN, clipDetected, headSilenceSec: sil.headSec, tailSilenceSec: sil.tailSec, silenceMinSec: silMin, silenceMaxSec: silMax, silenceAllowSec: silMax, effectiveMonoWarn: !!effMonoWarn, effectiveMonoCorr: effMono?.corr ?? null, effectiveMonoDiffRatio: effMono?.diffRatio ?? null};
}
try{ window._scRunMeasureAndRender = _scRunMeasureAndRender; }catch(_){}

function _scClamp(x){ return Math.max(-1, Math.min(1, x)); }

function _scEncodePcmPayloadFromBuffer(buffer, fmt){
  try{
    const audioFormat = fmt?.audioFormat ?? 1;
    const bits = fmt?.bitsPerSample ?? 16;
    const nch = fmt?.numChannels ?? buffer.numberOfChannels;
    const frames = buffer.length;

    if(audioFormat === 3 && bits === 32){
      // IEEE float 32
      const out = new ArrayBuffer(frames * nch * 4);
      const dv = new DataView(out);
      let o=0;
      for(let i=0;i<frames;i++){
        for(let ch=0; ch<nch; ch++){
          const d = buffer.getChannelData(ch);
          dv.setFloat32(o, _scClamp(d[i]), true);
          o += 4;
        }
      }
      return new Uint8Array(out);
    }

    if(audioFormat !== 1) return null; // only PCM supported for auto-fix

    if(bits === 16){
      const out = new ArrayBuffer(frames * nch * 2);
      const dv = new DataView(out);
      let o=0;
      for(let i=0;i<frames;i++){
        for(let ch=0; ch<nch; ch++){
          const d = buffer.getChannelData(ch);
          let v = Math.round(_scClamp(d[i]) * 32767);
          if(v>32767) v=32767;
          if(v<-32768) v=-32768;
          dv.setInt16(o, v, true);
          o += 2;
        }
      }
      return new Uint8Array(out);
    }

    if(bits === 24){
      const out = new Uint8Array(frames * nch * 3);
      let o=0;
      for(let i=0;i<frames;i++){
        for(let ch=0; ch<nch; ch++){
          const d = buffer.getChannelData(ch);
          let v = Math.round(_scClamp(d[i]) * 8388607);
          if(v>8388607) v=8388607;
          if(v<-8388608) v=-8388608;
          // little-endian 24-bit
          out[o++] = (v & 0xFF);
          out[o++] = ((v >> 8) & 0xFF);
          out[o++] = ((v >> 16) & 0xFF);
        }
      }
      return out;
    }

    if(bits === 32){
      const out = new ArrayBuffer(frames * nch * 4);
      const dv = new DataView(out);
      let o=0;
      for(let i=0;i<frames;i++){
        for(let ch=0; ch<nch; ch++){
          const d = buffer.getChannelData(ch);
          let v = Math.round(_scClamp(d[i]) * 2147483647);
          if(v>2147483647) v=2147483647;
          if(v<-2147483648) v=-2147483648;
          dv.setInt32(o, v, true);
          o += 4;
        }
      }
      return new Uint8Array(out);
    }

    return null;
  }catch(_){ return null; }
}

async function _scUpdatePreviewAudio(){
  if(!state.buffer || !state.srcFmtPayload || !state.srcDataPayload) return;
  try{
    const a = await ensureAudioEl();
    const suggestedPayload = (state.procApplied && state.procDataPayload) ? state.procDataPayload : state.srcDataPayload;

    const bextBuf = buildBextChunk();
    const fmtNorm = normalizePcmFmtPayload(state.srcFmtPayload);
    const fmtBuf  = _makeChunk("fmt ", fmtNorm.payload);
    const dataBuf = _makeChunk("data", suggestedPayload);
    const cmcdBuf = buildCmcdChunkFixed2048();
    const {cueChunk, listChunk, plstChunk} = buildCueChunks(state.buffer, state.cues);

    const chunks = [
      new Uint8Array(bextBuf),
      fmtBuf,
      dataBuf,
      new Uint8Array(cmcdBuf),
      new Uint8Array(cueChunk),
      ...(plstChunk ? [new Uint8Array(plstChunk)] : []),
      new Uint8Array(listChunk),
    ];
    const outAb = _buildCanonicalWavFromParts(chunks);
    const blob = new Blob([outAb], {type:"audio/wav"});

    if(state.previewUrl){ try{ URL.revokeObjectURL(state.previewUrl); }catch(_){ } }
    state.previewUrl = URL.createObjectURL(blob);
    a.src = state.previewUrl;
    a.currentTime = 0;
  }catch(err){
    log(`WARN: プレビュー音声を更新できませんでした: ${err?.message||err}`);
  }
}

async function _scApplyAutoFix(){
  if(!state.buffer){
    const recId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    const rec = (typeof window.__wavcueProGetRecById === "function") ? window.__wavcueProGetRecById(recId) : null;
    const targetFile = rec?.file || state.file;
    if(targetFile && typeof loadFile === "function"){
      await loadFile(targetFile);
    }
  }
  if(!state.buffer) return;
  const preset = _scGetPresetById(state.qcPresetId);
  if(!preset){
    alert("プリセットが見つかりません。");
    return;
  }

  const fmt = _ecParseFmtInfo();
  if(!fmt){
    alert("fmtチャンク情報を取得できませんでした。");
    return;
  }
  if(!(fmt.audioFormat===1 || (fmt.audioFormat===3 && fmt.bitsPerSample===32))){
    alert("この形式はラウドネスノーマライズに対応していません（PCM / Float32のみ）。");
    return;
  }

  const fixCtrl = new AbortController();
  let fixProgShown = false;
  try{ _prog.show("補正中…", "補正を実行中", fixCtrl); fixProgShown = true; }catch(_){ }

  try{
    const recId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
    const rec = (typeof window.__wavcueProGetRecById === "function") ? window.__wavcueProGetRecById(recId) : null;
    // measure current LUFS/TP from current state.buffer
    const r = _ecFindRange();
    const st = r.hasSeg ? r.start : 0;
    const ed = r.hasSeg ? r.end : state.buffer.duration;
    const lufsRes = _ecComputeIntegratedLufs(state.buffer, st, ed);
    const curLufs = lufsRes.lufs;
    if(curLufs==null || !isFinite(curLufs)){
      alert("LUFSを測定できませんでした。");
      return;
    }

  // gain to target
  const gainDb = preset.targetLufs - curLufs;
  const gain = Math.pow(10, gainDb/20);

  // TP safety attenuation
  const pk = _ecComputePeaks(state.buffer, 0, state.buffer.duration);
  const curTpAmp = pk?.truePeak ?? null;
  let tpSafetyDb = 0;
  let totalDb = gainDb;
  let total = gain;

  if(curTpAmp!=null && isFinite(curTpAmp)){
    const afterTpAmp = curTpAmp * gain;
    const maxTpAmp = Math.pow(10, preset.maxTruePeakDb/20);
    if(afterTpAmp > maxTpAmp){
      const safety = maxTpAmp / afterTpAmp;
      tpSafetyDb = 20*Math.log10(safety);
      total *= safety;
      totalDb += tpSafetyDb;
    }
  }

  // apply gain into new buffer
  const src = state.buffer;
  const nch = src.numberOfChannels;
  const len = src.length;
  const sr = src.sampleRate;

  const ctx = (typeof ensureAudioCtx === "function")
    ? await ensureAudioCtx()
    : (async ()=>{
      if(state.audioCtx) return state.audioCtx;
      state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      try{ await state.audioCtx.resume(); }catch(_){}
      return state.audioCtx;
    })();
  const outBuf = ctx.createBuffer(nch, len, sr);

  for(let ch=0; ch<nch; ch++){
    const s = src.getChannelData(ch);
    const d = outBuf.getChannelData(ch);
    for(let i=0;i<len;i++){
      d[i] = _scClamp(s[i] * total);
    }
  }

  const payload = _scEncodePcmPayloadFromBuffer(outBuf, fmt);
  if(!payload){
    alert("補正後の書き出しに失敗しました。");
    return;
  }

  // ensure original WAV bytes for rebuild
  let srcAb = state.srcAb || rec?.srcAb || rec?._stateSnap?.srcAb || null;
  if(!srcAb){
    try{
      const fileForAb = rec?.file || state.file || null;
      if(fileForAb && typeof fileForAb.arrayBuffer === "function"){
        srcAb = await fileForAb.arrayBuffer();
        state.srcAb = srcAb;
        if(rec) rec.srcAb = srcAb;
      }
    }catch(err){
      console.warn("[FixCommitB] srcAb fetch failed", err);
    }
  }

  let rebuiltAb = null;
  let replacedFile = false;
  let rebuiltBytesLen = 0;
  let dataReplaceOk = false;
  const replacements = { dataBuf: _makeChunk("data", payload) };
  const chunks = state.srcChunks || (srcAb ? parseRiffChunks(srcAb) : null);
  if(srcAb && chunks && Array.isArray(chunks) && chunks.length){
    try{
      const rebuiltBlob = rebuildWaveFromOriginal(srcAb, chunks, replacements);
      rebuiltAb = await rebuiltBlob.arrayBuffer();
      rebuiltBytesLen = rebuiltAb.byteLength;
      dataReplaceOk = true;
      if(!state.srcChunks) state.srcChunks = chunks;
    }catch(err){
      console.warn("[FixCommitB] data-replace failed", err);
    }
  }else{
    console.warn("[FixCommitB] data-replace skipped (missing srcAb/chunks)", { hasSrcAb: !!srcAb, hasChunks: !!(chunks && chunks.length) });
  }

  if(dataReplaceOk && rebuiltAb){
    const name = rec?.name || state.fileName || "fixed.wav";
    try{
      const newFile = new File([rebuiltAb], name, {type:"audio/wav"});
      if(rec){
        rec.file = newFile;
        rec._fixReplacedFile = true;
        rec.srcAb = rebuiltAb;
      }
      state.file = newFile;
      state.fileName = name;
      state.srcAb = rebuiltAb;
      state.srcDataPayload = payload;
      state.procApplied = false;
      state.procDataPayload = null;
      state.procInfo = null;
      state.origBuffer = null;
      replacedFile = true;
    }catch(err){
      console.warn("[FixCommitB] replace file failed", err);
    }
  }

  // apply to state (fallback: keep procApplied for temporary preview)
  if(!replacedFile && !state.origBuffer) state.origBuffer = src;
  state.buffer = outBuf;
  if(!replacedFile){
    state.procApplied = true;
    state.procDataPayload = payload;
    state.procInfo = {totalDb, gainDb, tpSafetyDb};
  }

  // rebuild peaks and redraw
  state.peaks = buildPeaks(state.buffer, 6000);
  drawAll();
  updateButtons();

  // update audio preview to match exported audio
  await _scUpdatePreviewAudio();

  _scSet("sc_fixState", "適用中");
  _scSet("sc_fixInfo", `ゲイン ${gainDb.toFixed(2)} dB / TP安全 ${tpSafetyDb.toFixed(2)} dB（合計 ${totalDb.toFixed(2)} dB）`);

  console.log("[FixCommitB]", {
    fileId: rec?.id || null,
    name: rec?.name || state.fileName || null,
    gainDb,
    rebuiltBytesLen,
    replacedFile,
  });
  if(dataReplaceOk){
    console.log("[FixCommitB] data-replace ok", { fileId: rec?.id || null, bytes: rebuiltBytesLen });
  }else{
    console.warn("[FixCommitB] data-replace ng", { fileId: rec?.id || null, bytes: rebuiltBytesLen });
  }

    // re-measure
    try{ _prog.set(null, "補正中…", "解析中…"); }catch(_){ }
    _scRunMeasureAndRender();

    try{
      const activeId = (typeof window.__wavcueProGetActiveId === "function") ? window.__wavcueProGetActiveId() : null;
      if(activeId && typeof window.__wavcueProAfterFix === "function"){
        window.__wavcueProAfterFix(activeId);
      }
      if(replacedFile && typeof window.requestFullRefresh === "function"){
        window.requestFullRefresh("fix:commitB");
      }
    }catch(_){ }
  }finally{
    if(fixProgShown){
      try{ _prog.hide(); }catch(_){ }
    }
  }
}

async function _scRevertAutoFix(){
  if(!state.procApplied){
    _scSet("sc_fixState", "未適用");
    _scSet("sc_fixInfo", "—");
    return;
  }
  try{
    const a = await ensureAudioEl();

    state.procApplied = false;
    state.procDataPayload = null;
    state.procInfo = null;

    // restore decoded buffer
    if(state.origBuffer){
      state.buffer = state.origBuffer;
      state.peaks = buildPeaks(state.buffer, 6000);
    }
    // restore preview to original file URL
    if(state.previewUrl){ try{ URL.revokeObjectURL(state.previewUrl); }catch(_){ } state.previewUrl=null; }
    if(state.audioUrl) a.src = state.audioUrl;

    drawAll();
    updateButtons();

    _scSet("sc_fixState", "未適用");
    _scSet("sc_fixInfo", "—");
    _scRunMeasureAndRender();
  }catch(err){
    log(`WARN: 補正を戻す処理でエラー: ${err?.message||err}`);
  }
}

function _scWire(){
  const btn = $("btnStdCheck");
  const dlg = $("stdCheckDialog");
  if(btn && dlg){
    btn.addEventListener("click", ()=>{
      try{
        _qcEnsureLoaded();
        _scPopulatePresetSelect();
        state.qcPresetId = $("sc_preset")?.value || state.qcPresetId || CFG.QC_DEFAULT_PRESET_ID;
        _scRenderTargets(_scGetPresetById(state.qcPresetId));
        _scUpdatePresetDesc();

        const fileKey = _scCurrentFileKey();
        const canKeep = !!(state.qcHasRun && state.scLast && state.scLast.presetId===state.qcPresetId && state.scLast.fileKey===fileKey);
        if(!canKeep){
          state.qcHasRun = false;
          _scResetResultsBlank();
        }

        // Restore last active tab (default: results)
        try{ _scSetTab(state.scActiveTab || "results"); }catch(_){ try{ _scSetTab("results"); }catch(__){} }

        dlg.showModal();
// fix state labels
        _scSet("sc_fixState", state.procApplied ? "適用中" : "未適用");
        if(state.procApplied && state.procInfo){
          _scSet("sc_fixInfo", `ゲイン ${state.procInfo.gainDb.toFixed(2)} dB / TP安全 ${state.procInfo.tpSafetyDb.toFixed(2)} dB（合計 ${state.procInfo.totalDb.toFixed(2)} dB）`);
        }else{
          _scSet("sc_fixInfo", "—");
        }
      }catch(_){
        try{ dlg.showModal(); }catch(__){}
      }
    });
  }

  if($("sc_preset")){
    $("sc_preset").addEventListener("change", ()=>{
      const gate = guardPreset({ source: "preset:select" });
      if(!gate.ok){
        if(window.safeToast) window.safeToast(LICENSE_TEXT.presetDemo, "warn");
        if(state.qcPresetId && $("sc_preset")) $("sc_preset").value = state.qcPresetId;
        return;
      }
      state.qcPresetId = $("sc_preset").value;
      _scRenderTargets(_scGetPresetById(state.qcPresetId));
      _scUpdatePresetDesc();
      state.qcHasRun = false;
      _scResetResultsBlank();
// preset manager is edited explicitly via picker/new
    });

    // keep preset form in sync when manager is open
    const mgr = $("sc_presetMgr");
    if(mgr){
      // no-op; toggled separately
    }
  }

  const ensurePresetAllowed = ()=>{
    const gate = guardPreset({ source: "preset" });
    if(!gate.ok){
      if(window.safeToast) window.safeToast(LICENSE_TEXT.presetDemo, "warn");
      return false;
    }
    return true;
  };

  // Preset manager
  if($("sc_presetManage")){
    $("sc_presetManage").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      const mgr = $("sc_presetMgr");
      if(!mgr) return;
      const next = (mgr.style.display==="none" || !mgr.style.display) ? "block" : "none";
      mgr.style.display = next;
      if(next==="block"){
        _scPresetMgrEnterIdle();
      }
    });
  }
  if($("sc_pm_pick")){
    $("sc_pm_pick").addEventListener("change", ()=>{
      if(!ensurePresetAllowed()) return;
      const v = ($("sc_pm_pick").value||"").trim();
      _scPmUpdatePickVisual();
      if(!v) return;
      if(v==="__new__") { _scPresetMgrStartNewBlank(); return; }
      _scPresetMgrStartEditPreset(v);
    });
  }
  if($("sc_pm_new")){
    $("sc_pm_new").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      _scPresetMgrStartNewBlank();
    });
  }

  if($("sc_pm_sort")){
    $("sc_pm_sort").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      _scPmToggleSortPanel();
    });
  }

if($("sc_pm_clone")){
    $("sc_pm_clone").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      // Clone = copy values into "new preset" form (not saved until user presses 保存)
      const srcId = (($("sc_pm_pick")?.value||"").trim()) || (($("sc_pm_id")?.value||"").trim()) || state.qcPresetId;
      const base = _scGetPresetById(srcId);
      if(!base){ alert("プリセットが見つかりません"); return; }

      // Switch editor to new mode and fill with cloned values
      if($("sc_pm_pick")) $("sc_pm_pick").value = "__new__";
      _scPmUpdatePickVisual();
      if($("sc_pm_id")) $("sc_pm_id").value = ""; // force new id on save
      if($("sc_pm_desc")) $("sc_pm_desc").value = "";
      if($("sc_pm_name")) $("sc_pm_name").value = String(base.name||"") + "（複製）";

      // numeric fields
      if($("sc_pm_target")) $("sc_pm_target").value = (isFinite(base.targetLufs) ? String(base.targetLufs) : "");
      if($("sc_pm_tol")) $("sc_pm_tol").value = (isFinite(base.tolLufs) ? String(base.tolLufs) : "");
      if($("sc_pm_tpmax")) $("sc_pm_tpmax").value = (isFinite(base.maxTruePeakDb) ? String(base.maxTruePeakDb) : "");

      // optional selectors
      if($("sc_pm_srsel")) $("sc_pm_srsel").value = (base.sampleRate || "");
      if($("sc_pm_bitssel")) $("sc_pm_bitssel").value = (base.bitDepth || "");
      if($("sc_pm_chsel")) $("sc_pm_chsel").value = (base.channels || "");

      // silence min/max (fallback to legacy allow)
      const sMin = isFinite(base.silenceMinSec) ? base.silenceMinSec : 0;
      const sMax = isFinite(base.silenceMaxSec) ? base.silenceMaxSec : (isFinite(base.silenceAllowSec) ? base.silenceAllowSec : 0.50);
      if($("sc_pm_silmin")) $("sc_pm_silmin").value = Number(sMin).toFixed(2);
      if($("sc_pm_silmax")) $("sc_pm_silmax").value = Number(sMax).toFixed(2);

      _scPresetMgrSetLocked(false);
      if($("sc_pm_clone")) $("sc_pm_clone").disabled = true;
      if($("sc_pm_delete")) $("sc_pm_delete").disabled = true;

      _scSet("sc_pm_hint", "複製元の設定をコピーしました。名前を調整して「保存」すると新規プリセットとして登録されます。 / " + _qcPresetStoreHint());
    });
  }
  if($("sc_pm_save")){
    $("sc_pm_save").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      const curId = ($("sc_pm_id")?.value || "").trim();
      const pickV = ($("sc_pm_pick")?.value || "").trim();
      const isNewMode = (pickV==="__new__") || !curId;
      const p = _scPresetMgrReadForm(isNewMode ? "" : curId);
      if(!p) return;
      const ok = _qcUpsertUserPreset(p);
      if(!ok){ alert(`保存に失敗しました。

原因: ${state.qcPresetSaveError||"（不明）"}

対処: ブラウザの保存設定をご確認ください。保存できない環境では「エクスポート」でJSON保存が可能です。`); return; }
      state.qcPresetId = p.id;
      _scPopulatePresetSelect();
      $("sc_preset").value = p.id;
      _scUpdatePresetDesc();
      _scPresetMgrFillFromCurrent(true);
      _scPresetMgrSetLocked(false);
      _scRunMeasureAndRender({switchToResults:false});
      window.safeToast("プリセットを保存しました。","ok");
    });
  }
    if($("sc_pm_export")){
    $("sc_pm_export").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      _qcEnsureLoaded();
      _qcOpenPresetExportSelector();
    });
  }
  if($("sc_pm_import")){
    $("sc_pm_import").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      const inp = document.createElement("input");
      inp.type = "file";
      inp.accept = "application/json,.json";
      inp.addEventListener("change", async ()=>{
        const f = inp.files && inp.files[0];
        if(!f) return;
        try{
          const txt = await f.text();
          const cleaned = String(txt||"").replace(/^\uFEFF/, "").trim();
          if(!cleaned){ throw new Error("empty"); }
          let obj;
          try{
            obj = JSON.parse(cleaned);
          }catch(e){
            // try to recover if the file contains extra text before/after JSON
            const a = cleaned.indexOf("{");
            const b = cleaned.lastIndexOf("}");
            if(a>=0 && b>a){
              obj = JSON.parse(cleaned.slice(a, b+1));
            }else{
              throw e;
            }
          }
          const res = _qcImportUserPresetsFromObject(obj);
          _scPopulatePresetSelect();
          if(state.qcPresetId && $("sc_preset")) $("sc_preset").value = state.qcPresetId;
          _scUpdatePresetDesc();

          // After import, auto-select and show the imported preset in the preset editor (if possible)
          if(res && res.firstId){
            try{
              if($("sc_pm_pick")) $("sc_pm_pick").value = res.firstId;
              _scPmUpdatePickVisual();
              _scPresetMgrStartEditPreset(res.firstId);
            }catch(_){
              _scPresetMgrEnterIdle();
            }
          }else{
            _scPresetMgrEnterIdle();
          }

          _scRunMeasureAndRender({switchToResults:false});
          if(res.ok) window.safeToast(res.count>0 ? `プリセットをインポートしました（追加: ${res.count}件）` : `インポートは完了しました（追加なし / 既存と重複）`,"ok");
          else window.safeToast(`インポートは完了しましたが、ブラウザ保存に失敗しました（エクスポートで保存してください）`,"warn");
        }catch(e){
          alert("インポートに失敗しました。\n\n詳細: "+(e?.message||e));
        }
      });
      inp.click();
    });
  }
if($("sc_pm_delete")){
    $("sc_pm_delete").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      const id = $("sc_pm_id")?.value || state.qcPresetId;
      if(!id){ return; }
      if(!_qcIsUserPreset(id)){
        // if it's a default (no override), ask to remove override only
        alert("削除できるのはカスタムプリセットのみです。\nデフォルトに戻すには、上書き分を削除してください。");
        return;
      }
      if(!confirm("このプリセット（カスタム）を削除します。よろしいですか？")) return;
      _qcDeleteUserPreset(id);
      // fallback to default if exists, else first
      const all = _qcGetAllPresets();
      const next = all[0]?.id || null;
      state.qcPresetId = next;
      _scPopulatePresetSelect();
      if(next) $("sc_preset").value = next;
      _scUpdatePresetDesc();
      _scPresetMgrFillFromCurrent(true);
      _scRunMeasureAndRender({switchToResults:false});
      _scPresetMgrEnterIdle();
      window.safeToast("プリセットを削除しました。","warn");
    });
  }

  if($("sc_run")){
    $("sc_run").addEventListener("click", ()=>_scRunMeasureAndRender());
  }

  if($("sc_tab_results")){
    $("sc_tab_results").addEventListener("click", ()=>_scSetTab("results"));
  }
  if($("sc_tab_preset")){
    $("sc_tab_preset").addEventListener("click", ()=>{
      if(!ensurePresetAllowed()) return;
      _scSetTab("preset");
    });
  }


  // Close when clicking outside the modal content (dialog backdrop)
  if(dlg && !dlg.dataset.backdropClose){
    dlg.dataset.backdropClose = "1";
    dlg.addEventListener("click", (e)=>{ if(e.target===dlg) { try{ dlg.close(); }catch(_){} } });
    dlg.addEventListener("cancel", (e)=>{ e.preventDefault(); try{ dlg.close(); }catch(_){} });
  }

  if($("sc_fix")){
    const btnFix = $("sc_fix");
    btnFix.addEventListener("click", async ()=>{
      if(isDemoEditLocked()){ warnDemoLocked(); return; }
      if(btnFix.disabled) return;
      btnFix.disabled = true;
      try{
        await _scApplyAutoFix();
      }catch(err){
        log(`ERROR: 自動補正でエラー: ${err?.message||err}`);
        alert("ラウドネスノーマライズに失敗しました。ログをご確認ください。");
      }finally{
        btnFix.disabled = false;
      }
    });
  }
}
_scWire();
// ===== /Standard Check modal =====


/* Keyboard shortcuts
   Space: play/pause
   T: zoom in (horizontal)
   R: zoom out (horizontal)
   Shift+T: zoom in (vertical)
   Shift+R: zoom out (vertical)
*/
window.addEventListener("keydown", (e)=>{
  // ignore while typing in inputs/textareas/dialog
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
  const isTyping = (tag==="input" || tag==="textarea") || (e.target && e.target.isContentEditable);
  if(isTyping) return;

  // Undo / Redo (app-level)
  if((e.metaKey || e.ctrlKey) && !e.altKey){
    const k = (e.key || "").toLowerCase();
    if(k === "z"){
      // If auto gain correction is currently applied, Ctrl/Cmd+Z reverts it (no separate button)
      if(!e.shiftKey && (state?.procApplied) && (typeof _scRevertAutoFix === "function")){
        e.preventDefault();
        _scRevertAutoFix();
        return;
      }
      e.preventDefault();
      if(e.shiftKey) redoDo(); else undoDo();
      return;
    }
    if(k === "y"){
      e.preventDefault();
      redoDo();
      return;
    }
  }

  if(e.code==="Space"){
    e.preventDefault();
    if(!state.buffer) return;
    if(state.isPlaying) pause(); else play();
    return;
  }

  // Shift + T/R => vertical zoom
  if(e.shiftKey && (e.key==="t" || e.key==="T")){
    e.preventDefault();
    if(!state.buffer) return;
    state.vZoom = clamp(state.vZoom*1.25, 0.25, 10);
    drawAll();
    return;
  }
  if(e.shiftKey && (e.key==="r" || e.key==="R")){
    e.preventDefault();
    if(!state.buffer) return;
    state.vZoom = clamp(state.vZoom/1.25, 0.25, 10);
    drawAll();
    return;
  }

  // T/R => horizontal zoom
  if(e.key==="t" || e.key==="T"){
    e.preventDefault();
    if(!state.buffer) return;
    state.zoom = clamp(state.zoom*1.25, 1, 32);
    ensureVisibleSec(currentPlayheadSec());
    drawAll();
    return;
  }
  if(e.key==="r" || e.key==="R"){
    e.preventDefault();
    if(!state.buffer) return;
    state.zoom = clamp(state.zoom/1.25, 1, 32);
    ensureVisibleSec(currentPlayheadSec());
    drawAll();
    return;
  }
});
function updateViewportVars(){
  const vh = window.innerHeight * 0.01;
  const vw = window.innerWidth * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
  document.documentElement.style.setProperty('--vw', `${vw}px`);
  console.log(`[UI][viewport] w=${window.innerWidth}, h=${window.innerHeight}, vh=${vh.toFixed(2)}, vw=${vw.toFixed(2)}`);
}
function installViewportWatch(){
  if(window.__viewportWatchInstalled) return;
  window.__viewportWatchInstalled = true;
  let lastW = window.innerWidth;
  let lastH = window.innerHeight;
  let _resizeRaf = 0;
  let _resizeTimer = 0;
  const tick = ()=>{
    const w = window.innerWidth;
    const h = window.innerHeight;
    if(w === lastW && h === lastH) return;
    lastW = w;
    lastH = h;
    console.log(`[UI][watchResize] detected w/h change ${w}x${h}`);
    updateViewportVars();
    if (_resizeRaf) cancelAnimationFrame(_resizeRaf);
    if (_resizeTimer) clearTimeout(_resizeTimer);
    const kick = (phase)=>{
      try{
        console.log(`[UI][resizeKick] ${phase} w=${w} h=${h}`);
        resizeAll();
        drawAll();
        _uiLogWaveLayout(`resizeKick:${phase}`);
      }catch(e){
        console.warn("[UI][resizeKick] failed", phase, e);
      }
    };
    _resizeRaf = requestAnimationFrame(()=> kick("raf"));
    _resizeTimer = setTimeout(()=> kick("timeout"), 60);
    _recoverProFileDockLayout("watch");
  };
  setInterval(tick, 220);
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", updateViewportVars, {passive:true});
    window.visualViewport.addEventListener("scroll", updateViewportVars, {passive:true});
  }
}
function installWindowResizeRelayout(){
  if(window.__resizeRelayoutInstalled) return;
  window.__resizeRelayoutInstalled = true;
  let lastW = window.innerWidth;
  let lastH = window.innerHeight;
  let timer = 0;
  const safe = window.safeCall || ((fn, ...args)=>{
    try{ if(typeof fn === "function") return fn(...args); }catch(_){}
  });
  const run = ()=>{
    safe(window.requestFullRefresh, "window:resize");
    safe(window.forceRedraw, "window:resize");
    safe(window.drawWaveform);
    safe(window.drawAnalyzers);
    safe(window.bootDrawAnalyzers, "resize");
  };
  const handler = ()=>{
    const w = window.innerWidth;
    const h = window.innerHeight;
    if(w === lastW && h === lastH) return;
    lastW = w;
    lastH = h;
    if(timer) clearTimeout(timer);
    timer = setTimeout(()=>{
      requestAnimationFrame(run);
    }, 100);
  };
  window.addEventListener("resize", handler, {passive:true});
}
/* Resize */
window.addEventListener("resize", ()=>{
  updateViewportVars();
  resizeAll();
  drawAll();
  requestAnimationFrame(()=>{
    try{ resizeAll(); }catch(_){}
    try{ drawAll(); }catch(_){}
    try{ forceDrawAnalyzersOnBoot(); }catch(_){}
  });
  _recoverProFileDockLayout("window:resize");
  try{
    const waveEl = $("wave");
    const meterEl = $("meterCanvas");
    const imagerEl = $("imagerCanvas");
    const waveRect = waveEl?.getBoundingClientRect?.() || {width:0,height:0};
    const meterRect = meterEl?.getBoundingClientRect?.() || {width:0,height:0};
    const imagerRect = imagerEl?.getBoundingClientRect?.() || {width:0,height:0};
    console.log("[UI][canvas]", {
      wave: { rectW: waveRect.width, rectH: waveRect.height, w: waveEl?.width, h: waveEl?.height },
      meter: { rectW: meterRect.width, rectH: meterRect.height, w: meterEl?.width, h: meterEl?.height },
      imager: { rectW: imagerRect.width, rectH: imagerRect.height, w: imagerEl?.width, h: imagerEl?.height },
    });
  }catch(_){}
  _uiLogWaveLayout("window:resize:end");
});

function init(){
  updateViewportVars();
  installViewportWatch();
  installWindowResizeRelayout();
  setupDragAndDrop();

  // 1回目：従来どおり
  resizeAll();
  updateButtons();
  drawAll();
  log("Ready.");

  // 2回目：レイアウト確定後に再描画（起動直後にメーター目盛り/LRが消える対策）
  requestAnimationFrame(()=>{
    try{ resizeAll(); drawAll(); }catch(_){}
    _recoverProFileDockLayout("raf");
  });
  setTimeout(()=>{
    try{ resizeAll(); drawAll(); }catch(_){}
    _recoverProFileDockLayout("timeout");
  }, 60);
}
init();

document.addEventListener("DOMContentLoaded", ()=>{
  _recoverProFileDockLayout("dom");
  bootDrawAnalyzers("dom");
});
requestAnimationFrame(()=>{ _recoverProFileDockLayout("boot-raf"); });
window.addEventListener("load", ()=>{
  _recoverProFileDockLayout("load");
  bootDrawAnalyzers("load");
});

setupCmcdDialog();
setupPdfDialog();

// ===== Settings persistence (localStorage) =====
const _SET_KEY = "wavcue_settings_v1";
function _settingsLoad(){
  try{
    const raw = localStorage.getItem(_SET_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(s && typeof s === "object"){
      try{ if(typeof s.pairSeconds === "string" && $("pairSeconds")) $("pairSeconds").value = s.pairSeconds; }catch(_){}
      try{ if(typeof s.linkPair === "boolean" && $("chkLinkPair")) $("chkLinkPair").checked = s.linkPair; }catch(_){}
    }
  }catch(_){}
}
function _settingsSave(){
  try{
    const s = {
      pairSeconds: ($("pairSeconds")?.value ?? "").toString(),
      linkPair: !!($("chkLinkPair")?.checked),
    };
    localStorage.setItem(_SET_KEY, JSON.stringify(s));
  }catch(_){}
}
_settingsLoad();
refreshSettingsData();
try{
  ["pairSeconds","chkLinkPair"].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("change", _settingsSave);
    el.addEventListener("input", _settingsSave);
  });
}catch(_){}

// ===== Version & Changelog =====
try{ const vp = document.getElementById("verPill"); if(vp) vp.textContent = APP_VERSION; }catch(_){}
(function(){
  const btn = document.getElementById("btnChangelog");
  const dlg = document.getElementById("changelogDialog");
  const close = document.getElementById("btnChangelogClose");
  if(btn && dlg){
    btn.addEventListener("click", ()=>{ try{ dlg.showModal(); }catch(_){ dlg.open=true; } });
  }
  if(close && dlg){
    close.addEventListener("click", ()=>{ try{ dlg.close(); }catch(_){ dlg.open=false; } });
  }
  dlg?.addEventListener("click", (e)=>{ if(e.target===dlg){ try{ dlg.close(); }catch(_){ dlg.open=false; } } });
})();

// ===== Diagnostic copy =====
(function(){
  const btn = document.getElementById("btnDiagCopy");
  if(!btn) return;
  btn.addEventListener("click", async()=>{
    const t = collectDiagnosticText([`exportStrategy: ${(function(){ try{ return exportStrategySummary().method; }catch(_){ return "n/a"; } })()}`]);
    await copyTextToClipboard(t);
  });
})();

installUndoTracking();

// init: diff summary UI
try{ initDiffSummary(); }catch(_){ }

// wire: dialog outside click to close
(function(){
  const ids = ["chunkDialog","cmcdDialog"];
  for(const id of ids){
    const dlg = document.getElementById(id);
    if(!dlg) continue;
    dlg.addEventListener("click", (e)=>{
      if(e.target === dlg){
        try{ dlg.close(); }catch(_){ dlg.open=false; }
      }
    });
  }
})();

renderCmcdForm();

// ===== PDF_ATTACH_V1_START =====
// (extended) file kinds for Minhouren: CSV/PDF/XML/TEXT
function _fileKindFromName(name){
  const n = String(name||"").toLowerCase();
  if(n.endsWith('.pdf')) return 'PDF';
  if(n.endsWith('.csv')) return 'CSV';
  if(n.endsWith('.xml')) return 'XML';
  if(n.endsWith('.txt') || n.endsWith('.text')) return 'TEXT';
  return '';
}
function _fileKindFromMime(m){
  const t = String(m||"").toLowerCase();
  if(t.includes('pdf')) return 'PDF';
  if(t.includes('csv')) return 'CSV';
  if(t.includes('xml')) return 'XML';
  if(t.startsWith('text/')) return 'TEXT';
  return '';
}
function _fileExtForKind(kind){
  switch(kind){
    case 'PDF': return '.pdf';
    case 'CSV': return '.csv';
    case 'XML': return '.xml';
    case 'TEXT': return '.txt';
    default: return '';
  }
}
function _fileMimeForKind(kind){
  switch(kind){
    case 'PDF': return 'application/pdf';
    case 'CSV': return 'text/csv';
    case 'XML': return 'application/xml';
    case 'TEXT': return 'text/plain';
    default: return 'application/octet-stream';
  }
}
function _fileDetectKind(fileOrObj){
  try{
    const name = fileOrObj?.name;
    const mime = fileOrObj?.type || fileOrObj?.mime;
    return _fileKindFromName(name) || _fileKindFromMime(mime);
  }catch(_){ return ''; }
}
function _fileDecodeText(u8){
  try{ return new TextDecoder('utf-8', {fatal:false}).decode(u8); }catch(_){ }
  try{ return new TextDecoder('shift-jis', {fatal:false}).decode(u8); }catch(_){ }
  try{ return new TextDecoder().decode(u8); }catch(_){ }
  return '';
}


// attachment model (max 9, order matters)
function _attMakeId(){ return `att_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`; }
function _attEnsureId(att){ try{ if(att && !att.id) att.id=_attMakeId(); }catch(_){ } return att; }
function attachSyncLegacy(){
  if(!Array.isArray(state.attachments)) state.attachments = [];
  if(!(state.attachSel>=0 && state.attachSel<state.attachments.length)) state.attachSel = 0;
  state.pdfAttach = state.attachments[state.attachSel] || null; // legacy alias
}
function attachRenderList(){
  const list = document.getElementById("attachList");
  const cnt = document.getElementById("attachCount");
  if(cnt) cnt.textContent = `${(Array.isArray(state.attachments)?state.attachments.length:0)}/9`;
  if(!list) return;
  list.innerHTML = "";
  const atts = Array.isArray(state.attachments) ? state.attachments : [];
  if(!atts.length){
    const empty = document.createElement("div");
    empty.style.padding = "10px 12px";
    empty.style.opacity = ".75";
    empty.style.fontSize = "12px";
    empty.textContent = "未添付";
    list.appendChild(empty);
    return;
  }
  for(let i=0;i<atts.length;i++){
    const a = atts[i];
    _attEnsureId(a);
    const item = document.createElement("div");
    item.className = "attachItem" + (i===state.attachSel ? " selected" : "");
    item.dataset.id = a.id;
    item.setAttribute("role","option");
    item.setAttribute("aria-selected", i===state.attachSel ? "true" : "false");

    const h = document.createElement("span");
    h.className = "dragHandle";
    h.textContent = "≡";
    h.title = "ドラッグで並び替え";
    h.setAttribute("draggable","true");

    const badge = document.createElement("span");
    badge.className = "attachSlotBadge";
    badge.textContent = `#${i+1}`;
    badge.title = `添付スロット #${i+1}`;

    const main = document.createElement("div");
    main.className = "attachMain";

    const name = document.createElement("div");
    name.className = "attachNameLine";
    name.textContent = a?.name || "attached";

    const meta = document.createElement("div");
    meta.className = "attachMetaLine";
    const kind = a?.kind || _fileKindFromName(a?.name) || _fileKindFromMime(a?.mime) || "FILE";
    meta.textContent = `${kind} • ${(a?.bytes?.length||0).toLocaleString()} bytes`;

    main.appendChild(name);
    main.appendChild(meta);

    item.appendChild(h);
    item.appendChild(badge);
    item.appendChild(main);
    list.appendChild(item);
  }
}
function attachSetAll(list){
  const norm = (Array.isArray(list)?list:[]).slice(0,9).map(a=>_attEnsureId(a));
  state.attachments = norm;
  state.attachSel = 0;
  attachSyncLegacy();
  attachRenderList();
  _pdfUI_set(state.pdfAttach);
}

try{
  window.attachSetAll = window.attachSetAll || attachSetAll;
  window.attachRenderList = window.attachRenderList || attachRenderList;
  window.attachSyncLegacy = window.attachSyncLegacy || attachSyncLegacy;
  window._pdfUI_set = window._pdfUI_set || _pdfUI_set;
}catch(_){ }
function attachSelectById(id){
  const atts = Array.isArray(state.attachments) ? state.attachments : [];
  const idx = atts.findIndex(a=>a && a.id===id);
  if(idx>=0){
    state.attachSel = idx;
    attachSyncLegacy();
    attachRenderList();
    _pdfUI_set(state.pdfAttach);
  }
}
function attachSelectIndex(idx){
  const atts = Array.isArray(state.attachments) ? state.attachments : [];
  if(!atts.length){
    state.attachSel = 0;
    attachSyncLegacy();
    attachRenderList();
    _pdfUI_set(null);
    return;
  }
  state.attachSel = clamp(idx, 0, atts.length-1);
  attachSyncLegacy();
  attachRenderList();
  _pdfUI_set(state.pdfAttach);
}
function attachAdd(att){
  if(!att || !att.bytes || !att.bytes.length) return;
  if(!Array.isArray(state.attachments)) state.attachments = [];
  if(state.attachments.length >= 9){
    log("WARN: 添付は最大9件です。");
    return;
  }
  _attEnsureId(att);
  try{ if(att._storeId==null) att._storeId = _pdfStorePut(att.bytes); }catch(_){ }
  state.attachments.push(att);
  state.attachSel = state.attachments.length - 1;
  attachSyncLegacy();
  attachRenderList();
  _pdfUI_set(state.pdfAttach);
  const rec = _syncActiveRecAttachments();
  if(rec){
    console.log("[PDF]", "add", { fileId: rec.id, count: rec.attachments.length });
    if(typeof window.commitAll === "function"){
      window.commitAll("pdf:add", { fileId: rec.id });
    }
  }
}
function attachRemoveSelected(confirmMsg){
  const atts = Array.isArray(state.attachments) ? state.attachments : [];
  if(!atts.length) return;
  const cur = atts[state.attachSel];
  const name = cur?.name || "添付";
  if(confirmMsg){
    if(!window.confirm(confirmMsg.replace(/\{name\}/g, name))) return;
  }
  atts.splice(state.attachSel, 1);
  state.attachments = atts;
  if(state.attachSel >= atts.length) state.attachSel = Math.max(0, atts.length-1);
  attachSyncLegacy();
  attachRenderList();
  _pdfUI_set(state.pdfAttach);
  log(`OK: 添付を解除しました: ${name}`);
  const rec = _syncActiveRecAttachments();
  if(rec){
    console.log("[PDF]", "remove", { fileId: rec.id, count: rec.attachments.length });
    if(typeof window.commitAll === "function"){
      window.commitAll("pdf:remove", { fileId: rec.id });
    }
  }
}

function _pdfUI_set(obj){
  const nameEl = document.getElementById("pdfAttachName");
  const stEl = document.getElementById("pdfAttachStatus");
  const btnView = document.getElementById("btnPdfAttachView");
  const btnDl = document.getElementById("btnPdfAttachDownload");
  const btnClear = document.getElementById("btnPdfAttachClear");
  const atts = Array.isArray(state.attachments) ? state.attachments : [];
  const idx = Math.max(0, Math.min(state.attachSel|0, Math.max(0, atts.length-1)));
  const total = atts.length;
  const cur = obj;

  if(nameEl) nameEl.value = cur?.name || "";
  if(stEl){
    if(!cur) stEl.value = "未添付";
    else {
      const k = cur.kind || _fileKindFromName(cur.name) || _fileKindFromMime(cur.mime) || "FILE";
      stEl.value = `添付済み (${idx+1}/${total})  ${k} / ${(cur.bytes?.length||0).toLocaleString()} bytes`;
    }
  }
  if(btnView) btnView.disabled = !cur;
  if(btnDl) btnDl.disabled = !cur;
  if(btnClear) btnClear.disabled = !total;
  try{ const cnt = document.getElementById("attachCount"); if(cnt) cnt.textContent = `${total}/9`; }catch(_){ }
}
function pdfSet(obj){
  try{
    if(Array.isArray(obj)){
      const list = obj.slice(0,9).map(o=>{
        let a = o;
        try{
          if(a && a.bytes && a.bytes.length && a._storeId==null) a = { ...a, _storeId: _pdfStorePut(a.bytes) };
        }catch(_){ }
        try{
          if(a && typeof a.name==="string"){
            const nn = (a.name.normalize ? a.name.normalize("NFC") : a.name);
            a = { ...a, name: nn };
          }
        }catch(_){ }
        try{ if(a && !a.kind) a = { ...a, kind: (_fileKindFromName(a.name) || _fileKindFromMime(a.mime) || "") }; }catch(_){ }
        return _attEnsureId(a);
      });
      attachSetAll(list);
      return;
    }

    if(obj && obj.bytes && obj.bytes.length){
      let a = obj;
      if(a._storeId==null) a = { ...a, _storeId: _pdfStorePut(a.bytes) };
      try{
        if(typeof a.name==="string"){
          const nn = (a.name.normalize ? a.name.normalize("NFC") : a.name);
          a = { ...a, name: nn };
        }
      }catch(_){ }
      try{ if(!a.kind) a = { ...a, kind: (_fileKindFromName(a.name) || _fileKindFromMime(a.mime) || "") }; }catch(_){ }
      attachSetAll([_attEnsureId(a)]);
      return;
    }
  }catch(_){ }
  attachSetAll([]);
}

function _pdf_parseFilePayload(payloadU8){
  // [u32 cueId][u32 reserved][cp932 filename + CRLF][file bytes]
  if(!payloadU8 || payloadU8.length < 12) return null;
  let cueId = 0;
  try{ cueId = new DataView(payloadU8.buffer, payloadU8.byteOffset, payloadU8.byteLength).getUint32(0,true); }catch(_){ cueId = 0; }
  let p = 8;
  let end = payloadU8.length;
  for(let i=p;i<payloadU8.length-1;i++){
    if(payloadU8[i]===0x0D && payloadU8[i+1]===0x0A){ end = i+2; break; }
    if(payloadU8[i]===0x00){ end = i; break; }
  }
  const nameRaw = payloadU8.slice(p, end);
  const rawName = _sjisDecode(nameRaw).replace(/\r?\n/g,"").trim();
  const name = (rawName || "attached" + (_fileExtForKind("PDF")||".pdf"));
  const nameNfc = (name.normalize ? name.normalize("NFC") : name);
  const bytes = payloadU8.slice(end);
  const kind = _fileKindFromName(nameNfc) || "FILE";
  return { name: nameNfc, bytes, cueId, kind };
}

function pdfFindAllInWav(ab){
  try{
    const u8 = new Uint8Array(ab);
    const dv = new DataView(ab);
    const u32 = (o)=>dv.getUint32(o,true);
    const str4 = (o)=>String.fromCharCode(u8[o],u8[o+1],u8[o+2],u8[o+3]);
    if(str4(0)!=="RIFF" || str4(8)!=="WAVE") return [];

    const out = [];
    let off = 12;
    while(off + 8 <= u8.length){
      const id = str4(off);
      const size = u32(off+4);
      const data = off+8;
      const end = data+size;

      if(id==="LIST" && data+4<=end){
        const ltype = str4(data);
        if(ltype==="adtl"){
          let p = data+4;
          while(p + 8 <= end){
            const sid = str4(p);
            const ssize = u32(p+4);
            const sdata = p+8;
            const send = sdata+ssize;
            if(sid==="file" && send<=end){
              const payload = new Uint8Array(ab, sdata, ssize);
              const parsed = _pdf_parseFilePayload(payload);
              if(parsed && parsed.bytes && parsed.bytes.length) out.push(parsed);
            }
            p = send + (ssize%2);
          }
        }
      }
      off = end + (size%2);
    }

    // order: NOTE1..NOTE9 by cueId (legacy cueId=2 -> NOTE1)
    const noteIndexFromCueId = (cid)=>{
      if(cid===2) return 1;
      if(cid>=5 && cid<=13) return (cid-4);
      return 99;
    };
    out.forEach(a=>{ try{ a._noteOrder = noteIndexFromCueId(a.cueId>>>0); }catch(_){ a._noteOrder=99; } });
    out.sort((a,b)=>(a._noteOrder-b._noteOrder));
    const list = out.slice(0,9).map(a=>{
      try{ delete a._noteOrder; }catch(_){ }
      return a;
    });
    return list;
  }catch(_){ return []; }
}
function pdfFindInWav(ab){
  const list = pdfFindAllInWav(ab);
  return (list && list.length) ? list[0] : null;
}


/* ===============================
   PDF_ATTACH: LIST/adtl/file builder
================================ */

function pdfBuildFileSubchunk(fileName, fileBytes, cueId){
  // cueId は対応する NOTE の dwName を参照する（NOTE1..NOTE9）
  const safeName = pdfNormalizeNameCp932(fileName, CFG.PDF_NAME_MAX_BYTES); // filename <=128 bytes (CP932)
  const nameBytes = _sjisEncode(safeName + "\r\n");

  const head = new Uint8Array(8 + nameBytes.length);
  const dv = new DataView(head.buffer);
  dv.setUint32(0, (cueId>>>0), true);
  dv.setUint32(4, 0, true);
  head.set(nameBytes, 8);

  const body = new Uint8Array(head.length + fileBytes.length);
  body.set(head, 0);
  body.set(fileBytes, head.length);

  const out = new Uint8Array(8 + body.length + (body.length % 2));
  out.set(new TextEncoder().encode("file"), 0);
  new DataView(out.buffer).setUint32(4, body.length, true);
  out.set(body, 8);
  return out;
}

// filename sanitizer/truncator for LIST/adtl/file (CP932 byte count)
function pdfNormalizeNameCp932(name, maxBytes){
  let s = (name ?? "").toString().trim();
  // strip path components just in case
  s = s.replace(/\\/g,"/").split("/").pop() || "attached";
  // strip control chars / CRLF
  s = s.replace(/[\r\n\0]/g,"").trim();
  try{ s = (s.normalize ? s.normalize("NFC") : s); }catch(_){ }
  if(!s) s = "attached";

  // normalize .text -> .txt
  s = s.replace(/\.text$/i, ".txt");

  let kind = _fileKindFromName(s) || 'TEXT';
  const extWanted = _fileExtForKind(kind) || ".bin";

  // if extension missing or unsupported, append wanted
  if(!_fileKindFromName(s)) s = s + extWanted;

  const dot = s.lastIndexOf(".");
  const ext = dot>=0 ? s.slice(dot) : extWanted;
  let base = dot>=0 ? s.slice(0, dot) : s;

  // clamp by CP932 bytes, ensuring no multibyte split
  const encChar = (ch)=> cp932Encode(ch);
  const baseMax = Math.max(1, (maxBytes|0) - encChar(ext).length);

  let bytes = 0;
  let outBase = "";
  for(const ch of base){
    const b = encChar(ch);
    if(bytes + b.length > baseMax) break;
    outBase += ch;
    bytes += b.length;
  }
  let outName = (outBase || "attached") + ext;

  // final guard
  const outBytes = _sjisEncode(outName);
  if(outBytes.length > maxBytes){
    // As last resort, fall back to simple ASCII base.
    outName = "attached" + ext;
  }
  return outName;
}

function pdfOpenViewerForObject(obj, meta){
  try{
    const dlg = document.getElementById("pdfViewDialog");
    const frame = document.getElementById("pdfViewerFrame");
    const textBox = document.getElementById("fileTextPreview");
    if(!dlg || !frame) return;

    if(!obj || !obj.bytes || !obj.bytes.length){
      log("WARN: ファイルが添付されていません。");
      return;
    }

    const kind =
      obj.kind ||
      (typeof _fileKindFromName === "function" ? _fileKindFromName(obj.name) : "") ||
      (typeof _fileKindFromMime === "function" ? _fileKindFromMime(obj.mime) : "") ||
      "FILE";

    // reset old object URL
    if(state.pdfViewUrl){
      try{ URL.revokeObjectURL(state.pdfViewUrl); }catch(_){}
      state.pdfViewUrl = null;
    }

    if(kind === "PDF"){
      if(textBox){ textBox.style.display = "none"; textBox.value = ""; }
      frame.style.display = "block";
      const url = URL.createObjectURL(new Blob([obj.bytes], {type: obj.mime || "application/pdf"}));
      state.pdfViewUrl = url;
      frame.src = url;
    }else{
      frame.src = "about:blank";
      frame.style.display = "none";
      if(textBox){
        textBox.style.display = "block";
        const txt = (typeof _fileDecodeText === "function") ? _fileDecodeText(obj.bytes) : "";
        textBox.value = txt ? txt : `（${kind} のプレビューはテキストとして表示します。内容が表示されない場合はエクスポート後に外部で確認してください）`;
      }
    }

    if(meta && meta.source === "popover"){
      try{
        console.log("[PDF]", "openFromPopover", {
          fileId: meta.fileId,
          index: meta.index,
          name: obj.name || "",
          kind
        });
      }catch(_){}
    }

    try{ dlg.showModal(); }catch(_){ dlg.open = true; }
  }catch(e){
    try{ console.warn("[PDF] pdfOpenViewerForObject failed", e); }catch(_){}
  }
}
try{ window.pdfOpenViewerForObject = pdfOpenViewerForObject; }catch(_){}

function pdfOpenViewer(){
  if(!state.pdfAttach?.bytes?.length){
    log("WARN: ファイルが添付されていません。");
    return;
  }
  const fn = (typeof window !== "undefined") ? window.pdfOpenViewerForObject : null;
  if(typeof fn === "function"){
    fn(state.pdfAttach, null);
  }else{
    try{ console.warn("[PDF] pdfOpenViewerForObject missing"); }catch(_){}
    log("WARN: ビューアの起動関数が見つかりません。");
  }
}

async function pdfDownloadAttach(){
  try{
    const obj = state.pdfAttach;
    if(!obj || !obj.bytes || !obj.bytes.length){
      log("WARN: 添付ファイルがありません。");
      return;
    }
    const kind = obj.kind || _fileKindFromName(obj.name) || _fileKindFromMime(obj.mime) || "FILE";
    const mime = obj.mime || _fileMimeForKind(kind) || "application/octet-stream";
    const name = (obj.name && String(obj.name).trim()) ? String(obj.name) : ("attached" + (_fileExtForKind(kind) || ""));
    const res = await saveExportBytes(obj.bytes, name);
    if(res?.mode === "cancel"){
      log("INFO: 保存をキャンセルしました。");
      return;
    }
    log(`OK: 添付ファイルを保存しました: ${name}`);
  }catch(err){
    console.error(err);
    log("ERR: ダウンロードに失敗しました。");
  }
}

function pdfCloseViewer(){

  const dlg = document.getElementById("pdfViewDialog");
  const frame = document.getElementById("pdfViewerFrame");
  if(frame) frame.src = "about:blank";
  if(state.pdfViewUrl){ try{ URL.revokeObjectURL(state.pdfViewUrl);}catch(_){}
    state.pdfViewUrl=null;
  }
  try{ dlg?.close(); }catch(_){ if(dlg) dlg.open=false; }
}

function setupPdfDialog(){
  const btn = document.getElementById("btnPdfAttach");
  const dlg = document.getElementById("pdfAttachDialog");
  if(!btn || !dlg) return;

  const open = ()=>{ attachSyncLegacy(); attachRenderList(); _pdfUI_set(state.pdfAttach); try{ dlg.showModal(); }catch(_){ dlg.open=true; } };
  const close = ()=>{ try{ dlg.close(); }catch(_){ dlg.open=false; } };

  btn.addEventListener("click", open);
  document.getElementById("btnPdfAttachClose")?.addEventListener("click", close);
  dlg.addEventListener("click", (e)=>{ if(e.target===dlg) close(); });

  document.getElementById("btnPdfAttachView")?.addEventListener("click", pdfOpenViewer);
  document.getElementById("btnPdfAttachDownload")?.addEventListener("click", pdfDownloadAttach);
  document.getElementById("btnPdfAttachClear")?.addEventListener("click", ()=>{
    attachRemoveSelected("添付ファイル「{name}」を解除しますか？\nこの操作は元に戻せません。");
  });

  document.getElementById("btnPdfViewClose")?.addEventListener("click", pdfCloseViewer);
  const vdlg = document.getElementById("pdfViewDialog");
  vdlg?.addEventListener("click", (e)=>{ if(e.target===vdlg) pdfCloseViewer(); });

  const zone = document.getElementById("pdfAttachDrop");
  const input = document.getElementById("pdfAttachInput");
  const pickBtn = document.getElementById("btnPdfAttachPick");
  pickBtn?.addEventListener("click", ()=>{ try{ input?.click(); }catch(_){ } });

  const handleFile = async (f)=>{
    if(!f) return;
    const kind = _fileDetectKind(f);
    if(!kind){
      log("WARN: 対応形式（CSV / PDF / XML / TEXT）以外が選択/ドロップされました。");
      return;
    }
    if(!Array.isArray(state.attachments)) state.attachments = [];
    if(state.attachments.length >= 9){
      log("WARN: 添付は最大9件です。");
      return;
    }
    const ab = await f.arrayBuffer();
    const nName = (f.name && f.name.normalize) ? f.name.normalize("NFC") : f.name;
    attachAdd({ name: nName, bytes: new Uint8Array(ab), kind: kind, mime: f.type });
    log(`OK: ファイルを添付しました: ${nName}（${kind} / 書き出しでWAVへ保存）`);
  };

  input?.addEventListener("change", (e)=>{ const f=e.target.files?.[0]; handleFile(f); e.target.value=""; });
  if(zone){
    zone.addEventListener("dragover", (e)=>{ e.preventDefault(); e.stopPropagation(); zone.classList.add("drag"); });
    zone.addEventListener("dragleave", (e)=>{ e.preventDefault(); e.stopPropagation(); zone.classList.remove("drag"); });
    zone.addEventListener("drop", (e)=>{ e.preventDefault(); e.stopPropagation(); zone.classList.remove("drag"); handleFile(e.dataTransfer?.files?.[0]); });

  // Allow file drop anywhere inside the attach dialog (not only the drop zone)
  // Note: ignore internal drag-reorder (it uses text/plain, not Files)
  const _isFileDrag = (e)=>{
    const dt = e?.dataTransfer;
    if(!dt) return false;
    try{
      const types = Array.from(dt.types || []);
      return types.includes("Files") || types.includes("application/x-moz-file");
    }catch(_){ return false; }
  };
  const _setWholeDrag = (on)=>{
    try{
      if(zone){
        if(on) zone.classList.add("drag");
        else zone.classList.remove("drag");
      }
      if(on) dlg.classList.add("dragFile");
      else dlg.classList.remove("dragFile");
    }catch(_){}
  };

  dlg.addEventListener("dragover", (e)=>{
    if(!_isFileDrag(e)) return;
    e.preventDefault(); e.stopPropagation();
    try{ if(e.dataTransfer) e.dataTransfer.dropEffect="copy"; }catch(_){}
    _setWholeDrag(true);
  }, {passive:false});

  dlg.addEventListener("dragleave", (e)=>{
    if(!_isFileDrag(e)) return;
    // Only when leaving dialog boundary
    if(e.relatedTarget && dlg.contains(e.relatedTarget)) return;
    _setWholeDrag(false);
  });

  dlg.addEventListener("drop", (e)=>{
    if(!_isFileDrag(e)) return;
    e.preventDefault(); e.stopPropagation();
    _setWholeDrag(false);
    const f = e.dataTransfer?.files?.[0];
    if(f) handleFile(f);
  }, {passive:false});

  }

  // list: select + drag reorder
  const list = document.getElementById("attachList");
  if(list){
    list.addEventListener("click", (e)=>{
      const item = e.target.closest(".attachItem");
      if(item && item.dataset.id) attachSelectById(item.dataset.id);
    });

    let dragId = null;

    list.addEventListener("dragstart", (e)=>{
      const h = e.target.closest(".dragHandle");
      if(!h) return;
      const item = h.closest(".attachItem");
      if(!item) return;
      dragId = item.dataset.id;
      item.classList.add("dragging");
      try{ e.dataTransfer.effectAllowed = "move"; e.dataTransfer.setData("text/plain", dragId); }catch(_){ }
    });

    list.addEventListener("dragover", (e)=>{
      if(!dragId) return;
      e.preventDefault();
      const dragging = list.querySelector(`.attachItem[data-id="${dragId}"]`);
      const over = e.target.closest(".attachItem");
      if(!dragging || !over || over===dragging) return;
      const r = over.getBoundingClientRect();
      const after = (e.clientY - r.top) > (r.height/2);
      list.querySelectorAll(".attachItem").forEach(el=>el.classList.remove("dragOver"));
      over.classList.add("dragOver");
      list.insertBefore(dragging, after ? over.nextSibling : over);
    });

    list.addEventListener("dragleave", (_)=>{
      list.querySelectorAll(".attachItem").forEach(el=>el.classList.remove("dragOver"));
    });

    list.addEventListener("drop", (e)=>{
      if(!dragId) return;
      e.preventDefault();
      list.querySelectorAll(".attachItem").forEach(el=>el.classList.remove("dragOver"));
    });

    list.addEventListener("dragend", (_)=>{
      if(!dragId) return;
      const ids = Array.from(list.querySelectorAll(".attachItem")).map(el=>el.dataset.id);
      const old = Array.isArray(state.attachments) ? state.attachments : [];
      const map = new Map(old.map(a=>[a.id,a]));
      const reordered = ids.map(id=>map.get(id)).filter(Boolean);
      state.attachments = reordered;
      const sel = reordered.findIndex(a=>a && a.id===dragId);
      state.attachSel = sel>=0 ? sel : 0;
      attachSyncLegacy();
      attachRenderList();
      _pdfUI_set(state.pdfAttach);
      const rec = _syncActiveRecAttachments();
      if(rec){
        console.log("[PDF]", "reorder", { fileId: rec.id, count: rec.attachments.length });
        if(typeof window.commitAll === "function"){
          window.commitAll("pdf:reorder", { fileId: rec.id });
        }
      }
      dragId = null;
    });
  }

  attachSyncLegacy();
  attachRenderList();
  _pdfUI_set(state.pdfAttach);
}

function _exportCueId(label){
  const s = String(label||"").trim();
  if(s==="BC$STANDBY") return 1;
  if(s==="BC$END") return 2;
  if(s==="BC$START") return 3;
  if(s==="BC$STOP") return 4;
  const m = /^BC\$NOTE\(?(\d+)\)?$/i.exec(s.replace(/\s+/g,""));
  if(m){
    const n = parseInt(m[1],10);
    if(isFinite(n) && n>=1 && n<=9) return 4+n; // NOTE1..NOTE9 => 5..13
  }
  if(s==="BC$NOTE1") return 5;
  return null;
}
// ===== PDF_ATTACH_V1_END =====


function _base64FromUint8(u8){
  let s = "";
  const chunk = 0x8000;
  for(let i=0; i<u8.length; i+=chunk){
    s += String.fromCharCode.apply(null, u8.subarray(i, i+chunk));
  }
  return btoa(s);
}

function _base64FromArrayBuffer(ab){
  return _base64FromUint8(new Uint8Array(ab));
}

function _baseNameFromPath(pathLike){
  return String(pathLike || "").split(/[\\/]/).pop();
}

async function saveExportBytes(bytes, defaultName, onPhase){
  if(!window.wavcue || !window.wavcue.saveExportFile){
    throw new Error("saveExportFile is unavailable.");
  }
  const u8 = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
  try{ onPhase && onPhase("picker_open"); }catch(_){}
  const res = await window.wavcue.saveExportFile({
    defaultName,
    dataBase64: _base64FromUint8(u8),
  });
  if(res?.canceled){
    try{ onPhase && onPhase("cancel"); }catch(_){}
    return { mode: "cancel" };
  }
  if(!res?.ok){
    throw new Error(res?.error || "save failed");
  }
  try{ onPhase && onPhase("picked"); }catch(_){}
  try{ onPhase && onPhase("writing"); }catch(_){}
  try{ onPhase && onPhase("done"); }catch(_){}
  return { mode: "ipc", filePath: res.filePath, suggested: defaultName };
}

// ===== SAVE JSON (Electron dialog) =====
async function _saveJsonWithFallback(blob, filename){
  const suggested = (filename && String(filename).trim()) ? filename : "BWFJ_qc_presets.json";
  try{
    const res = await saveExportBytes(await blob.arrayBuffer(), suggested);
    if(res?.mode === "cancel"){
      log("INFO: JSON書き出しをキャンセルしました");
      return { mode: "cancel" };
    }
    const savedName = _baseNameFromPath(res?.filePath) || suggested;
    log(`OK: JSONを書き出しました: ${savedName}`);
    return res;
  }catch(e){
    log(`WARN: JSON保存に失敗: ${e?.message || e}`);
    throw e;
  }
}

// ===== SAVE (Electron dialog) =====
async function _saveBlobWithFallback(blob, filename, onPhase){
  try{
    const suggested = (filename && String(filename).trim()) ? filename : "output.wav";
    try{ onPhase && onPhase("writing"); }catch(_){}
    const res = await saveExportBytes(await blob.arrayBuffer(), suggested, onPhase);
    if(res?.mode === "cancel"){
      return { mode: "cancel" };
    }
    const savedName = _baseNameFromPath(res?.filePath) || suggested;
    log(`OK: 保存しました: ${savedName}`);
    return res;
  }catch(e){
    log(`ERROR: 保存に失敗: ${e?.name||"Error"} ${e?.message||""}`);
    throw e;
  }
}
// ===== /SAVE =====

// ===== RIFF extract helpers (for canonical export) =====
function _riffExtractChunkPayload(ab, id4){
  const u8 = new Uint8Array(ab);
  const dv = new DataView(ab);
  const u32 = (o)=>dv.getUint32(o,true);
  const str4 = (o)=>String.fromCharCode(u8[o],u8[o+1],u8[o+2],u8[o+3]);
  if(str4(0)!=="RIFF" || str4(8)!=="WAVE") return null;
  let off = 12;
  while(off + 8 <= u8.length){
    const cid = str4(off);
    const size = u32(off+4);
    const data = off+8;
    const end = data+size;
    if(cid === id4){
      return new Uint8Array(ab, data, size); // payload only
    }
    off = end + (size%2);
  }
  return null;
}
function _makeChunk(id4, payloadU8){
  const payloadLen = payloadU8 ? payloadU8.length : 0;
  const pad = payloadLen % 2;
  const out = new Uint8Array(8 + payloadLen + pad);
  out[0]=id4.charCodeAt(0); out[1]=id4.charCodeAt(1); out[2]=id4.charCodeAt(2); out[3]=id4.charCodeAt(3);
  new DataView(out.buffer).setUint32(4, payloadLen, true);
  if(payloadLen) out.set(payloadU8, 8);
  return out;
}
function _buildCanonicalWavFromParts(parts){
  // parts: Uint8Array[] chunks (already include 8+payload+pad)
  const total = 4 + parts.reduce((a,b)=>a+b.length,0); // "WAVE"+chunks
  const out = new Uint8Array(8 + total);
  out.set([82,73,70,70], 0); // RIFF
  new DataView(out.buffer).setUint32(4, total, true);
  out.set([87,65,86,69], 8); // WAVE
  let p = 12;
  for(const ch of parts){
    out.set(ch, p);
    p += ch.length;
  }
  return out.buffer;
}
// ===== /RIFF extract helpers =====

/* ===== ChunkDialog UI: tabs + structured views ===== */
function _kv(v){ return (v==null) ? "" : String(v); }
function renderKVGrid(grid, rows){
  if(!grid) return;
  grid.innerHTML = "";
  for(const [k,v] of rows){
    const dk = document.createElement("div");
    dk.className = "kvK";
    dk.textContent = k;
    const dv = document.createElement("div");
    dv.className = "kvV";
    dv.textContent = _kv(v);
    grid.appendChild(dk);
    grid.appendChild(dv);
  }
}

function _trimNullAndSpace(s){
  return (s||"").replace(/\u0000+$/g,"").trim();
}

function parseBextPayload(u8){
  try{
    if(!u8 || u8.length < 602) return null;
    const dec = new TextDecoder("latin1");
    const getStr = (off,len)=> _trimNullAndSpace(dec.decode(u8.slice(off, off+len)));
    const Description = getStr(0,256);
    const Originator = getStr(256,32);
    const OriginatorReference = getStr(288,32);
    const OriginationDate = getStr(320,10);
    const OriginationTime = getStr(330,8);

    const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
    const timeLow = dv.getUint32(338, true);
    const timeHigh = dv.getUint32(342, true);
    const Version = dv.getUint16(346, true);

    const umid = u8.slice(348, 348+64);
    let umidHex = "";
    for(const b of umid){ umidHex += b.toString(16).padStart(2,"0"); }

    let coding = "";
    try{
      const hist = u8.slice(602);
      let end = hist.length;
      for(let i=0;i<hist.length;i++){ if(hist[i]===0){ end=i; break; } }
      coding = _trimNullAndSpace(dec.decode(hist.slice(0,end)));
    }catch(_){}

    const timeSamples = ((BigInt(timeHigh) << 32n) | BigInt(timeLow)).toString();

    return {
      Description, Originator, OriginatorReference, OriginationDate, OriginationTime,
      TimeReferenceSamples: timeSamples,
      Version: String(Version),
      UMID_hex: umidHex,
      CodingHistory: coding
    };
  }catch(_){
    return null;
  }
}

function refreshBextView(){
  const grid = $("bextViewGrid");
  const meta = $("bextMeta");
  if(!grid) return;

  const rowsBlank = [
    ["Description",""],
    ["Originator",""],
    ["OriginatorReference",""],
    ["OriginationDate",""],
    ["OriginationTime",""],
    ["TimeReference (samples)",""],
    ["Version",""],
    ["UMID (hex)",""]
  ];

  if(!(state && state.srcBextPayload)){
    if(meta) meta.textContent = "bext: なし";
    renderKVGrid(grid, rowsBlank);
    return;
  }
  const payload = new Uint8Array(state.srcBextPayload);
  const obj = parseBextPayload(payload);
  if(!obj){
    if(meta) meta.textContent = `bext: 解析失敗（${payload.length} bytes）`;
    renderKVGrid(grid, rowsBlank);
    return;
  }
  const rows = [
    ["Description", obj.Description],
    ["Originator", obj.Originator],
    ["OriginatorReference", obj.OriginatorReference],
    ["OriginationDate", obj.OriginationDate],
    ["OriginationTime", obj.OriginationTime],
    ["TimeReference (samples)", obj.TimeReferenceSamples],
    ["Version", obj.Version],
    ["UMID (hex)", obj.UMID_hex]
  ];
  renderKVGrid(grid, rows);
  if(meta) meta.textContent = `bext: ${payload.length} bytes / 表示項目 ${rows.length}/${rows.length}`;
}

function refreshCmcdView(){
  const grid = $("cmcdViewGrid");
  const meta = $("cmcdMeta");
  if(!grid) return;

  let filled = 0;
  const rows = [];
  for(const k of CMCD_KEYS_UI){
    const v = document.querySelector(`[data-cmcd="${k}"]`)?.value || "";
    rows.push([k, v]);
    if(k!=="Ver" && (v||"").trim()) filled++;
  }
  renderKVGrid(grid, rows);

  const has = (state && state.cmcdBytes && state.cmcdBytes.length===2048);
  if(meta) meta.textContent = has ? `cmcd: 2048 bytes / 入力値 ${filled}/${CMCD_KEYS_UI.length-1}` : "cmcd: なし";
}

function setChunkTab(tab){
  const dlg = $("chunkDialog");
  if(!dlg) return;
  dlg.querySelectorAll(".tabBtn").forEach(b=>{
    const on = (b.dataset.tab===tab);
    b.classList.toggle("active", on);
    b.setAttribute("aria-selected", on ? "true" : "false");
  });
  dlg.querySelectorAll(".tabPanel").forEach(p=>{
    const on = (p.dataset.tabpanel===tab);
    p.classList.toggle("active", on);
  });
}

function initChunkTabsOnce(){
  const dlg = $("chunkDialog");
  if(!dlg || dlg.dataset.tabsReady==="1") return;
  dlg.dataset.tabsReady = "1";
  dlg.querySelectorAll(".tabBtn").forEach(btn=>{
    btn.addEventListener("click", ()=> setChunkTab(btn.dataset.tab || "bext"));
  });
  setChunkTab("bext");
}

function refreshChunkDialogViews(){
  try{ renderCmcdForm(); }catch(_){}
  try{ refreshBextView(); }catch(_){}
  try{ refreshCmcdView(); }catch(_){}
  try{
    const grid = $("chunkPresenceGrid");
    if(!grid) return;

    const fmtBytes = (n)=>{
      if(!isFinite(n) || n < 0) return "—";
      if(n < 1024) return `${n} B`;
      if(n < 1024*1024) return `${(n/1024).toFixed(1)} KB`;
      return `${(n/1024/1024).toFixed(2)} MB`;
    };

    const rows = [];

    // iXML: presence only (no content, no copy)
    const hasIXml = !!(state && state.srcIXmlPayload);
    const ixmlBytes = hasIXml ? (new Uint8Array(state.srcIXmlPayload)).length : 0;
    rows.push(["iXML", hasIXml ? `あり (${fmtBytes(ixmlBytes)})` : "なし"]);

    // Other (pass-through) chunks: show brief list
    const keepKeys = new Set(["bext","fmt ","data","cmcd","cue ","plst","LIST:adtl","iXML"]);
    const others = [];
    if(state && Array.isArray(state.srcChunks)){
      for(const ch of state.srcChunks){
        const key = (ch.id==="LIST" && ch.listType) ? `LIST:${ch.listType}` : ch.id;
        if(!keepKeys.has(key)){
          const payloadBytes = Math.max(0, ch.size>>>0);
          others.push({key, bytes: payloadBytes});
        }
      }
    }
    if(others.length){
      const preview = others
        .slice(0,8)
        .map(o=>`${o.key} (${fmtBytes(o.bytes)})`)
        .join(", ") + (others.length>8 ? " …" : "");
      rows.push(["未知/保持チャンク", `${others.length}個`]);
      rows.push(["内訳", preview]);
    }else{
      rows.push(["未知/保持チャンク", "0個"]);
    }

    renderKVGrid(grid, rows);
  }catch(_){}
  try{ updateDiffUI(); }catch(_){ }
}


(function(){
  const open = $("btnChunk");
  const close = $("btnCloseDialog");
  const dlg = $("chunkDialog");

  if(open && dlg){
    open.addEventListener("click", ()=>{
      initChunkTabsOnce();
      refreshChunkDialogViews();
      document.body.classList.add("modalLock");
      dlg.addEventListener("close", ()=> document.body.classList.remove("modalLock"), {once:true});
      dlg.showModal();
    });
  }
  if(close && dlg){
    close.addEventListener("click", ()=>{
      document.body.classList.remove("modalLock");
      dlg.close();
    });
  }

  const btnOpen = $("btnOpenCmcdDialogFromChunk");
  if(btnOpen){
    btnOpen.addEventListener("click", ()=>{
      try{ renderCmcdForm(); }catch(_){}
      $("cmcdDialog")?.showModal?.();
    });
  }

  const btnLogCopy = $("btnLogCopy");
  if(btnLogCopy){
    btnLogCopy.addEventListener("click", async()=>{
      const snap = collectDiagnosticText([`trigger: log-copy`]);
      const body = getLogText() || "";
      const text = snap + "\n\n---\n\n" + body;
      await copyTextToClipboard(text);
    });
  }

  const btnLogExport = $("btnLogExport");
  if(btnLogExport){
    btnLogExport.addEventListener("click", async()=>{
      const name = `WavCue_Log_${_tsStamp()}.txt`;
      const snap = collectDiagnosticText([`trigger: log-export`]);
      const body = getLogText() || "";
      const text = snap + "\n\n---\n\n" + body;
      const logRes = await downloadTextFile(name, text);
      if(logRes?.mode !== "cancel"){
        log(`OK: ログを書き出しました: ${name}`);
      }
    });
  }
})();
/* ===== /ChunkDialog UI ===== */



/* ===== ProTools+ UX: scroll shadows for chunk dialog panels ===== */
(function(){
  function applyShadows(el){
    if(!el) return;
    const top = el.scrollTop > 2;
    const bottom = (el.scrollHeight - el.clientHeight - el.scrollTop) > 2;
    el.classList.toggle("scrollShadowTop", top);
    el.classList.toggle("scrollShadowBottom", bottom);
  }

  function init(){
    const dlg = document.getElementById("chunkDialog");
    if(!dlg) return;

    // Track currently visible panels
    const panels = dlg.querySelectorAll(".tabPanel");
    panels.forEach(p=>{
      p.addEventListener("scroll", ()=>applyShadows(p), {passive:true});
      // initial
      requestAnimationFrame(()=>applyShadows(p));
    });

    // When tab changes, update shadows after layout
    const tabBar = dlg.querySelector(".tabBar");
    if(tabBar){
      tabBar.addEventListener("click", ()=>{
        requestAnimationFrame(()=>{
          panels.forEach(p=>applyShadows(p));
        });
      });
    }

    // On open, refresh once
    dlg.addEventListener("toggle", ()=>{
      requestAnimationFrame(()=>panels.forEach(p=>applyShadows(p)));
    });
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", init, {once:true});
  }else{
    init();
  }
})();
 /* ===== /ProTools+ UX ===== */



/* ===== UX fix: never show WAV drop overlay after closing PDF attach ===== */
function initUxFix_NoDropOverlayAfterPdfAttachClose(){
  const dlg = document.getElementById("pdfAttachDialog");
  const ov = document.getElementById("dropOverlay");
  if(!dlg || !ov) return;
  const hideOv = ()=>{ ov.classList.remove("show");  };
  dlg.addEventListener("close", hideOv);
  dlg.addEventListener("cancel", hideOv);
}
initUxFix_NoDropOverlayAfterPdfAttachClose();
/* ===== /UX fix ===== */

/* ===============================
   DEBUG SURFACE (optional)
   - Minimal export for debugging; safe to ignore.
   - Provides stable names for console inspection (does not affect UI).
================================ */
try{
  // Back-compat (older notes): window.BWFJ
  window.BWFJ = window.BWFJ || {};
  window.BWFJ.CFG = CFG;
  window.BWFJ.state = state;

  // Preferred product name: window.WavCue
  window.WavCue = window.WavCue || {};
  window.WavCue.CFG = CFG;
  window.WavCue.state = state;

  // A small, intentionally limited API surface (dev use only)
  window.WavCue.api = Object.freeze({
    // Primary entry points (stable)
    loadFile,
    exportWav,

    // Structured, read-only navigation map for maintainers (no runtime dependency).
    // NOTE: These references do NOT change how the app works; they simply expose
    // already-declared functions/objects in a grouped way for easier discovery.
    modules: Object.freeze({
      progress: Object.freeze({
        show: _prog.show,
        set: _prog.set,
        hide: _prog.hide,
      }),

      riff: Object.freeze({
        parseRiffChunks,
        _riffExtractChunkPayload,
        rebuildWaveFromOriginal,
        rebuildWaveFromOriginalCanonical,
        _makeChunk,
        _buildCanonicalWavFromParts,
      }),

      cue: Object.freeze({
        parseWavCues,
        normalizeCueIds,
        buildCueChunks,
        applyCueInPlacePatch,
        _exportCueId,
      }),

      chunks: Object.freeze({
        buildChunkFromPayload,
        buildBextChunk,
        buildIXmlChunk,
        buildCmcdChunkFixed2048,
        encodeWavPCM16WithCues,
      }),

      pdf: Object.freeze({
        pdfFindInWav,
        pdfFindAllInWav,
        pdfBuildFileSubchunk,
      }),

      waveform: Object.freeze({
        drawWaveform,
        buildPeaks,
        _forceWaveRedraw,
      }),
    }),
  });
}catch(_){/* ignore */}

})();


(function(){
  const project = {
    files:[],
    activeId:null,
    lastLoadedId:null,
    selectedIds:new Set(),
    filter:{status:'all'},
    lastClickIndex:null,
    popover:{openType:null, openFileId:null, anchorEl:null},
    historyTriggerLogged:false
  };
  const job = { running:false, cancel:false, failed:[], done:0, total:0, ok:0 };
  const history = { entries:[], active:null, selectedId:null };

  (function ensureGlobalLog(){
    if(typeof window.log === "function") return;

    const pad2 = (n)=> String(n).padStart(2,"0");
    const nowTime = ()=> {
      const d = new Date();
      return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
    };

    window.log = function(msg){
      try{
        const line = document.createElement("div");
        line.className = "logLine";
        line.textContent = `[${nowTime()}] ${String(msg ?? "")}`;

        const box = document.getElementById("logBox");
        if(box) box.prepend(line);

        const box2 = document.getElementById("logBox2");
        if(box2){
          const line2 = line.cloneNode(true);
          box2.prepend(line2);
        }

        if(!box && !box2){
          console.log("[LOG]", msg);
        }
      }catch(err){
        console.log("[LOG][fallback]", msg, err);
      }
    };
  })();

  function esc(str){ return String(str).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
  function uid(){ return 'f_' + Math.random().toString(16).slice(2) + Date.now().toString(16); }
  function $(id){ return document.getElementById(id); }
  const bulkOverlay = (()=> {
    let ov=null, msg=null, pctEl=null, bar=null, sub=null, now=null;
    const ensure = ()=>{
      if(ov) return;
      ov = $("bulkOverlay");
      msg = $("bulkMsg");
      pctEl = $("bulkPct");
      bar = $("bulkBar");
      sub = $("bulkSub");
      now = $("bulkNow");
    };
    const titleFor = (type)=> type==="qc" ? "一括規格チェック中..." : "一括書き出し中...";
    const start = (type, total)=>{
      ensure();
      if(!ov) return;
      if(msg) msg.textContent = titleFor(type);
      if(pctEl) pctEl.textContent = "0%";
      if(bar) bar.style.width = "0%";
      if(sub) sub.textContent = `0/${total} (0%)`;
      if(now) now.textContent = "";
      ov.classList.add("show");
      console.log(`[Overlay] bulk:start type=${String(type||"")} total=${total}`);
    };
    const update = (done, total, filename)=>{
      ensure();
      if(!ov) return;
      const pct = total ? Math.round((done/total)*100) : 0;
      if(pctEl) pctEl.textContent = `${pct}%`;
      if(bar) bar.style.width = `${pct}%`;
      if(sub) sub.textContent = `${done}/${total} (${pct}%)`;
      if(now) now.innerHTML = filename ? `処理中: <span class="nowFile">${esc(filename)}</span>` : "";
    };
    const end = (type, status)=>{
      ensure();
      if(!ov) return;
      ov.classList.remove("show");
      console.log(`[Overlay] bulk:end type=${String(type||"")} status=${status}`);
    };
    return { start, update, end };
  })();
  const W = window.WavCue || {};
  const api = W.api || {};
  const loadSingleWav =
    (typeof loadFile === "function")
      ? loadFile
      : ((typeof api.loadFile === "function") ? api.loadFile : null);
  function safeLog(msg){
    try{
      if(typeof window?.log === "function"){ window.log(msg); return; }
      if(typeof log === "function"){ log(msg); return; }
    }catch(_){}
    try{ console.log(msg); }catch(_){}
  }
  const audioCache = { map: new Map(), totalBytes: 0 };
  const _getCFG = ()=>{
    return (window.WavCue && window.WavCue.CFG) ? window.WavCue.CFG
      : ((window.BWFJ && window.BWFJ.CFG) ? window.BWFJ.CFG
      : ((typeof CFG !== "undefined") ? CFG : null));
  };
  const _cfg0 = _getCFG() || {};
  const audioCacheCfg = {
    capBytes: Math.max(0, (Number(_cfg0.PRO_AUDIO_CACHE_CAP_MB) || 768) * 1024 * 1024),
    margin: (Number(_cfg0.PRO_AUDIO_CACHE_MARGIN) || 0.92),
    lowWater: (Number(_cfg0.PRO_AUDIO_CACHE_LOW_WATER) || 0.80),
  };
  function audioCacheLimits(){
    const cap = audioCacheCfg.capBytes;
    return {
      cap,
      hi: cap * audioCacheCfg.margin,
      low: cap * audioCacheCfg.lowWater,
    };
  }
  function audioCacheBytes(buf){
    if(!buf) return 0;
    return Math.max(0, (buf.length || 0) * (buf.numberOfChannels || 1) * 4);
  }
  function audioCacheLog(action, detail){
    try{
      const extra = detail ? ` ${JSON.stringify(detail)}` : "";
      console.log(`[Pro][AudioCache] ${action}${extra}`);
    }catch(_){
      console.log(`[Pro][AudioCache] ${action}`);
    }
  }
  function audioCacheEvictToFit(bytesNeeded){
    const { hi, low } = audioCacheLimits();
    if(audioCache.totalBytes + bytesNeeded <= hi) return;
    const target = Math.max(low, hi - bytesNeeded);
    const activeId = project.activeId;
    const pickCandidate = ()=>{
      let oldest = null;
      let oldestActive = null;
      for(const [id, entry] of audioCache.map){
        if(id === activeId){
          if(!oldestActive || entry.usedAt < oldestActive.usedAt) oldestActive = entry;
          continue;
        }
        if(!oldest || entry.usedAt < oldest.usedAt) oldest = entry;
      }
      return oldest || oldestActive || null;
    };
    while(audioCache.totalBytes > target || (audioCache.totalBytes + bytesNeeded > hi)){
      const candidate = pickCandidate();
      if(!candidate) break;
      audioCache.map.delete(candidate.id);
      audioCache.totalBytes = Math.max(0, audioCache.totalBytes - candidate.bytes);
      audioCacheLog("evict", { id: candidate.id, name: candidate.name, mb: (candidate.bytes/1024/1024).toFixed(1) });
      if(audioCache.totalBytes <= target && audioCache.totalBytes + bytesNeeded <= hi) break;
    }
  }
  function audioCacheRemember(rec, buffer, peaks){
    if(!rec || !buffer) return false;
    const { hi } = audioCacheLimits();
    const bytes = audioCacheBytes(buffer);
    if(bytes <= 0) return false;
    if(bytes > hi){
      rec._audioCachePolicy = "oversize-nocache";
      audioCacheLog("skip oversize", { id: rec.id, name: rec.name, mb: (bytes/1024/1024).toFixed(1) });
      return false;
    }
    if(audioCache.map.has(rec.id)){
      const prev = audioCache.map.get(rec.id);
      if(prev && prev.bytes) audioCache.totalBytes = Math.max(0, audioCache.totalBytes - prev.bytes);
      audioCache.map.delete(rec.id);
    }
    audioCacheEvictToFit(bytes);
    if(audioCache.totalBytes + bytes > hi){
      audioCacheLog("skip", { id: rec.id, name: rec.name, reason: "no-space" });
      return false;
    }
    const entry = {
      id: rec.id,
      name: rec.name,
      buffer,
      peaks,
      bytes,
      usedAt: Date.now(),
    };
    audioCache.map.set(rec.id, entry);
    audioCache.totalBytes += bytes;
    rec._audioCachePolicy = "cached";
    audioCacheLog("remember", { id: rec.id, name: rec.name, mb: (bytes/1024/1024).toFixed(1) });
    return true;
  }
  function audioCacheApply(rec){
    if(!rec) return false;
    const entry = audioCache.map.get(rec.id);
    if(!entry) return false;
    entry.usedAt = Date.now();
    state.buffer = entry.buffer;
    state.origBuffer = entry.buffer;
    state.peaks = entry.peaks;
    state.sr = entry.buffer.sampleRate;
    rec._audioCachePolicy = "cached";
    audioCacheLog("apply", { id: rec.id, name: rec.name });
    return true;
  }
  function audioCacheHas(rec){
    if(!rec) return false;
    return audioCache.map.has(rec.id);
  }
  async function proEnsureAudioElSafe(){
    try{
      if(typeof ensureAudioEl === "function") return ensureAudioEl();
    }catch(_){}
    if(state.audioEl) return state.audioEl;
    const a = new Audio();
    a.preload = "auto";
    a.addEventListener("ended", ()=>{
      state.isPlaying = false;
      try{ if(typeof stopRaf === "function") stopRaf(); }catch(_){}
      try{ if(typeof setPlayhead === "function") setPlayhead(state.playStartSec || 0); }catch(_){}
      try{ if(typeof ensureVisibleSec === "function") ensureVisibleSec(currentPlayheadSec()); }catch(_){}
      try{ if(typeof updateButtons === "function") updateButtons(); }catch(_){}
      try{ if(typeof drawAll === "function") drawAll(); }catch(_){}
    });
    state.audioEl = a;
    return a;
  }
  async function proEnsureAudioSrc(rec){
    if(!rec?.file) return;
    const audio = await proEnsureAudioElSafe();
    if(state.previewUrl){ try{ URL.revokeObjectURL(state.previewUrl); }catch(_){ } state.previewUrl=null; }
    if(state.audioUrl){ try{ URL.revokeObjectURL(state.audioUrl); }catch(_){ } }
    state.audioUrl = URL.createObjectURL(rec.file);
    audio.src = state.audioUrl;
    audio.currentTime = 0;
    state.isPlaying = false;
  }
  function proApplyStateSnapshot(rec){
    const snap = rec?._stateSnap;
    if(!snap) return;
    const keys = [
      "srcAb","srcFmtPayload","srcDataPayload","srcBextPayload","srcIXmlPayload","srcCmcdPayload",
      "srcChunks","fileSr","fileBlockAlign","fileTotalSamples","_pcmInfo","cuePatchMeta","loadedCueSig",
    ];
    keys.forEach((k)=>{ if(snap[k] != null) state[k] = snap[k]; });
  }
  function proComputeAnalysisFromState(rec){
    if(!rec || !state.buffer) return null;
    const range = _ecFindRange();
    const startSec = range.hasSeg ? range.start : 0;
    const endSec = range.hasSeg ? range.end : state.buffer.duration;
    const lufsRes = _ecComputeIntegratedLufs(state.buffer, startSec, endSec);
    const lufs = (lufsRes && isFinite(lufsRes.lufs)) ? lufsRes.lufs : null;
    const pk = _ecComputePeaks(state.buffer, startSec, endSec);
    const tpDb = (pk && pk.truePeak != null && pk.truePeak > 0) ? (20*Math.log10(pk.truePeak)) : null;
    const fmt = _ecParseFmtInfo();
    const sil = _scComputeHeadTailSilence(state.buffer, startSec, endSec, (Number(_cfg0.STDCHK_SILENCE_THRESHOLD_DB) || -60));
    const analysis = {
      integratedLufs: lufs,
      truePeakDbtp: (tpDb != null && isFinite(tpDb)) ? tpDb : null,
      rangeStartSec: startSec,
      rangeEndSec: endSec,
      measuredAt: Date.now(),
      sr: fmt?.sampleRate || state.buffer.sampleRate,
      ch: fmt?.numChannels || state.buffer.numberOfChannels,
      durSec: state.buffer.duration,
      bits: (fmt && isFinite(fmt.bitsPerSample)) ? fmt.bitsPerSample : null,
      clipCount: pk?.clipped ?? 0,
      headSilenceSec: sil?.headSec ?? 0,
      tailSilenceSec: sil?.tailSec ?? 0,
      hasSound: (sil?.hasSound !== false),
    };
    rec.analysis = analysis;
    return analysis;
  }
  function proBuildQcResultFromAnalysis(rec){
    const analysis = rec?.analysis;
    if(!analysis) return null;
    const presetId = state.qcPresetId || _cfg0.QC_DEFAULT_PRESET_ID || null;
    const preset = _scGetPresetById(presetId);
    if(!preset) return null;

    const lufs = analysis.integratedLufs;
    let lufsKind = "warn";
    if(lufs != null && preset){
      lufsKind = (Math.abs(lufs - preset.targetLufs) <= preset.tolLufs) ? "ok" : "ng";
    }
    const lufsReason = (lufs != null && preset) ? (
      (lufsKind==="ok")
        ? `OK（目標 ${preset.targetLufs.toFixed(1)} ±${preset.tolLufs.toFixed(1)} / 実測 ${lufs.toFixed(1)}）`
        : `許容範囲外（目標 ${preset.targetLufs.toFixed(1)} ±${preset.tolLufs.toFixed(1)} → 許容 [${(preset.targetLufs-preset.tolLufs).toFixed(1)}, ${(preset.targetLufs+preset.tolLufs).toFixed(1)}] / 実測 ${lufs.toFixed(1)}）`
    ) : "";

    const tpDb = analysis.truePeakDbtp;
    let tpKind = "warn";
    if(tpDb != null && preset){
      tpKind = (tpDb <= preset.maxTruePeakDb) ? "ok" : "ng";
    }
    const tpReason = (tpDb != null && preset && isFinite(tpDb)) ? (
      (tpKind==="ok")
        ? `OK（上限 ${preset.maxTruePeakDb.toFixed(2)} dBTP / 実測 ${tpDb.toFixed(2)} dBTP）`
        : `上限超過（上限 ${preset.maxTruePeakDb.toFixed(2)} dBTP / 実測 ${tpDb.toFixed(2)} dBTP）`
    ) : "";

    const sr = analysis.sr;
    const bd = analysis.bits;
    const chN = analysis.ch;
    let srKind="warn", bdKind="warn", chKind="warn";
    if(preset){
      const srList = Array.isArray(preset.allowedSampleRates) ? preset.allowedSampleRates : [];
      const bdList = Array.isArray(preset.allowedBits) ? preset.allowedBits : [];
      const chList = Array.isArray(preset.allowedChannels) ? preset.allowedChannels : [];
      srKind = (srList.length===0 || srList.includes(sr)) ? "ok" : "ng";
      bdKind = (bd==null) ? "warn" : ((bdList.length===0 || bdList.includes(bd)) ? "ok" : "ng");
      chKind = (chList.length===0 || chList.includes(chN)) ? "ok" : "ng";
    }
    let srReason = "";
    if(preset){
      const allowed = preset.allowedSampleRates;
      if(!allowed || allowed.length===0) srReason = "（制限なし）";
      else {
        const a = allowed.join(", ");
        srReason = (srKind==="ok") ? `OK（許容: ${a} / 実測: ${sr}）` : `許容外（許容: ${a} / 実測: ${sr}）`;
      }
    }
    let bdReason = "";
    if(preset){
      const allowed = preset.allowedBits;
      if(!allowed || allowed.length===0) bdReason = "（制限なし）";
      else {
        const a = allowed.join(", ");
        bdReason = (bdKind==="ok") ? `OK（許容: ${a} / 実測: ${bd}）` : `許容外（許容: ${a} / 実測: ${bd}）`;
      }
    }
    let chReason = "";
    if(preset){
      const allowed = preset.allowedChannels;
      if(!allowed || allowed.length===0) chReason = "（制限なし）";
      else {
        const a = allowed.map(_scFormatCh).join(", ");
        const v = _scFormatCh(chN);
        chReason = (chKind==="ok") ? `OK（許容: ${a} / 実測: ${v}）` : `許容外（許容: ${a} / 実測: ${v}）`;
      }
    }

    const clipDetected = (analysis.clipCount || 0) > 0;
    const clipReason = clipDetected ? `クリップ検出（clipped: ${analysis.clipCount}）` : "";

    const silMin = (preset && isFinite(preset.silenceMinSec)) ? Number(preset.silenceMinSec) : 0.0;
    const silMax = (preset && isFinite(preset.silenceMaxSec)) ? Number(preset.silenceMaxSec) : ((preset && isFinite(preset.silenceAllowSec)) ? Number(preset.silenceAllowSec) : 0.5);
    let silKind = "ok";
    let silReason = "";
    if(analysis.hasSound === false){
      silKind = "ng";
      silReason = "音声が検出できません（無音）";
    }else{
      const h = analysis.headSilenceSec ?? 0;
      const t = analysis.tailSilenceSec ?? 0;
      const underH = (h < silMin);
      const underT = (t < silMin);
      const overH = (h > silMax);
      const overT = (t > silMax);
      const ok = !underH && !underT && !overH && !overT;
      silKind = ok ? "ok" : "ng";
      if(ok){
        silReason = `OK（前 ${h.toFixed(2)}s / 後 ${t.toFixed(2)}s / 許容 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s）`;
      }else{
        const parts = [];
        if(underH) parts.push(`前が不足（${h.toFixed(2)}s）`);
        if(overH) parts.push(`前が許容超過（${h.toFixed(2)}s）`);
        if(underT) parts.push(`後が不足（${t.toFixed(2)}s）`);
        if(overT) parts.push(`後が許容超過（${t.toFixed(2)}s）`);
        silReason = `${parts.join(" / ")}（許容 ${silMin.toFixed(2)}〜${silMax.toFixed(2)}s）`;
      }
    }

    const summary = {failCount:0, warnCount:0};
    const count = (k)=>{ if(k==="ng") summary.failCount++; else if(k==="warn") summary.warnCount++; };
    count(lufsKind); count(tpKind); count(srKind); count(bdKind); count(chKind);
    if(clipDetected) summary.failCount++;
    if(silKind==="ng") summary.failCount++;

    return {
      items: [
        { key: "lufs", label: "Integrated LUFS", ok: lufsKind !== "ng", reason: lufsReason },
        { key: "tp", label: "TruePeak", ok: tpKind !== "ng", reason: tpReason },
        { key: "sr", label: "サンプルレート", ok: srKind !== "ng", reason: srReason },
        { key: "bd", label: "bit深度", ok: bdKind !== "ng", reason: bdReason },
        { key: "ch", label: "チャンネル", ok: chKind !== "ng", reason: chReason },
        { key: "clip", label: "クリッピング", ok: !clipDetected, reason: clipReason },
        { key: "silence", label: "無音", ok: silKind !== "ng", reason: silReason },
      ],
      summary: { ngCount: summary.failCount, warnCount: summary.warnCount },
      presetId,
    };
  }
  function proApplyQcResult(rec, qcResult){
    applyQcResultToRec(rec, qcResult, { source: "single" });
    if(project.activeId === rec.id && qcResult){
      window.__wavcueLastQc = {
        at: Date.now(),
        fileKey: String(rec.name || ""),
        result: qcResult || {}
      };
      state.qcHasRun = true;
      const analysis = rec.analysis;
      if(analysis){
        const preset = _scGetPresetById(qcResult.presetId);
        const silMin = (preset && isFinite(preset.silenceMinSec)) ? Number(preset.silenceMinSec) : 0.0;
        const silMax = (preset && isFinite(preset.silenceMaxSec)) ? Number(preset.silenceMaxSec)
          : ((preset && isFinite(preset.silenceAllowSec)) ? Number(preset.silenceAllowSec) : 0.5);
        state.scLast = {
          presetId: qcResult.presetId || null,
          fileKey: String(rec.name || ""),
          lufs: analysis.integratedLufs,
          tpDb: analysis.truePeakDbtp,
          sr: analysis.sr,
          bd: analysis.bits,
          chN: analysis.ch,
          clipDetected: (analysis.clipCount || 0) > 0,
          headSilenceSec: analysis.headSilenceSec,
          tailSilenceSec: analysis.tailSilenceSec,
          silenceMinSec: silMin,
          silenceMaxSec: silMax,
          silenceAllowSec: silMax,
          effectiveMonoWarn: false,
          effectiveMonoCorr: null,
          effectiveMonoDiffRatio: null,
        };
      }
    }
  }
  function proGetJobLogText(){
    const box = $('proJobLog');
    if(!box) return "";
    return Array.from(box.querySelectorAll("div")).map(el=>el.textContent||"").join("\n");
  }
  function proUpdateAfterFix(rec){
    if(!rec) return;
    try{
      const snap = (typeof window.safeCloneLite === "function")
        ? window.safeCloneLite(window.WavCue?.state || null)
        : (window.WavCue?.state || null);
      rec._stateSnap = snap || rec._stateSnap;
    }catch(_){ }
    try{ proComputeAnalysisFromState(rec); }catch(err){ console.warn("[Pro] analysis update failed", rec?.name, err); }
    try{ audioCacheRemember(rec, state.buffer, state.peaks); }catch(err){ console.warn("[Pro] audio cache update failed", rec?.name, err); }
    try{
      const qcResult = proBuildQcResultFromAnalysis(rec);
      if(qcResult) proApplyQcResult(rec, qcResult);
    }catch(err){
      console.warn("[Pro] qc update failed", rec?.name, err);
    }
    render();
  }
  function proGetAppCues(){
    const st = window.WavCue?.state;
    if(!st || !Array.isArray(st.cues)) return null;
    return st.cues.map(c=>({
      id: c.id >>> 0,
      label: String(c.label ?? ""),
      sec: Number(c.sec ?? 0),
    }));
  }
  function proCueSignature(cues){
    if(!Array.isArray(cues)) return "";
    return cues.map(c=>`${c.id >>> 0}:${String(c.label ?? "")}:${Number(c.sec ?? 0)}`).join("|");
  }
  function proSaveActiveEdits(reason, force){
    const id = project.activeId;
    if(!id) return;
    const rec = project.files.find(f=>f.id===id);
    if(!rec) return;

    const cues = proGetAppCues();
    if(!cues) return;

    const sig = proCueSignature(cues);
    if(!force && sig === rec.cuesSig) return;

    rec.cuesSnapshot = cues.map(c=>({
      id: c.id >>> 0,
      label: String(c.label ?? ""),
      sec: Number(c.sec ?? 0),
    }));
    rec.cuesSig = sig;
    rec.dirty = true;

    console.log(`[Pro] saveEdits(${reason||""}${force?",force":""}) -> ${rec.name} cues=${rec.cuesSnapshot.length}`);
  }
  function proApplyEditsToApp(rec, reason){
    const st = window.WavCue?.state;
    if(!st || !rec) return;
    const cues = Array.isArray(rec.cuesSnapshot) ? rec.cuesSnapshot : null;
    if(!cues) return;
    st.cues = cues.map(c=>({
      id: c.id >>> 0,
      label: String(c.label ?? ""),
      sec: Number(c.sec ?? 0),
    }));
    try{
      const maxId = st.cues.reduce((m,c)=> Math.max(m, Number(c.id)||0), 0);
      st.nextCueId = maxId + 1;
    }catch(_){}
    try{
      rec.cues = Array.isArray(rec.cuesSnapshot) ? rec.cuesSnapshot.slice() : rec.cues;
    }catch(_){}
    try{ if(typeof renderCues === "function") renderCues(); }catch(_){}
    try{ if(typeof drawAll === "function") drawAll(); }catch(_){}
    try{ if(typeof updateButtons === "function") updateButtons(); }catch(_){}
    if(reason){ console.log(`[Pro] applyEdits(${reason}) -> ${rec.name} cues=${st.cues.length}`); }
  }
  function proSyncRecFromState(rec, reason, opts={}){
    const st = window.WavCue?.state;
    if(!st || !rec || !Array.isArray(st.cues)) return;
    const cues = st.cues.map(c=>({
      id: c.id >>> 0,
      label: String(c.label ?? ""),
      sec: Number(c.sec ?? 0),
    }));
    rec.cuesSnapshot = cues.map(c=>({ ...c }));
    rec.cuesSig = proCueSignature(cues);
    rec.cues = cues.map(c=>({ ...c }));
    if(opts.markEdited){
      rec.status.edited = true;
    }
    if(reason){ console.log(`[Pro] syncRec(${reason}) -> ${rec.name} cues=${rec.cues.length}`); }
  }
  function proUpdateBadges(reason){
    project.files.forEach(f=>{
      if(Array.isArray(f.cuesSnapshot)){
        f.cues = f.cuesSnapshot.map(c=>({ ...c }));
      }
    });
    if(reason){ console.log(`[Pro] updateBadges(${reason})`); }
    render();
  }
  function proCommitEdits(reason, opts){
    const id = project.activeId;
    const rec = project.files.find(f=>f.id===id);
    if(!rec) return;
    proSyncRecFromState(rec, reason || "commit", {markEdited:true});
    if(reason){ console.log(`[Pro] commitEdits(${reason}) -> ${rec.name}`); }
  }
  window.commitEdits = window.commitEdits || proCommitEdits;
  window.updateBadges = window.updateBadges || proUpdateBadges;
  window.__wavcueProGetActiveId = window.__wavcueProGetActiveId || (()=> project.activeId);
  window.__wavcueProGetRecById = window.__wavcueProGetRecById || ((id)=> project.files.find(f=>f.id===id) || null);
  window.__wavcueProAfterFix = window.__wavcueProAfterFix || ((id)=>{
    const rec = project.files.find(f=>f.id===id) || null;
    proUpdateAfterFix(rec);
  });
  function proForceRedraw(reason){
    if(reason) console.log(`[Pro] forceRedraw(${reason})`);
    try{ if(typeof window.resizeAll === "function") window.resizeAll(); }catch(_){}
    try{ if(typeof window.drawAll === "function") window.drawAll(); }catch(_){}
    setTimeout(()=>{
      try{ if(typeof window.resizeAll === "function") window.resizeAll(); }catch(_){}
      try{ if(typeof window.drawAll === "function") window.drawAll(); }catch(_){}
    }, 120);
  }
  function isWavFile(file){
    if(!file) return false;
    const name = String(file.name||"").toLowerCase();
    return file.type === "audio/wav" || file.type === "audio/wave"
      || name.endsWith(".wav") || name.endsWith(".wave");
  }
  const extractQcNgItems = (typeof window.extractQcNgItems === "function")
    ? window.extractQcNgItems
    : function extractQcNgItemsLocal(qcResult){
      const out = { items: [], ng: [], ok: [] };
      if(!qcResult) return out;

      // items は「全検査項目」。NG配列ではない
      const itemsCand =
        qcResult.items ??
        qcResult.rows ??
        qcResult.results ??
        [];
      out.items = Array.isArray(itemsCand) ? itemsCand : [];

      // NG候補は専用フィールドのみ（itemsは入れない）
      const ngCand =
        qcResult.ngItems ??
        qcResult.ng ??
        qcResult.issues ??
        qcResult.failures ??
        [];
      out.ng = Array.isArray(ngCand) ? ngCand.filter(Boolean) : [];

      // ng専用フィールドが無い形式の場合は items から ok===false だけ抽出
      if(out.ng.length===0 && out.items.length){
        out.ng = out.items.filter(it => it && (it.ok === false || it.status === "ng" || it.pass === false || it.passed === false));
      }

      // 最終フォールバック（旧挙動維持）
      if(out.ng.length===0){
        if(qcResult.ok === false || qcResult.pass === false || qcResult.passed === false){
          out.ng = ["NG"];
        }
      }
      return out;
    };
  const safeExtract = (qcResult)=>{
    try{
      if(typeof window.extractQcNgItems === "function") return window.extractQcNgItems(qcResult);
      if(typeof extractQcNgItems === "function") return extractQcNgItems(qcResult);
    }catch(_){}
    const items = qcResult?.items || qcResult?.rows || qcResult?.results || [];
    const arr = Array.isArray(items) ? items : [];
    const ng = arr.filter(it => it && (it.ok === false || it.status === "ng" || it.pass === false));
    return { items: arr, ng };
  };
  async function runQcAndWaitResult(){
    const st = window.WavCue?.state;
    const fileKey = String(st?.fileName || "");
    try{ _scRunMeasureAndRender({switchToResults:false}); }catch(_){}

    const t0 = Date.now();
    const timeoutMs = 8000;
    while(Date.now() - t0 < timeoutMs){
      try{
        if(typeof window.getLastQcForCurrentFile === "function"){
          const r = window.getLastQcForCurrentFile();
          if(r) return r;
        }
      }catch(_){}

      try{
        const last = window.__wavcueLastQc;
        if(last && last.result){
          if(!fileKey || !last.fileKey || String(last.fileKey) === fileKey){
            return last.result;
          }
        }
      }catch(_){}

      await new Promise(r=>setTimeout(r, 60));
    }
    return null;
  }
  function qcReasonText(qcResult){
    if(!qcResult) return "未チェック/理由なし";
    const { ng } = safeExtract(qcResult);
    if(!ng.length) return "規格OK";
    const reasons = ng.map(it=>{
      const label = it?.label || it?.key || "NG";
      const reason = it?.reason ? `: ${it.reason}` : "";
      return `${label}${reason}`;
    });
    return reasons.length ? reasons.join("\n") : "未チェック/理由なし";
  }
  function formatNgDetailItem(item){
    if(!item) return { label: "NG", reason: "詳細不明", extra: [] };
    if(typeof item === "string"){
      return { label: item, reason: "詳細不明", extra: [] };
    }
    const label = item.label || item.key || item.name || "NG";
    const reason =
      item.reason ||
      item.message ||
      item.detail ||
      item.desc ||
      item.text ||
      item.value ||
      "詳細不明";
    const extra = [];
    const actual = item.actual ?? item.measured ?? item.valueMeasured ?? item.measuredValue ?? item.valueActual;
    const limit = item.limit ?? item.threshold ?? item.target ?? item.targetValue;
    const delta = item.delta ?? item.diff ?? item.difference;
    if(actual != null) extra.push(["実測値", actual]);
    if(limit != null) extra.push(["基準値", limit]);
    if(delta != null) extra.push(["差分", delta]);
    return { label, reason, extra };
  }
  function renderNgDetail(qcResult, fileName){
    const dlg = $("ngDetailDialog");
    const listEl = $("ngDetailList");
    const fileEl = $("ngDetailFile");
    if(fileEl) fileEl.textContent = fileName ? `(${fileName})` : "";
    if(!listEl) return;
    const { ng } = safeExtract(qcResult || null);
    if(!qcResult || !ng.length){
      listEl.innerHTML = `<div class="ngDetailEmpty">NG項目はありません。</div>`;
      return;
    }
    listEl.innerHTML = ng.map((raw)=> {
      const item = formatNgDetailItem(raw);
      const rows = [
        `<div class="label">NG事由</div><div>${esc(item.reason)}</div>`,
        ...item.extra.map(([k,v])=>`<div class="label">${esc(k)}</div><div>${esc(v)}</div>`)
      ];
      return `<div class="ngDetailCard">
        <div class="ngDetailHeader">
          <div class="ngDetailKey">NG項目</div>
          <div class="ngDetailVal">${esc(item.label)}</div>
        </div>
        <div class="ngDetailGrid">${rows.join("")}</div>
      </div>`;
    }).join("");
  }
  function openNgDetailDialog(file, source){
    if(!file) return;
    const qcResult = file.qcResult || null;
    const { ng } = safeExtract(qcResult || null);
    console.log(`[NGDetail] open fileId=${file.id} ngCount=${ng.length}`);
    renderNgDetail(qcResult, file.name || "");
    const dlg = $("ngDetailDialog");
    if(dlg){
      try{ dlg.showModal(); }catch(_){ dlg.open = true; }
    }
  }
  function getRecQcState(rec){
    const qcResult = rec?.qcResult || null;
    if(!qcResult){
      return { status: "unverified", reason: null, ng: [] };
    }
    const { ng } = safeExtract(qcResult);
    return {
      status: ng.length ? "ng" : "ok",
      reason: qcReasonText(qcResult),
      ng,
    };
  }
  function applyQcResultToRec(rec, qcResult, opts){
    if(!rec) return;
    if(!qcResult){
      rec.status.qc = "unverified";
      rec.status.qcReason = null;
      rec.qcResult = null;
    }else{
      const { status, reason, ng } = getRecQcState({ qcResult });
      rec.status.qc = status;
      rec.status.qcReason = reason;
      rec.qcResult = qcResult;
      if(opts?.source === "bulk"){
        console.log(`[QC][apply] fileId=${rec.id} ok=${ng.length === 0} field=qcResult`);
      }
    }
  }
  function syncActiveQcFromRec(rec){
    if(!rec){
      state.qcHasRun = false;
      window.__wavcueLastQc = null;
      return;
    }
    if(rec.qcResult){
      window.__wavcueLastQc = {
        at: Date.now(),
        fileKey: String(rec.name || ""),
        result: rec.qcResult,
      };
      state.qcHasRun = true;
    }else{
      state.qcHasRun = false;
      window.__wavcueLastQc = null;
    }
  }
  async function addFiles(fileList){
    try{
      const files = Array.from(fileList || []).filter(isWavFile);
      if(!files.length) return;
      const dndGuard = (files.length > 1) ? { expected: files.length, seen: 0, startedAt: Date.now() } : null;
      if (typeof window.diagLog === "function") window.diagLog("[DND]", "start", window.diagState({ count: files.length, startedAt: dndGuard?.startedAt || null }));
      console.log(`[DND] start ${files.length}`);
      const addedIds = [];
      const addedRecs = [];
      for(const file of files){
        const id = uid();
        const rec = {
          id,
          file,
          name:file.name,
          status:{ qc:'unverified', edited:false, exported:false, qcReason:null },
          cues:[],
          cmcd: null,
          attachments:[],
          attachCount:null,
          qcResult:null,
          snapshot:false,
        };
        project.files.push(rec);
        addedIds.push(id);
        addedRecs.push(rec);
      }
      const targetActiveId = project.activeId || project.files[0]?.id || null;
      if(typeof loadSingleWav === "function"){
        for(const rec of addedRecs){
          try{
            console.log("[DND] fullLoad start", rec.name);
            if (typeof window.diagLog === "function") window.diagLog("[DND]", "fullLoad start", window.diagState({ name: rec.name, fileId: rec.id }));
            await loadSingleWav(rec.file);
            project.lastLoadedId = rec.id;
            let stateLike = null;
            try{
              const raw = window.WavCue?.state || null;
              stateLike = (typeof window.safeCloneLite === "function") ? window.safeCloneLite(raw) : raw;
              rec._stateSnap = stateLike || null;
            }catch(e){
              console.warn("[MIGRATE] state snapshot failed", e);
            }
            let artifacts = null;
            try{
              const fileBuf = window.WavCue?.state?.srcAb || null;
              const chunks = window.WavCue?.state?.srcChunks || null;
              if(fileBuf && typeof window._artifactScan === "function"){
                artifacts = window._artifactScan(fileBuf, chunks, rec.id);
              }else{
                console.warn("[ARTIFACT] scan skipped", { fileId: rec.id });
              }
            }catch(e){
              console.warn("[ARTIFACT] scan failed", e);
            }
            try{
              if(artifacts){
                if((!rec.cmcdInputs || !window._cmcdInputsHasValues(rec.cmcdInputs)) && artifacts.cmcdInputs && window._cmcdInputsHasValues(artifacts.cmcdInputs)){
                  rec.cmcdInputs = artifacts.cmcdInputs;
                }
                if((!rec.cmcd || !rec.cmcd.trim()) && artifacts.cmcdText){
                  rec.cmcd = artifacts.cmcdText;
                }else if((!rec.cmcd || !rec.cmcd.trim()) && rec.cmcdInputs){
                  try{ rec.cmcd = JSON.stringify(rec.cmcdInputs); }catch(_){ rec.cmcd = ""; }
                }
                if((!rec.attachments || !rec.attachments.length) && Array.isArray(artifacts.attachments)){
                  rec.attachments = artifacts.attachments;
                }
                if(typeof window.normalizeRecArtifacts === "function"){
                  window.normalizeRecArtifacts(rec, null);
                }
                console.log("[ARTIFACT]", "import", {
                  fileId: rec.id,
                  cmcdFilled: !!(rec.cmcdInputs && window._cmcdInputsHasValues(rec.cmcdInputs)),
                  pdfCount: rec.attachments?.length || 0,
                });
              }else if(rec.cmcd && rec.cmcd.trim()){
                console.warn("[CMCD]", "notfound", { fileId: rec.id, checked: ["chunk","ixml","list","bext"], note: "preserve existing" });
              }
            }catch(e){
              if(artifacts){
                if((!rec.cmcdInputs || !window._cmcdInputsHasValues(rec.cmcdInputs)) && artifacts.cmcdInputs && window._cmcdInputsHasValues(artifacts.cmcdInputs)){
                  rec.cmcdInputs = artifacts.cmcdInputs;
                }
                if((!rec.cmcd || !rec.cmcd.trim()) && artifacts.cmcdText){
                  rec.cmcd = artifacts.cmcdText;
                }else if((!rec.cmcd || !rec.cmcd.trim()) && rec.cmcdInputs){
                  try{ rec.cmcd = JSON.stringify(rec.cmcdInputs); }catch(_){ rec.cmcd = ""; }
                }
                if((!rec.attachments || !rec.attachments.length) && Array.isArray(artifacts.attachments)){
                  rec.attachments = artifacts.attachments;
                }
                console.log("[ARTIFACT]", "import fallback", {
                  fileId: rec.id,
                  cmcdFilled: !!(rec.cmcdInputs && window._cmcdInputsHasValues(rec.cmcdInputs)),
                  pdfCount: rec.attachments?.length || 0,
                });
              }
              console.warn("[ARTIFACT] import failed", e);
            }
            try{
              if(typeof window.normalizeRecArtifacts === "function"){
                window.normalizeRecArtifacts(rec, stateLike);
              }else{
                console.warn("[MIGRATE] normalizeRecArtifacts missing (fullLoad)");
              }
            }catch(err){ console.error("[MIGRATE] fullLoad normalize error", err); }
            proSyncRecFromState(rec, "dnd:fullLoad", {markEdited:false});
            try{
              proComputeAnalysisFromState(rec);
            }catch(err){
              console.warn("[Pro] analysis failed", rec.name, err);
            }
            try{
              audioCacheRemember(rec, state.buffer, state.peaks);
            }catch(err){
              console.warn("[Pro] audio cache remember failed", rec.name, err);
            }
            console.log("[DND] fullLoad done", rec.name);
            if (typeof window.diagLog === "function") window.diagLog("[DND]", "fullLoad done", window.diagState({ name: rec.name, fileId: rec.id }));
          }catch(err){
            console.error("[DND] fullLoad error", rec.name, err);
            if (typeof window.diagErr === "function") window.diagErr("[DND]", "fullLoad error", err);
          }finally{
            if(dndGuard){
              dndGuard.seen += 1;
              if (typeof window.diagLog === "function") window.diagLog("[DND]", "fullLoad seen", window.diagState({ seen: dndGuard.seen, expected: dndGuard.expected }));
            }
          }
        }
      }
      if(dndGuard && dndGuard.seen !== dndGuard.expected){
        const warnPayload = { expected: dndGuard.expected, seen: dndGuard.seen, elapsedMs: Date.now() - dndGuard.startedAt };
        console.warn("[GUARD] DND fullLoad mismatch", warnPayload);
        if (typeof window.diagLog === "function") window.diagLog("[GUARD]", "dnd:seen-mismatch", warnPayload);
      }
      if (typeof window.diagLog === "function") window.diagLog("[DND]", "all done", window.diagState({ expected: dndGuard?.expected || files.length, seen: dndGuard?.seen || files.length }));
      console.log(`[DND] all done ${addedRecs.length}`);
      if(targetActiveId){
        await setActiveFile(targetActiveId, {force:true, skipSave:true});
      }else{
        render();
      }
      if(typeof window.requestFullRefresh === "function") window.requestFullRefresh("dnd:done");
      console.log(`[Pro] addFiles done total=${project.files.length}`);
      if (typeof window.diagLog === "function") window.diagLog("[DND]", "addFiles done", window.diagState({ total: project.files.length }));
      return addedIds;
    }catch(err){
      console.error("[DND] addFiles failed", err);
      if (typeof window.diagErr === "function") window.diagErr("[DND]", "addFiles failed", err);
      return [];
    }
  }
  async function setActiveFile(id, opts){
    try{
      const rec = project.files.find(f=>f.id===id);
      if(!rec) return;
      if (typeof window.diagLog === "function") window.diagLog("[ACTIVE]", "start", window.diagState({ fileId: id, hasGetState: (typeof window.getState === "function") }));
      console.log("[Pro] setActiveFile start", { id, name: rec.name, force: !!opts?.force });
      console.log("[FixCommitB] restore-check", {
        fileId: rec.id,
        isReplacedFile: !!rec._fixReplacedFile,
        srcAbLen: rec?.srcAb?.byteLength || rec?._stateSnap?.srcAb?.byteLength || null,
      });

      if(!opts?.skipSave){
        proSaveActiveEdits("before-switch", true);
      }else{
        console.log("[ACTIVE]", "skipSave", { fileId: id });
      }

      project.activeId = id;
      state.activeFileId = id;
      const switchCueCount = Array.isArray(rec.cues) ? rec.cues.length : 0;
      try{
        if(typeof clearCueLayerOnSwitch === "function"){
          clearCueLayerOnSwitch(rec.id, switchCueCount, "active.switch");
        }
      }catch(e){
        console.warn("[ACTIVE] clearCueLayerOnSwitch threw (ignored)", e);
      }
      render();

      // すでに同じIDが読み込まれていて、forceでないなら再ロードしない
      if(project.lastLoadedId===id && !opts?.force){
        // UI更新だけはして終わる
        return;
      }

      // 本体APIが無いならここで止める（波形が出ない原因を明示）
      if(typeof loadSingleWav !== "function"){
        console.warn("[Pro] window.WavCue.api.loadFile が見つかりません。Pro側からWAVを読み込めません。");
        return;
      }

      const allowDecode = (opts?.allowDecode !== false);
      const cacheHit = audioCacheApply(rec);
      if(cacheHit){
        state.fileName = rec.name;
        state.file = rec.file;
        proApplyStateSnapshot(rec);
        state.procApplied = false;
        state.procDataPayload = null;
        state.procInfo = null;
        state.scLast = null;
        state.qcHasRun = false;
        state.zoom = 1;
        state.vZoom = 1;
        state.scrollPx = 0;
        state.playheadSec = 0;
        state.playStartSec = 0;
        await proEnsureAudioSrc(rec);
        project.lastLoadedId = id;
        proForceRedraw("cache-hit");
        proApplyEditsToApp(rec, "cache-hit");
      }else if(!allowDecode){
        console.log("[Pro] setActiveFile skip decode (no cache)", { id, name: rec.name });
        return;
      }else{
        console.log(`[Pro] setActiveFile(force=${!!opts?.force}) -> ${rec.name}`);
        await loadSingleWav(rec.file);  // ★ここが本体のloadFileに確実に到達する
        project.lastLoadedId = id;
        proForceRedraw("after-load");
        proApplyEditsToApp(rec, "after-load");
        try{
          audioCacheRemember(rec, state.buffer, state.peaks);
        }catch(err){
          console.warn("[Pro] audio cache remember failed", rec.name, err);
        }
      }

      // 読み込み後に、本体stateからキュー情報を同期（表示用）
      const st = (window.WavCue && window.WavCue.state) ? window.WavCue.state : null;
      if(st && Array.isArray(st.cues)){
        rec.cues = st.cues.map(c=>({
          id: c.id >>> 0,
          label: String(c.label ?? ""),
          sec: Number(c.sec ?? 0),
        }));
      }else{
        rec.cues = Array.isArray(rec.cues) ? rec.cues : [];
      }

      // cmcd / attachments: restore per-file values after cache-restore
      try{
        try{
          if(typeof window.normalizeRecArtifacts === "function"){
            const snap = rec._stateSnap || (typeof window.safeCloneLite === "function"
              ? window.safeCloneLite(window.WavCue?.state || null)
              : (window.WavCue?.state || null));
            window.normalizeRecArtifacts(rec, snap);
          }else{
            console.warn("[MIGRATE] normalizeRecArtifacts missing (active)");
          }
        }catch(err){ console.error("[MIGRATE] active normalize error", err); }
        const cmcdInput = window._cmcdInput;
        if(cmcdInput){
        if(rec.cmcdInputs && window._cmcdInputsHasValues(rec.cmcdInputs)){
          cmcdInput.value = rec.cmcdInputs;
        }else{
          cmcdInput.value = rec.cmcd || "";
        }
          console.log("[CMCD]", "restore", { fileId: rec.id, value: cmcdInput.value });
        }else if(typeof window._cmcdApplyValuesToInputs === "function"){
          window._cmcdApplyValuesToInputs(rec.cmcd || null);
          console.log("[CMCD]", "restore", { fileId: rec.id, value: rec.cmcd || "" });
        }else if(typeof window._cmcdCaptureInputs === "function"){
          rec.cmcd = window._cmcdCaptureInputs();
        }
      }catch(err){
        console.error("[ACTIVE] cmcd restore error", err);
      }
      try{
        if(Array.isArray(rec.attachments) && typeof window.attachSetAll === "function"){
          window.attachSetAll(rec.attachments);
        }else{
          const list = Array.isArray(rec.attachments) ? rec.attachments : [];
          if(Array.isArray(state.attachments)) state.attachments = list.slice();
          if(typeof window.attachSyncLegacy === "function") window.attachSyncLegacy();
          if(typeof window.attachRenderList === "function") window.attachRenderList();
          if(typeof window._pdfUI_set === "function") window._pdfUI_set(state.pdfAttach);
          rec.attachments = list;
        }
        rec.attachCount = Array.isArray(rec.attachments) ? rec.attachments.length : 0;
      }catch(err){
        console.error("[ACTIVE] pdf restore error", err);
      }
      try{
        console.log("[PDF]", "restore", {
          fileId: rec.id,
          count: rec.attachments?.length || 0,
          names: (rec.attachments || []).map(a=>a?.name || a?.fileName || a?.filename || "").filter(Boolean).slice(0,3),
        });
        console.log("[ACTIVE]", "restore", {
          fileId: rec.id,
          hasCmcd: _cmcdHasValues(rec.cmcd),
          pdfCount: rec.attachments?.length || 0,
        });
      }catch(_){ }
      if(typeof window.requestFullRefresh === "function"){
        window.requestFullRefresh("active:restore:cmcd");
        window.requestFullRefresh("active:restore:pdf");
      }

      // クリップ(添付)数は「確実に取れる手段」があれば同期。
      // 取れない場合でもUIが壊れないように null のままにする（表示側で 0 扱い or “–” 表示）
      // ※pdfFindAllInWav は window.WavCue.api.modules.pdf.pdfFindAllInWav で参照可能
      try{
        const pdfFindAll = window.WavCue?.api?.modules?.pdf?.pdfFindAllInWav;
        if(typeof pdfFindAll === "function"){
          // 状態から取れない環境もあるため、必要最小限で遅延取得（ここでは“軽く”やる）
          // File→ArrayBufferが重い場合があるので、ここでは未取得のときだけ実行
          if(rec.attachCount == null){
            const ab = await rec.file.arrayBuffer();
            const list = pdfFindAll(ab) || [];
            rec.attachCount = Array.isArray(list) ? list.length : 0;
          }
        }
      }catch(_){
        // attachCount は null のままでOK
      }

      syncActiveQcFromRec(rec);
    }catch(err){
      console.error("[Pro] setActiveFile error", err);
      if (typeof window.diagErr === "function") window.diagErr("[ACTIVE]", "error", err);
    }finally{
      render();
      if(typeof window.requestFullRefresh === "function") window.requestFullRefresh("active:switch");
      console.log("[Pro] setActiveFile done", id);
      if (typeof window.diagLog === "function") window.diagLog("[ACTIVE]", "done", window.diagState({ fileId: id }));
    }
  }
  function matchesFilter(file){
    const st = project.filter.status;
    const qcState = getRecQcState(file).status;
    if(st==='all') return true;
    if(st==='unverified') return qcState==='unverified';
    if(st==='ok') return qcState==='ok';
    if(st==='ng') return qcState==='ng';
    if(st==='unexported') return !file.status.exported;
    if(st==='exported') return !!file.status.exported;
    return true;
  }
  function filtered(){
    return project.files.filter(matchesFilter);
  }
  function getVisibleFileIds(){
    return filtered().map(f => f.id).filter(Boolean);
  }
  function historyTypeLabel(type){
    return type === "qc" ? "一括チェック" : "一括書き出し";
  }
  function historyEntries(){
    const list = history.entries.slice();
    if(history.active && history.active.running) list.unshift(history.active);
    return list;
  }
  function renderHistoryList(){
    const listEl = $("proHistoryList");
    if(!listEl) return;
    const entries = historyEntries();
    if(!entries.length){
      listEl.innerHTML = `<div class="ngDetailEmpty">履歴がありません。</div>`;
      return;
    }
    if(!history.selectedId && entries.length){
      history.selectedId = entries[0].id;
    }
    listEl.innerHTML = entries.map(entry=>{
      const ngCount = entry.ngCount || 0;
      const okCount = entry.okCount || 0;
      const total = entry.total || 0;
      const badgeClass = ngCount ? "ng" : "ok";
      const status = entry.running ? "進行中" : "完了";
      const t = new Date(entry.startedAt || Date.now()).toLocaleTimeString();
      return `<div class="proHistoryItem ${entry.id===history.selectedId ? "active" : ""}" data-id="${esc(entry.id)}">
        <div class="proHistoryTitle">${esc(historyTypeLabel(entry.type))}</div>
        <div class="proHistoryMeta">
          <span>${esc(t)} / ${status}</span>
          <span class="proHistoryBadge ${badgeClass}">OK:${okCount} NG:${ngCount}</span>
        </div>
        <div class="proHistoryMeta">対象 ${total} 件</div>
      </div>`;
    }).join("");
    Array.from(listEl.querySelectorAll(".proHistoryItem")).forEach(item=>{
      item.addEventListener("click", ()=>{
        history.selectedId = item.getAttribute("data-id");
        renderHistoryList();
        renderHistoryDetail();
      });
    });
  }
  function renderHistoryDetail(){
    const entries = historyEntries();
    const entry = entries.find(e=>e.id===history.selectedId) || entries[0] || null;
    if(entry && history.selectedId !== entry.id) history.selectedId = entry.id;
    const titleEl = $("proJobTitle");
    const nowEl = $("proJobNow");
    const countEl = $("proJobCount");
    const statEl = $("proJobStat");
    const bar = $("proJobProgressBar");
    const logEl = $("proJobLog");
    const failEl = $("proJobFailBadge");
    const failList = $("proJobFailList");
    const exportList = $("proJobExportList");
    if(!entry){
      if(titleEl) titleEl.textContent = "詳細ログ";
      if(nowEl) nowEl.textContent = "—";
      if(countEl) countEl.textContent = "0/0";
      if(statEl) statEl.textContent = "OK:0 / 失敗:0";
      if(bar) bar.style.width = "0%";
      if(logEl) logEl.innerHTML = "";
      if(failList) failList.innerHTML = "";
      if(failEl) failEl.textContent = "—";
      if(exportList) exportList.style.display = "none";
      return;
    }
    if(titleEl){
      const t = new Date(entry.startedAt || Date.now()).toLocaleString();
      titleEl.textContent = `${historyTypeLabel(entry.type)} (${t})`;
    }
    const done = entry.done || 0;
    const total = entry.total || 0;
    const okCount = entry.okCount || 0;
    const ngCount = entry.ngCount || 0;
    const failCount = entry.failCount || 0;
    const pct = total ? Math.round((done/total)*100) : 0;
    if(nowEl) nowEl.innerHTML = entry.nowText ? entry.nowText : (entry.running ? "処理中…" : "—");
    if(countEl) countEl.textContent = `${done}/${total}`;
    if(statEl) statEl.textContent = `OK:${okCount} / NG:${ngCount} / 失敗:${failCount}`;
    if(bar) bar.style.width = `${pct}%`;
    if(failEl){
      if(failCount){
        failEl.textContent = "失敗あり";
        failEl.classList.add("isFail");
      }else{
        failEl.textContent = total ? "失敗なし" : "—";
        failEl.classList.remove("isFail");
      }
    }
    if(logEl){
      logEl.innerHTML = (entry.logLines || []).map(line=>{
        const cls = line.level==="bad" ? "err" : "";
        return `<div class="${cls}">${esc(line.text)}</div>`;
      }).join("");
      logEl.scrollTop = logEl.scrollHeight;
    }
    if(failList){
      const failedIds = entry.failedIds || [];
      if(!failedIds.length){
        failList.innerHTML = "";
      }else{
        failList.innerHTML = failedIds.map(id=>{
          const rec = project.files.find(f=>f.id===id);
          const name = rec?.name || `file:${id}`;
          const canDetail = entry.type === "qc";
          const btn = canDetail ? `<button class="btnMini" data-id="${esc(id)}">NG詳細</button>` : "";
          return `<div class="proJobFailItem"><span class="name">${esc(name)}</span>${btn}</div>`;
        }).join("");
        Array.from(failList.querySelectorAll("button[data-id]")).forEach(btn=>{
          btn.addEventListener("click", ()=>{
            const id = btn.getAttribute("data-id");
            const rec = project.files.find(f=>String(f.id)===String(id));
            if(rec) openNgDetailDialog(rec, { source:"history" });
          });
        });
      }
    }
    if(exportList){
      if(entry.type === "export" && Array.isArray(entry.exportedNames) && entry.exportedNames.length){
        exportList.style.display = "grid";
        exportList.innerHTML = entry.exportedNames.map(name=>(
          `<div class="proJobExportItem">${esc(name)}</div>`
        )).join("");
      }else{
        exportList.style.display = "none";
        exportList.innerHTML = "";
      }
    }
    console.log(`[History] render entry id=${entry.id} ok=${okCount} ng=${ngCount} fail=${failCount}`);
    const retryBtn = $("proJobRetryFailed");
    const cancelBtn = $("proJobCancel");
    if(retryBtn) retryBtn.disabled = !entry.failedIds?.length || entry.running;
    if(cancelBtn) cancelBtn.disabled = !entry.running;
  }
  function showJob(open){
    const dlg = $("proHistoryDialog");
    if(!dlg) return;
    const next = (open===undefined) ? !dlg.open : open;
    if(next){
      if(dlg.parentElement !== document.body) document.body.appendChild(dlg);
      renderHistoryList();
      renderHistoryDetail();
      try{ dlg.showModal(); }catch(_){ dlg.setAttribute("open", ""); }
      requestAnimationFrame(()=>{
        const r = dlg.getBoundingClientRect();
        const entriesCount = historyEntries().length;
        console.log(`[History] open size=${Math.round(r.width)},${Math.round(r.height)} entries=${entriesCount}`);
      });
    }else{
      try{ dlg.close(); }catch(_){ dlg.removeAttribute("open"); }
    }
  }
  function logJob(s, level){
    const t = new Date().toLocaleTimeString();
    const text = `[${t}] ${String(s ?? "")}`;
    const entry = history.active || historyEntries().find(e=>e.id===history.selectedId) || null;
    if(entry){
      entry.logLines = entry.logLines || [];
      entry.logLines.push({ text, level: level || "" });
    }
    renderHistoryDetail();
  }
  function updateJobUI(now){
    const mini = $('proJobMiniText');
    if(mini) mini.textContent = job.running ? `${job.done}/${job.total}` : '履歴';
    if(history.active){
      history.active.done = job.done;
      if(history.active.type === "export"){
        history.active.okCount = job.ok;
        history.active.ngCount = job.failed.length;
      }
      history.active.failCount = job.failed.length;
      history.active.failedIds = job.failed.slice();
      if(now != null) history.active.nowText = esc(now);
    }
    renderHistoryList();
    renderHistoryDetail();
  }
  async function resolveBulkExportTarget(){
    if(window.wavcue?.pickExportFolder && window.wavcue?.writeFileBase64){
      const res = await window.wavcue.pickExportFolder();
      if(res?.canceled) return null;
      if(res?.folderPath){
        return { kind:"ipc", folderPath: res.folderPath };
      }
    }
    logJob("書き出し先フォルダの選択に失敗しました。");
    try{
      if(typeof toast === "function") toast("書き出し先フォルダが選択できませんでした", "warn");
    }catch(_){}
    return null;
  }
  function trimBulkReasonText(text){
    const s = String(text || "");
    const parenIndex = s.indexOf("（");
    const parenAsciiIndex = s.indexOf("(");
    const firstParen = (parenIndex === -1) ? parenAsciiIndex : (parenAsciiIndex === -1 ? parenIndex : Math.min(parenIndex, parenAsciiIndex));
    if(firstParen >= 0){
      return s.slice(0, firstParen).trim();
    }
    const slashIndex = s.indexOf(" / ");
    if(slashIndex >= 0){
      return s.slice(0, slashIndex).trim();
    }
    return s.trim();
  }
  function formatBulkNgReasons(qcResult, limit){
    const { ng } = safeExtract(qcResult || null);
    if(!ng.length) return [];
    const out = [];
    for(const raw of ng){
      const detail = formatNgDetailItem(raw);
      const label = trimBulkReasonText(detail.label || "NG");
      const reasonRaw = (detail.reason && detail.reason !== "詳細不明") ? detail.reason : "";
      const reasonText = trimBulkReasonText(reasonRaw);
      const reason = reasonText ? `：${reasonText}` : "";
      out.push(`${label}${reason}`.trim());
      if(limit && out.length >= limit) break;
    }
    return out;
  }
  function showBulkExportNgDialog(items){
    const dlg = $("bulkExportNgDialog");
    const list = $("bulkExportNgList");
    if(!dlg || !list) return Promise.resolve(false);
    list.innerHTML = "";
    if(!items.length){
      list.innerHTML = `<div class="muted">NG項目はありません。</div>`;
    }else{
      list.innerHTML = items.map(entry=>{
        const reasons = entry.reasons?.length ? entry.reasons : ["規格NG"];
        const reasonHtml = reasons.map(r=>`<li>${esc(trimBulkReasonText(r))}</li>`).join("");
        return `<div class="bulkNgItem">
          <div class="bulkNgName">${esc(entry.name)}</div>
          <ul class="bulkNgReasons">${reasonHtml}</ul>
        </div>`;
      }).join("");
    }
    return new Promise(resolve=>{
      const cleanup = (result)=>{
        try{
          dlg.close();
        }catch(_){
          dlg.removeAttribute("open");
        }
        dlg.removeEventListener("click", onBackdrop);
        dlg.removeEventListener("cancel", onCancel);
        cancelBtn?.removeEventListener("click", onCancelBtn);
        proceedBtn?.removeEventListener("click", onProceedBtn);
        resolve(result);
      };
      const onBackdrop = (e)=>{ if(e.target === dlg) cleanup(false); };
      const onCancel = (e)=>{ e.preventDefault(); cleanup(false); };
      const onCancelBtn = ()=> cleanup(false);
      const onProceedBtn = ()=> cleanup(true);
      const cancelBtn = $("bulkExportNgCancel");
      const proceedBtn = $("bulkExportNgProceed");
      dlg.addEventListener("click", onBackdrop);
      dlg.addEventListener("cancel", onCancel);
      cancelBtn?.addEventListener("click", onCancelBtn);
      proceedBtn?.addEventListener("click", onProceedBtn);
      try{
        if(dlg.open) dlg.close();
      }catch(_){}
      try{
        dlg.showModal();
      }catch(_){
        try{ dlg.show(); }catch(__){}
      }
    });
  }
  async function runJob(type, idsOverride){
    const gate = (type === "export")
      ? guardBulkExport({ source: "bulk", mode: type })
      : guardBulkCheck({ source: "bulk", mode: type });
    if(!gate.ok){
      if(window.safeToast){
        const msg = (type === "export")
          ? LICENSE_TEXT.bulkExportPro
          : LICENSE_TEXT.bulkCheckPro;
        window.safeToast(msg, "warn");
      }
      return;
    }
    const usingOverride = Array.isArray(idsOverride);
    const targets = usingOverride ? idsOverride : getVisibleFileIds();
    const filterOn = project.filter.status && project.filter.status !== "all";
    console.log(`[Bulk] target=${usingOverride ? "override" : "visible"} count=${targets.length} filter=${filterOn ? "on" : "off"} action=${type==="qc" ? "QC" : "EXPORT"}`);
    if(!targets.length){
      logJob("対象件数: 0");
      try{
        if(typeof toast === "function") toast("対象ファイルがありません", "warn");
        else alert("対象ファイルがありません");
      }catch(_){}
      return;
    }
    const prog = getProg();
    let exportTarget = null;
    let bulkStartedAt = 0;
    if(type === "export"){
      console.log(`[BULK][PREFLIGHT] start total=${targets.length}`);
      const ngItems = [];
      targets.forEach(id=>{
        const f = project.files.find(x=>x.id===id);
        if(!f) return;
        const { ng } = safeExtract(f.qcResult || null);
        if(!ng.length) return;
        const reasons = formatBulkNgReasons(f.qcResult || null, 3);
        const name = f.name || `file:${id}`;
        console.log(`[BULK][PREFLIGHT] ng file=${name} reasons=${reasons.join(" / ") || "規格NG"}`);
        ngItems.push({ id, name, reasons });
      });
      console.log(`[BULK][PREFLIGHT] ngCount=${ngItems.length}`);
      if(ngItems.length){
        console.log("[BULK][PREFLIGHT] showWarningDialog");
        const proceed = await showBulkExportNgDialog(ngItems);
        console.log(`[BULK][PREFLIGHT] continueByUser=${proceed}`);
        if(!proceed) return;
      }
      console.log("[BULK][PREFLIGHT] pass -> continue");
      bulkStartedAt = Date.now();
      console.log(`[BULK] start total=${targets.length}`);
      prog.show("一括書き出し中…", `0/${targets.length}`);
      exportTarget = await resolveBulkExportTarget();
      if(!exportTarget){
        logJob("一括書き出しをキャンセルしました。");
        prog.hide();
        return;
      }
      const exportFolderLabel = exportTarget.folderPath || "";
      console.log(`[BULK] pickFolder ok path=${exportFolderLabel}`);
    }
    job.running = true;
    job.cancel=false;
    job.failed=[];
    job.done=0;
    job.total=targets.length;
    job.ok=0;

    const historyEntry = {
      id: uid(),
      type,
      total: targets.length,
      okCount: 0,
      ngCount: 0,
      failCount: 0,
      done: 0,
      failedIds: [],
      exportedNames: [],
      logLines: [],
      startedAt: Date.now(),
      running: true,
      nowText: "",
    };
    history.active = historyEntry;
    history.selectedId = historyEntry.id;
    renderHistoryList();
    renderHistoryDetail();

    logJob(`対象件数: ${targets.length}`);
    logJob(`開始: ${type==='qc' ? '一括チェック' : '一括書き出し'} (${targets.length}件)`);
    updateJobUI();
    if(type !== "export"){
      bulkOverlay.start(type, targets.length);
    }

    let qcUpdatedRows = 0;
    try{
      let index = 0;
      for(const id of targets){
        if(job.cancel) break;
        const f = project.files.find(x=>x.id===id);
        if(!f) continue;
        try{
          index += 1;
          logJob(`開始: ${type==='qc' ? '一括チェック' : '書き出し'}: ${f.name}`);
          await setActiveFile(id, {force:true});
          updateJobUI(`${type==='qc' ? 'チェック中' : '書き出し中'}: ${f.name}`);
          if(type === "export"){
            const pct = job.total ? (job.done / job.total) : 0;
            prog.set(pct, "一括書き出し中…", `${index}/${job.total} ${f.name || ""}`);
          }else{
            bulkOverlay.update(job.done, job.total, f.name);
          }
          if(type==='qc'){
            const st = window.WavCue?.state;
            if(!st || !st.buffer){
              throw new Error("QC失敗: AudioBuffer未準備（ロード未完了の可能性）");
            }

            // QC実行：例外は握りつぶさずログ化して失敗扱い
            try{
              const runQc = (typeof window._scRunMeasureAndRender === "function") ? window._scRunMeasureAndRender : null;
              if(!runQc){
                throw new Error("QC失敗: window._scRunMeasureAndRender が未定義です（公開漏れ）");
              }
              runQc({ switchToResults:false });
            }catch(e){
              const msg = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
              logJob(`QC例外: ${f.name} / ${msg}`, "bad");
              throw new Error("QC失敗: 実行中に例外が発生しました（詳細はログ/console）");
            }

            // QC結果取得：取れなければ失敗（成功扱いにしない）
            const qcResult =
              (typeof window.getLastQcForCurrentFile === "function")
                ? window.getLastQcForCurrentFile()
                : ((typeof getLastQcForCurrentFile === "function")
                  ? getLastQcForCurrentFile()
                  : (window.__wavcueLastQc?.result || null));

            if(!qcResult){
              throw new Error("QC失敗: 結果取得できず（__wavcueLastQc 未更新の可能性）");
            }

            applyQcResultToRec(f, qcResult, { source: "bulk" });
            qcUpdatedRows += 1;

            const qcState = getRecQcState(f).status;
            if(qcState === "ok") historyEntry.okCount += 1;
            if(qcState === "ng") historyEntry.ngCount += 1;

            if(qcState === "unverified"){
              throw new Error("QC失敗: バッジ更新できず（apply後も未のまま）");
            }
          }
          if(type==='export'){
            const fileLabel = f.name || state.fileName || "export.wav";
            const fileStartedAt = Date.now();
            console.log(`[BULK] file ${index}/${targets.length} begin id=${id} name=${fileLabel}`);
            const res = await window.WavCueExportCore.exportOneToTarget({
              target: exportTarget,
              suggestedName: fileLabel,
              fileId: id,
            });
            if(!res?.ok){
              const msg = res?.error?.message || res?.error || "export failed";
              throw new Error(msg);
            }
            f.status.exported = true;
            historyEntry.exportedNames.push(res?.savedName || fileLabel || "exported");
            console.log(`[BULK] file ${index}/${targets.length} ok ms=${Date.now() - fileStartedAt}`);
          }
          job.ok++;
          if(type === "qc"){
            logJob(`判定: ${f.name} (${getRecQcState(f).status.toUpperCase()})`);
          }else{
            logJob(`成功: ${f.name}`);
          }
        }catch(e){
          job.failed.push(id);
          historyEntry.failCount += 1;
          logJob(`失敗: ${f.name} / ${e?.message || e}`);
          if(type === "export"){
            const stack = e?.stack ? String(e.stack) : "";
            console.log(`[BULK] file ${index}/${targets.length} ng reason=${e?.message || e} stack=${stack}`);
          }
        }finally{
          job.done++;
          updateJobUI(`${type==='qc' ? 'チェック中' : '書き出し中'}: ${f.name}`);
          if(type === "export"){
            const pct = job.total ? (job.done / job.total) : 0;
            prog.set(pct, "一括書き出し中…", `${Math.min(index, job.total)}/${job.total} ${f.name || ""}`);
          }else{
            bulkOverlay.update(job.done, job.total, f.name);
          }
          render();
        }
      }
    }finally{
      logJob(`完了: ${job.done}/${job.total} / failed=${job.failed.length}`);
      if(type==='qc'){
        console.log(`[QC][bulk] done updatedRows=${qcUpdatedRows}`);
        render();
        if(typeof window.requestFullRefresh === "function") window.requestFullRefresh("qc:bulk");
      }
      job.running = false;
      updateJobUI();
      render();

      const status = job.cancel ? "cancel" : (job.failed.length ? "fail" : "success");
      if(type === "export"){
        prog.hide();
        console.log(`[BULK] end ok=${job.ok} ng=${job.failed.length} ms=${Date.now() - bulkStartedAt}`);
      }
      bulkOverlay.end(type, status);
      historyEntry.running = false;
      historyEntry.endedAt = Date.now();
      if(type === "export"){
        historyEntry.okCount = job.ok;
        historyEntry.ngCount = job.failed.length;
      }
      historyEntry.failCount = job.failed.length;
      historyEntry.done = job.done;
      historyEntry.failedIds = job.failed.slice();
      historyEntry.nowText = esc(job.cancel ? "キャンセル" : "完了");
      history.entries.unshift(historyEntry);
      history.active = null;
      history.selectedId = historyEntry.id;
      console.log(`[History] push type=${type==="qc" ? "QC" : "EXPORT"} total=${historyEntry.total} ok=${historyEntry.okCount} ng=${historyEntry.ngCount} fail=${historyEntry.failCount}`);
      renderHistoryList();
      renderHistoryDetail();
    }
  }
  function idsSelectedOrActive(){
    return getVisibleFileIds();
  }
  function setPopoverContent(title, bodyNode){
    const titleEl = $('proPopTitle');
    const bodyEl = $('proPopBody');
    if(titleEl) titleEl.textContent = title || "";
    if(bodyEl){
      bodyEl.innerHTML = "";
      if(bodyNode) bodyEl.appendChild(bodyNode);
    }
  }
  function positionPopover(){
    const pop = $('proGlobalPopover');
    if(!pop || pop.classList.contains('hidden') || !project.popover.anchorEl) return;
    const anchorRect = project.popover.anchorEl.getBoundingClientRect();
    pop.style.top = "0px";
    pop.style.left = "0px";
    pop.style.visibility = "hidden";
    const popRect = pop.getBoundingClientRect();
    let top = anchorRect.top - popRect.height - 8;
    if(top < 8){
      top = anchorRect.bottom + 8;
    }
    let left = anchorRect.left + anchorRect.width / 2 - popRect.width / 2;
    const maxLeft = window.innerWidth - popRect.width - 8;
    left = Math.max(8, Math.min(left, maxLeft));
    pop.style.top = `${Math.round(top)}px`;
    pop.style.left = `${Math.round(left)}px`;
    pop.style.visibility = "visible";
  }
  function closePopover(){
    const pop = $('proGlobalPopover');
    if(!pop) return;
    pop.classList.add('hidden');
    pop.setAttribute('aria-hidden', 'true');
    project.popover.openType = null;
    project.popover.openFileId = null;
    project.popover.anchorEl = null;
  }
  function openPopover(type, fileId, anchorEl){
    const pop = $('proGlobalPopover');
    if(!pop) return;
    if(project.popover.openType===type && project.popover.openFileId===fileId){
      closePopover();
      return;
    }
    const file = project.files.find(f=>f.id===fileId);
    if(!file) return;
    const body = document.createElement("div");
    body.className = "proPopList";
    if(type==="status"){
      openNgDetailDialog(file, { source:"list" });
      return;
    }
    if(type==="cues"){
      const cues = Array.isArray(file.cues) ? file.cues : [];
      if(!cues.length){
        const item = document.createElement("div");
        item.className = "proPopItem";
        item.textContent = "キューなし";
        body.appendChild(item);
      }else{
        cues.forEach(c=>{
          const row = document.createElement("div");
          row.className = "proPopItem proPopRow";
          const label = document.createElement("span");
          label.textContent = c.label || "—";
          const time = document.createElement("span");
          time.className = "mono";
          time.textContent = (typeof fmtTime === "function") ? fmtTime(c.sec) : `${c.sec.toFixed(3)}s`;
          row.appendChild(label);
          row.appendChild(time);
          body.appendChild(row);
        });
      }
      setPopoverContent("キュー一覧", body);
    }
    if(type==="attachments"){
      const atts = Array.isArray(file.attachments) ? file.attachments : [];
      for(let i=0;i<9;i++){
        const a = atts[i];
        const row = document.createElement("div");
        row.className = "proPopItem";
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = a ? `#${i+1} ${a.name || "attached"}` : `#${i+1} —`;
        btn.disabled = !a;
        if(a){
          btn.addEventListener("click", ()=>{
            // Do NOT switch active file here.
            const fn = (typeof window !== "undefined") ? window.pdfOpenViewerForObject : null;
            if(typeof fn === "function"){
              fn(a, {source:"popover", fileId: file.id, index: i});
            }else{
              try{ console.warn("[PDF] pdfOpenViewerForObject missing (popover)"); }catch(_){}
              safeLog("WARN: ビューアの起動関数が見つかりません。");
            }
            closePopover();
          });
        }
        row.appendChild(btn);
        body.appendChild(row);
      }
      setPopoverContent("添付一覧", body);
    }
    project.popover.openType = type;
    project.popover.openFileId = fileId;
    project.popover.anchorEl = anchorEl;
    pop.classList.remove('hidden');
    pop.setAttribute('aria-hidden', 'false');
    requestAnimationFrame(positionPopover);
  }
  function render(){
    const list = $('proFileList');
    const wrap = $('proFileListWrap');
    if(!list) return;
    const arr = filtered();
    if(wrap){
      wrap.classList.toggle('is-empty', project.files.length===0);
    }
    list.innerHTML = arr.map((f,i)=>{
      const cls = ['proFileRow'];
      if(f.id===project.activeId) cls.push('active');
      if(project.selectedIds.has(f.id)) cls.push('selected');
      const qcState = getRecQcState(f).status;
      const statusText = (qcState==='ok') ? 'OK' : (qcState==='ng' ? 'NG' : '未');
      const statusClass = (qcState==='ok') ? 'ok' : (qcState==='ng' ? 'ng' : 'unverified');
      const cueCount = Array.isArray(f.cues) ? f.cues.length : 0;
      const attCount = Number.isFinite(f.attachCount)
        ? f.attachCount
        : (Array.isArray(f.attachments) ? f.attachments.length : 0);
      const flags = [];
      if(f.status.edited) flags.push('<span class="proBadge">編</span>');
      if(f.status.exported) flags.push('<span class="proBadge">出</span>');
      return `<div class="${cls.join(' ')}" data-id="${esc(f.id)}" data-idx="${i}">
        <div class="proFileRowMain">
          <div class="proName">${esc(f.name)}</div>
          ${flags.length ? `<div class="proFileFlags">${flags.join('')}</div>` : ''}
        </div>
        <div class="proFileActions">
          <button class="proFileActionBtn proStatusBadge ${statusClass}" data-action="status" type="button">${statusText}</button>
          <button class="proFileActionBtn proCueBtn" data-action="cues" type="button">CUE ${cueCount}</button>
          <button class="proFileActionBtn proClipBtn" data-action="attachments" type="button">
            <svg aria-hidden="true" class="miniIcon" focusable="false"><use href="#ico-paperclip" xlink:href="#ico-paperclip"></use></svg>
            <span>${attCount}</span>
          </button>
        </div>
      </div>`;
    }).join('');

    Array.from(list.querySelectorAll('.proFileRow')).forEach(row=>{
      row.addEventListener('click', (e)=>{
        if(e.detail >= 2) return;
        if(e.target.closest('.proFileActionBtn')) return;
        const id = row.getAttribute('data-id');
        console.log('[Pro] row click', id);
        const idx = Number(row.getAttribute('data-idx'));
        const isCtrl = e.ctrlKey || e.metaKey;
        const isShift = e.shiftKey;

        if(isShift && project.lastClickIndex!=null){
          const a = Math.min(project.lastClickIndex, idx);
          const b = Math.max(project.lastClickIndex, idx);
          const ids = arr.slice(a,b+1).map(x=>x.id);
          if(!isCtrl) project.selectedIds.clear();
          for(const x of ids) project.selectedIds.add(x);
        }else if(isCtrl){
          if(project.selectedIds.has(id)) project.selectedIds.delete(id);
          else project.selectedIds.add(id);
          project.lastClickIndex = idx;
        }else{
          project.selectedIds.clear();
          project.selectedIds.add(id);
          project.lastClickIndex = idx;
          void setActiveFile(id);
          return;
        }
        render();
      });
      row.addEventListener('dblclick', ()=>{
        const id = row.getAttribute('data-id');
        console.log('[Pro] row dblclick', id);
        void setActiveFile(id, {force:true});
      });
    });

    Array.from(list.querySelectorAll('.proFileActionBtn')).forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const row = btn.closest('.proFileRow');
        if(!row) return;
        const id = row.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        openPopover(action, id, btn);
      });
    });

    if(project.popover.openType && project.popover.anchorEl && !document.body.contains(project.popover.anchorEl)){
      closePopover();
    }
  }
  function bind(){
    try{
      const dlg = document.getElementById("proHistoryDialog");
      if(dlg && dlg.parentElement !== document.body) document.body.appendChild(dlg);
      const pop = document.getElementById("proGlobalPopover");
      if(pop && pop.parentElement !== document.body) document.body.appendChild(pop);
      const toastRoot = document.getElementById("toastRoot");
      if(toastRoot && toastRoot.parentElement !== document.body) document.body.appendChild(toastRoot);
    }catch(_){}
    window.__wavcueProAddFiles = addFiles;

    $('proFilterStatus')?.addEventListener('change', (e)=>{
      project.filter.status = e.target.value||'all';
      render();
      console.log(`[Filter] set key=${project.filter.status} visible=${filtered().length}`);
    });
    (function(){
      const sel = document.getElementById('proFilterStatus');
      const lab = document.getElementById('proFilterStubLabel');
      if(!sel || !lab) return;
      const sync = ()=>{
        const opt = sel.options[sel.selectedIndex];
        lab.textContent = opt ? opt.textContent : '全て';
      };
      sync();
      sel.addEventListener('change', sync);
    })();

    $('proBtnBulkImport')?.addEventListener('click', ()=>{
      const gate = guardBulkImport({ source: "button" });
      if(!gate.ok){
        if(window.safeToast) window.safeToast(LICENSE_TEXT.bulkImportPro, "warn");
        return;
      }
      $('proBulkInput')?.click();
    });
    $('proBulkInput')?.addEventListener('change', async (e)=>{
      const files = e.target.files;
      if(!files || !files.length) return;
      const add = window.__wavcueProAddFiles;
      if(typeof add === "function"){
        await add(files);
      }else{
        await loadFile(files[0]);
      }
      e.target.value = "";
    });

    $('proBtnBatchCheck')?.addEventListener('click', ()=> {
      runJob('qc').catch((e)=> console.error("[BulkExport] runJob error", e));
    });
    $('proBtnBatchExport')?.addEventListener('click', ()=> {
      runJob('export').catch((e)=> console.error("[BulkExport] runJob error", e));
    });

    $('proJobMini')?.addEventListener('click', ()=>{
      const gate = guardHistory({ source: "history" });
      if(!gate.ok){
        if(window.safeToast) window.safeToast(LICENSE_TEXT.historyPro, "warn");
        return;
      }
      showJob(true);
    });
    $('proJobClose')?.addEventListener('click', ()=> showJob(false));
    if(!project.historyTriggerLogged){
      project.historyTriggerLogged = true;
      console.log("[UI] historyTrigger=rightOnly");
    }
    $('proJobCopy')?.addEventListener('click', async ()=>{
      try{
        const txt = $('proJobLog')?.innerText || "";
        await navigator.clipboard.writeText(txt);
        logJob("コピーしました", "muted");
      }catch(_){
        logJob("コピーに失敗しました（権限/環境）", "bad");
      }
    });
    $('proJobClear')?.addEventListener('click', ()=>{
      const entries = historyEntries();
      const entry = entries.find(e=>e.id===history.selectedId) || entries[0] || null;
      if(entry){
        entry.logLines = [];
      }
      logJob("クリアしました");
    });
    $('proJobCancel')?.addEventListener('click', ()=> { job.cancel=true; logJob('停止要求'); });
    $('proJobRetryFailed')?.addEventListener('click', ()=>{
      const entries = historyEntries();
      const entry = entries.find(e=>e.id===history.selectedId) || entries[0] || null;
      if(entry && entry.type === "qc" && Array.isArray(entry.failedIds) && entry.failedIds.length){
        runJob('qc', entry.failedIds.slice()).catch((e)=> console.error("[BulkExport] runJob error", e));
      }
    });

    document.addEventListener('click', (e)=>{
      const pop = $('proGlobalPopover');
      if(!pop || pop.classList.contains('hidden')) return;
      if(pop.contains(e.target)) return;
      closePopover();
    });
    document.addEventListener('keydown', (e)=>{ if(e.key==="Escape") closePopover(); });
    window.addEventListener('resize', ()=>{ if(project.popover.openType) positionPopover(); });
    window.addEventListener('scroll', ()=>{ if(project.popover.openType) positionPopover(); }, {passive:true});
    $('proFileListWrap')?.addEventListener('scroll', ()=>{ if(project.popover.openType) positionPopover(); }, {passive:true});

    updateJobUI();
    render();
  }
  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', bind);
  }else{
    bind();
  }
})();
</script>
<!-- ===== QC Preset Export Selector Overlay ===== -->

<dialog aria-label="cmcdプリセットエクスポート選択" class="scExportSelDialog" id="cmcdExportSelDialog">
<div class="box">
<div class="row" style="justify-content:flex-start">
<div style="font-weight:700">エクスポートするcmcdプリセットを選択</div>
</div>
<div class="row" style="margin-top:8px">
<button class="btn ghost" id="cmcd_es_all" style="border-radius:999px;padding:6px 10px" type="button">全選択</button>
<button class="btn ghost" id="cmcd_es_none" style="border-radius:999px;padding:6px 10px" type="button">全解除</button>
<div style="flex:1"></div>
<button class="btn" id="cmcd_es_export" style="border-radius:999px;padding:6px 12px" type="button">エクスポート</button>
</div>
<div class="list" id="cmcd_es_list"></div>
<div class="mutedSmall" style="margin-top:10px">
  選択したプリセットを書き出します。
</div>
</div>
</dialog>

<dialog aria-label="プリセットエクスポート選択" class="scExportSelDialog" id="scExportSelDialog">
<div class="box">
<div class="row" style="justify-content:flex-start">
<div style="font-weight:700">エクスポートするプリセットを選択</div>
</div>
<div class="row" style="margin-top:8px">
<button class="btn ghost" id="sc_es_all" style="border-radius:999px;padding:6px 10px" type="button">全選択</button>
<button class="btn ghost" id="sc_es_none" style="border-radius:999px;padding:6px 10px" type="button">全解除</button>
<div style="flex:1"></div>
<button class="btn" id="sc_es_export" style="border-radius:999px;padding:6px 12px" type="button">エクスポート</button>
</div>
<div class="list" id="sc_es_list"></div>
<div class="mutedSmall" style="margin-top:10px">
      選択したプリセットを書き出します。
    </div>
</div>
</dialog>
</div>

<!-- ===== CHANGELOG ===== -->
<dialog class="dlg" id="changelogDialog" style="max-width:min(760px, 96vw); width:min(760px,96vw);">
  <div class="dlgHead">
    <div class="dlgTitle">変更点</div>
    <button class="btn" id="btnChangelogClose" type="button">閉じる</button>
  </div>
  <div class="dlgBody" style="padding:14px 16px">
    <div class="muted" style="font-size:12px;line-height:1.55">
      この画面はプロトタイプ内の変更点メモです（機能説明ではありません）。
    </div>
    <ul id="changelogList" style="margin:12px 0 0 18px;line-height:1.7;font-size:12px;color:rgba(229,231,235,.88)">
      <li><b>v5_10_16</b>：添付一覧に #1〜#9 の番号バッジを常時表示。順序の説明文を追加。診断スナップショットに attachmentSlots(#番号+ファイル名) を自動添付。</li>
      <li><b>v5_10_14</b>：診断ログボタンをトップバーから撤去し、ログタブ内に「コピー/書き出し」を配置。書き出しテキストへ診断スナップショットを自動添付。</li>
      <li><b>v5_10_13</b>：安定性/診断/進捗バー強化（非対応WAVの早期検知、診断ログコピー、ロード/書き出しフェーズ固定、タイムアウト検知、添付Undo除外）</li>
      <li><b>v5_10_11</b>：44100Hz素材の書き出し後CUEズレ修正（fmt由来sampleRateでin-place patch）</li>
    </ul>
  </div>
</dialog>
<!-- ===== /CHANGELOG ===== -->

<div id="proGlobalPopover" class="proGlobalPopover hidden" role="dialog" aria-hidden="true">
  <div class="proGlobalPopoverInner">
    <div id="proPopTitle" class="proPopTitle"></div>
    <div id="proPopBody" class="proPopBody"></div>
  </div>
</div>
<div aria-atomic="true" aria-live="polite" class="toastHost" id="toastRoot"></div>
<dialog id="toastLayer" class="toastLayer" aria-live="polite" aria-atomic="true">
  <div class="toastHost" id="toastLayerHost"></div>
</dialog>

</body></html>
